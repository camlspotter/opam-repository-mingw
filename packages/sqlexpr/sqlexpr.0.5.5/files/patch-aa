diff -r -u ../ocaml-sqlexpr-0.5.5.orig/configure ./configure
--- ./configure
+++ ./configure
@@ -1,11 +1,11 @@
 #!/bin/sh
 
 # OASIS_START
-# DO NOT EDIT (digest: 425187ed8bfdbdd207fd76392dd243a7)
+# DO NOT EDIT (digest: dc86c2ad450f91ca10c931b6045d0499)
 set -e
 
 FST=true
-for i in "$@"; do 
+for i in "$@"; do
   if $FST; then
     set --
     FST=false
diff -r -u ../ocaml-sqlexpr-0.5.5.orig/Makefile ./Makefile
--- ./Makefile
+++ ./Makefile
@@ -1,5 +1,5 @@
 # OASIS_START
-# DO NOT EDIT (digest: bc1e05bfc8b39b664f29dae8dbd3ebbb)
+# DO NOT EDIT (digest: a3c674b4239234cbbe53afe090018954)
 
 SETUP = ocaml setup.ml
 
@@ -12,7 +12,7 @@
 test: setup.data build
 	$(SETUP) -test $(TESTFLAGS)
 
-all: 
+all:
 	$(SETUP) -all $(ALLFLAGS)
 
 install: setup.data
@@ -24,15 +24,18 @@
 reinstall: setup.data
 	$(SETUP) -reinstall $(REINSTALLFLAGS)
 
-clean: 
+clean:
 	$(SETUP) -clean $(CLEANFLAGS)
 
-distclean: 
+distclean:
 	$(SETUP) -distclean $(DISTCLEANFLAGS)
 
 setup.data:
 	$(SETUP) -configure $(CONFIGUREFLAGS)
 
+configure:
+	$(SETUP) -configure $(CONFIGUREFLAGS)
+
 .PHONY: build doc test all install uninstall reinstall clean distclean configure
 
 # OASIS_STOP
diff -r -u ../ocaml-sqlexpr-0.5.5.orig/META ./META
--- ./META
+++ ./META
@@ -1,10 +1,13 @@
 # OASIS_START
-# DO NOT EDIT (digest: 241cffd68e9612eb6fa812c6118b726f)
+# DO NOT EDIT (digest: 8cbb0be0f3c81dff26276ab1d41f8030)
 version = "0.5.5"
 description = "SQLite database access."
-requires = "csv batteries sqlite3 estring lwt lwt.syntax lwt.unix unix threads"
+requires =
+"csv batteries sqlite3 estring lwt lwt.syntax lwt.unix unix threads"
 archive(byte) = "sqlexpr.cma"
+archive(byte, plugin) = "sqlexpr.cma"
 archive(native) = "sqlexpr.cmxa"
+archive(native, plugin) = "sqlexpr.cmxs"
 exists_if = "sqlexpr.cma"
 package "syntax" (
  version = "0.5.5"
@@ -12,6 +15,8 @@
  requires = "camlp4 estring"
  archive(syntax, preprocessor) = "sqlexpr_syntax.cma"
  archive(syntax, toploop) = "sqlexpr_syntax.cma"
+ archive(syntax, preprocessor, native) = "sqlexpr_syntax.cmxa"
+ archive(syntax, preprocessor, native, plugin) = "sqlexpr_syntax.cmxs"
  exists_if = "sqlexpr_syntax.cma"
 )
 # OASIS_STOP
diff -r -u ../ocaml-sqlexpr-0.5.5.orig/myocamlbuild.ml ./myocamlbuild.ml
--- ./myocamlbuild.ml
+++ ./myocamlbuild.ml
@@ -1,39 +1,50 @@
 (* OASIS_START *)
-(* DO NOT EDIT (digest: 4b0b54727d86f5e35ee2bb2cd5d0d6c7) *)
+(* DO NOT EDIT (digest: dbfe3f56aca87d8ec05501cebd787249) *)
 module OASISGettext = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/oasis/OASISGettext.ml"
-  
+(* # 22 "src/oasis/OASISGettext.ml" *)
+
+
   let ns_ str =
     str
-  
+
+
   let s_ str =
     str
-  
-  let f_ (str : ('a, 'b, 'c, 'd) format4) =
+
+
+  let f_ (str: ('a, 'b, 'c, 'd) format4) =
     str
-  
+
+
   let fn_ fmt1 fmt2 n =
     if n = 1 then
       fmt1^^""
     else
       fmt2^^""
-  
+
+
   let init =
     []
-  
+
+
 end
 
 module OASISExpr = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/oasis/OASISExpr.ml"
-  
-  
-  
+(* # 22 "src/oasis/OASISExpr.ml" *)
+
+
+
+
+
   open OASISGettext
-  
-  type test = string 
-  
-  type flag = string 
-  
+
+
+  type test = string
+
+
+  type flag = string
+
+
   type t =
     | EBool of bool
     | ENot of t
@@ -41,32 +52,34 @@
     | EOr of t * t
     | EFlag of flag
     | ETest of test * string
-    
-  
-  type 'a choices = (t * 'a) list 
-  
+
+
+
+  type 'a choices = (t * 'a) list
+
+
   let eval var_get t =
     let rec eval' =
       function
         | EBool b ->
             b
-  
+
         | ENot e ->
             not (eval' e)
-  
+
         | EAnd (e1, e2) ->
             (eval' e1) && (eval' e2)
-  
+
         | EOr (e1, e2) ->
             (eval' e1) || (eval' e2)
-  
+
         | EFlag nm ->
             let v =
               var_get nm
             in
               assert(v = "true" || v = "false");
               (v = "true")
-  
+
         | ETest (nm, vl) ->
             let v =
               var_get nm
@@ -74,7 +87,8 @@
               (v = vl)
     in
       eval' t
-  
+
+
   let choose ?printer ?name var_get lst =
     let rec choose_aux =
       function
@@ -110,22 +124,28 @@
                          str_lst)
     in
       choose_aux (List.rev lst)
-  
+
+
 end
 
 
+# 132 "myocamlbuild.ml"
 module BaseEnvLight = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/base/BaseEnvLight.ml"
-  
+(* # 22 "src/base/BaseEnvLight.ml" *)
+
+
   module MapString = Map.Make(String)
-  
+
+
   type t = string MapString.t
-  
+
+
   let default_filename =
     Filename.concat
       (Sys.getcwd ())
       "setup.data"
-  
+
+
   let load ?(allow_empty=false) ?(filename=default_filename) () =
     if Sys.file_exists filename then
       begin
@@ -182,28 +202,31 @@
              "Unable to load environment, the file '%s' doesn't exist."
              filename)
       end
-  
-  let var_get name env =
-    let rec var_expand str =
-      let buff =
-        Buffer.create ((String.length str) * 2)
-      in
-        Buffer.add_substitute
-          buff
-          (fun var ->
-             try
-               var_expand (MapString.find var env)
-             with Not_found ->
-               failwith
-                 (Printf.sprintf
-                    "No variable %s defined when trying to expand %S."
-                    var
-                    str))
-          str;
-        Buffer.contents buff
+
+
+  let rec var_expand str env =
+    let buff =
+      Buffer.create ((String.length str) * 2)
     in
-      var_expand (MapString.find name env)
-  
+      Buffer.add_substitute
+        buff
+        (fun var ->
+           try
+             var_expand (MapString.find var env) env
+           with Not_found ->
+             failwith
+               (Printf.sprintf
+                  "No variable %s defined when trying to expand %S."
+                  var
+                  str))
+        str;
+      Buffer.contents buff
+
+
+  let var_get name env =
+    var_expand (MapString.find name env) env
+
+
   let var_choose lst env =
     OASISExpr.choose
       (fun nm -> var_get nm env)
@@ -211,169 +234,264 @@
 end
 
 
+# 237 "myocamlbuild.ml"
 module MyOCamlbuildFindlib = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/plugins/ocamlbuild/MyOCamlbuildFindlib.ml"
-  
-  (** OCamlbuild extension, copied from 
+(* # 22 "src/plugins/ocamlbuild/MyOCamlbuildFindlib.ml" *)
+
+
+  (** OCamlbuild extension, copied from
     * http://brion.inria.fr/gallium/index.php/Using_ocamlfind_with_ocamlbuild
     * by N. Pouillard and others
     *
     * Updated on 2009/02/28
     *
-    * Modified by Sylvain Le Gall 
+    * Modified by Sylvain Le Gall
     *)
   open Ocamlbuild_plugin
-  
+
+  type conf =
+    { no_automatic_syntax: bool;
+    }
+
   (* these functions are not really officially exported *)
-  let run_and_read = 
+  let run_and_read =
     Ocamlbuild_pack.My_unix.run_and_read
-  
-  let blank_sep_strings = 
+
+
+  let blank_sep_strings =
     Ocamlbuild_pack.Lexers.blank_sep_strings
-  
-  let split s ch =
-    let x = 
-      ref [] 
+
+
+  let exec_from_conf exec =
+    let exec =
+      let env_filename = Pathname.basename BaseEnvLight.default_filename in
+      let env = BaseEnvLight.load ~filename:env_filename ~allow_empty:true () in
+      try
+        BaseEnvLight.var_get exec env
+      with Not_found ->
+        Printf.eprintf "W: Cannot get variable %s\n" exec;
+        exec
+    in
+    let fix_win32 str =
+      if Sys.os_type = "Win32" then begin
+        let buff = Buffer.create (String.length str) in
+        (* Adapt for windowsi, ocamlbuild + win32 has a hard time to handle '\\'.
+         *)
+        String.iter
+          (fun c -> Buffer.add_char buff (if c = '\\' then '/' else c))
+          str;
+        Buffer.contents buff
+      end else begin
+        str
+      end
     in
-    let rec go s =
-      let pos = 
-        String.index s ch 
-      in
-        x := (String.before s pos)::!x;
-        go (String.after s (pos + 1))
+      fix_win32 exec
+
+  let split s ch =
+    let buf = Buffer.create 13 in
+    let x = ref [] in
+    let flush () =
+      x := (Buffer.contents buf) :: !x;
+      Buffer.clear buf
     in
-      try
-        go s
-      with Not_found -> !x
-  
+      String.iter
+        (fun c ->
+           if c = ch then
+             flush ()
+           else
+             Buffer.add_char buf c)
+        s;
+      flush ();
+      List.rev !x
+
+
   let split_nl s = split s '\n'
-  
+
+
   let before_space s =
     try
       String.before s (String.index s ' ')
     with Not_found -> s
-  
-  (* this lists all supported packages *)
+
+  (* ocamlfind command *)
+  let ocamlfind x = S[Sh (
+    Ocamlbuild_pack.Shell.quote_filename_if_needed
+      (exec_from_conf "ocamlfind") ); x]
+
+  (* This lists all supported packages. *)
   let find_packages () =
-    List.map before_space (split_nl & run_and_read "ocamlfind list")
-  
-  (* this is supposed to list available syntaxes, but I don't know how to do it. *)
+    List.map before_space (split_nl & run_and_read (exec_from_conf "ocamlfind" ^ " list"))
+
+
+  (* Mock to list available syntaxes. *)
   let find_syntaxes () = ["camlp4o"; "camlp4r"]
-  
-  (* ocamlfind command *)
-  let ocamlfind x = S[A"ocamlfind"; x]
-  
-  let dispatch =
+
+
+  let well_known_syntax = [
+    "camlp4.quotations.o";
+    "camlp4.quotations.r";
+    "camlp4.exceptiontracer";
+    "camlp4.extend";
+    "camlp4.foldgenerator";
+    "camlp4.listcomprehension";
+    "camlp4.locationstripper";
+    "camlp4.macro";
+    "camlp4.mapgenerator";
+    "camlp4.metagenerator";
+    "camlp4.profiler";
+    "camlp4.tracer"
+  ]
+
+
+  let dispatch conf =
     function
-      | Before_options ->
-          (* by using Before_options one let command line options have an higher priority *)
-          (* on the contrary using After_options will guarantee to have the higher priority *)
-          (* override default commands by ocamlfind ones *)
+      | After_options ->
+          (* By using Before_options one let command line options have an higher
+           * priority on the contrary using After_options will guarantee to have
+           * the higher priority override default commands by ocamlfind ones *)
           Options.ocamlc     := ocamlfind & A"ocamlc";
           Options.ocamlopt   := ocamlfind & A"ocamlopt";
           Options.ocamldep   := ocamlfind & A"ocamldep";
           Options.ocamldoc   := ocamlfind & A"ocamldoc";
-          Options.ocamlmktop := ocamlfind & A"ocamlmktop"
-                                  
+          Options.ocamlmktop := ocamlfind & A"ocamlmktop";
+          Options.ocamlmklib := ocamlfind & A"ocamlmklib"
+
       | After_rules ->
-          
-          (* When one link an OCaml library/binary/package, one should use -linkpkg *)
+
+          (* When one link an OCaml library/binary/package, one should use
+           * -linkpkg *)
           flag ["ocaml"; "link"; "program"] & A"-linkpkg";
-          
-          (* For each ocamlfind package one inject the -package option when
-           * compiling, computing dependencies, generating documentation and
-           * linking. *)
-          List.iter 
-            begin fun pkg ->
-              flag ["ocaml"; "compile";  "pkg_"^pkg] & S[A"-package"; A pkg];
-              flag ["ocaml"; "ocamldep"; "pkg_"^pkg] & S[A"-package"; A pkg];
-              flag ["ocaml"; "doc";      "pkg_"^pkg] & S[A"-package"; A pkg];
-              flag ["ocaml"; "link";     "pkg_"^pkg] & S[A"-package"; A pkg];
-              flag ["ocaml"; "infer_interface"; "pkg_"^pkg] & S[A"-package"; A pkg];
-            end 
-            (find_packages ());
-  
+
+          if not (conf.no_automatic_syntax) then begin
+            (* For each ocamlfind package one inject the -package option when
+             * compiling, computing dependencies, generating documentation and
+             * linking. *)
+            List.iter
+              begin fun pkg ->
+                let base_args = [A"-package"; A pkg] in
+                (* TODO: consider how to really choose camlp4o or camlp4r. *)
+                let syn_args = [A"-syntax"; A "camlp4o"] in
+                let (args, pargs) =
+                  (* Heuristic to identify syntax extensions: whether they end in
+                     ".syntax"; some might not.
+                  *)
+                  if Filename.check_suffix pkg "syntax" ||
+                     List.mem pkg well_known_syntax then
+                    (syn_args @ base_args, syn_args)
+                  else
+                    (base_args, [])
+                in
+                flag ["ocaml"; "compile";  "pkg_"^pkg] & S args;
+                flag ["ocaml"; "ocamldep"; "pkg_"^pkg] & S args;
+                flag ["ocaml"; "doc";      "pkg_"^pkg] & S args;
+                flag ["ocaml"; "link";     "pkg_"^pkg] & S base_args;
+                flag ["ocaml"; "infer_interface"; "pkg_"^pkg] & S args;
+
+                (* TODO: Check if this is allowed for OCaml < 3.12.1 *)
+                flag ["ocaml"; "compile";  "package("^pkg^")"] & S pargs;
+                flag ["ocaml"; "ocamldep"; "package("^pkg^")"] & S pargs;
+                flag ["ocaml"; "doc";      "package("^pkg^")"] & S pargs;
+                flag ["ocaml"; "infer_interface"; "package("^pkg^")"] & S pargs;
+              end
+              (find_packages ());
+          end;
+
           (* Like -package but for extensions syntax. Morover -syntax is useless
            * when linking. *)
           List.iter begin fun syntax ->
           flag ["ocaml"; "compile";  "syntax_"^syntax] & S[A"-syntax"; A syntax];
           flag ["ocaml"; "ocamldep"; "syntax_"^syntax] & S[A"-syntax"; A syntax];
           flag ["ocaml"; "doc";      "syntax_"^syntax] & S[A"-syntax"; A syntax];
-          flag ["ocaml"; "infer_interface"; "syntax_"^syntax] & S[A"-syntax"; A syntax];
+          flag ["ocaml"; "infer_interface"; "syntax_"^syntax] &
+                S[A"-syntax"; A syntax];
           end (find_syntaxes ());
-  
+
           (* The default "thread" tag is not compatible with ocamlfind.
            * Indeed, the default rules add the "threads.cma" or "threads.cmxa"
            * options when using this tag. When using the "-linkpkg" option with
            * ocamlfind, this module will then be added twice on the command line.
-           *                        
+           *
            * To solve this, one approach is to add the "-thread" option when using
            * the "threads" package using the previous plugin.
            *)
           flag ["ocaml"; "pkg_threads"; "compile"] (S[A "-thread"]);
           flag ["ocaml"; "pkg_threads"; "doc"] (S[A "-I"; A "+threads"]);
           flag ["ocaml"; "pkg_threads"; "link"] (S[A "-thread"]);
-          flag ["ocaml"; "pkg_threads"; "infer_interface"] (S[A "-thread"])
-  
-      | _ -> 
+          flag ["ocaml"; "pkg_threads"; "infer_interface"] (S[A "-thread"]);
+          flag ["ocaml"; "package(threads)"; "compile"] (S[A "-thread"]);
+          flag ["ocaml"; "package(threads)"; "doc"] (S[A "-I"; A "+threads"]);
+          flag ["ocaml"; "package(threads)"; "link"] (S[A "-thread"]);
+          flag ["ocaml"; "package(threads)"; "infer_interface"] (S[A "-thread"]);
+
+      | _ ->
           ()
-  
 end
 
 module MyOCamlbuildBase = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/plugins/ocamlbuild/MyOCamlbuildBase.ml"
-  
+(* # 22 "src/plugins/ocamlbuild/MyOCamlbuildBase.ml" *)
+
+
   (** Base functions for writing myocamlbuild.ml
       @author Sylvain Le Gall
     *)
-  
-  
-  
+
+
+
+
+
   open Ocamlbuild_plugin
   module OC = Ocamlbuild_pack.Ocaml_compiler
-  
-  type dir = string 
-  type file = string 
-  type name = string 
-  type tag = string 
-  
-# 56 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/plugins/ocamlbuild/MyOCamlbuildBase.ml"
-  
+
+
+  type dir = string
+  type file = string
+  type name = string
+  type tag = string
+
+
+(* # 62 "src/plugins/ocamlbuild/MyOCamlbuildBase.ml" *)
+
+
   type t =
       {
-        lib_ocaml: (name * dir list) list;
-        lib_c:     (name * dir * file list) list; 
+        lib_ocaml: (name * dir list * string list) list;
+        lib_c:     (name * dir * file list) list;
         flags:     (tag list * (spec OASISExpr.choices)) list;
         (* Replace the 'dir: include' from _tags by a precise interdepends in
          * directory.
          *)
-        includes:  (dir * dir list) list; 
-      } 
-  
+        includes:  (dir * dir list) list;
+      }
+
+
   let env_filename =
-    Pathname.basename 
+    Pathname.basename
       BaseEnvLight.default_filename
-  
+
+
   let dispatch_combine lst =
     fun e ->
-      List.iter 
+      List.iter
         (fun dispatch -> dispatch e)
-        lst 
-  
+        lst
+
+
   let tag_libstubs nm =
     "use_lib"^nm^"_stubs"
-  
+
+
   let nm_libstubs nm =
     nm^"_stubs"
-  
-  let dispatch t e = 
-    let env = 
-      BaseEnvLight.load 
-        ~filename:env_filename 
+
+
+  let dispatch t e =
+    let env =
+      BaseEnvLight.load
+        ~filename:env_filename
         ~allow_empty:true
         ()
     in
-      match e with 
+      match e with
         | Before_options ->
             let no_trailing_dot s =
               if String.length s >= 1 && s.[0] = '.' then
@@ -383,111 +501,48 @@
             in
               List.iter
                 (fun (opt, var) ->
-                   try 
+                   try
                      opt := no_trailing_dot (BaseEnvLight.var_get var env)
                    with Not_found ->
-                     Printf.eprintf "W: Cannot get variable %s" var)
+                     Printf.eprintf "W: Cannot get variable %s\n" var)
                 [
                   Options.ext_obj, "ext_obj";
                   Options.ext_lib, "ext_lib";
                   Options.ext_dll, "ext_dll";
                 ]
-  
-        | Before_rules ->
-          (* TODO: move this into its own file and conditionnaly include it, if
-           * needed.
-           *)
-          (* OCaml cmxs rules: cmxs available in ocamlopt but not ocamlbuild.
-             Copied from ocaml_specific.ml in ocamlbuild sources. *)
-          let has_native_dynlink =
-            try
-              bool_of_string (BaseEnvLight.var_get "native_dynlink" env)
-            with Not_found ->
-              false
-          in
-          if has_native_dynlink && String.sub Sys.ocaml_version 0 4 = "3.11" then
-            begin
-              let ext_lib = !Options.ext_lib in
-              let ext_obj = !Options.ext_obj in
-              let ext_dll = !Options.ext_dll in
-              let x_o = "%"-.-ext_obj in
-              let x_a = "%"-.-ext_lib in
-              let x_dll = "%"-.-ext_dll in
-              let x_p_o = "%.p"-.-ext_obj in
-              let x_p_a = "%.p"-.-ext_lib in
-              let x_p_dll = "%.p"-.-ext_dll in
-  
-              rule "ocaml: mldylib & p.cmx* & p.o* -> p.cmxs & p.so"
-                   ~tags:["ocaml"; "native"; "profile"; "shared"; "library"]
-                   ~prods:["%.p.cmxs"; x_p_dll]
-                   ~dep:"%.mldylib"
-                   (OC.native_profile_shared_library_link_mldylib
-                      "%.mldylib" "%.p.cmxs");
-  
-              rule "ocaml: mldylib & cmx* & o* -> cmxs & so"
-                   ~tags:["ocaml"; "native"; "shared"; "library"]
-                   ~prods:["%.cmxs"; x_dll]
-                   ~dep:"%.mldylib"
-                   (OC.native_shared_library_link_mldylib
-                      "%.mldylib" "%.cmxs");
-  
-              rule "ocaml: p.cmx & p.o -> p.cmxs & p.so"
-                   ~tags:["ocaml"; "native"; "profile"; "shared"; "library"]
-                   ~prods:["%.p.cmxs"; x_p_dll]
-                   ~deps:["%.p.cmx"; x_p_o]
-                   (OC.native_shared_library_link ~tags:["profile"]
-                                                  "%.p.cmx" "%.p.cmxs");
-  
-              rule "ocaml: p.cmxa & p.a -> p.cmxs & p.so"
-                   ~tags:["ocaml"; "native"; "profile"; "shared"; "library"]
-                   ~prods:["%.p.cmxs"; x_p_dll]
-                   ~deps:["%.p.cmxa"; x_p_a]
-                   (OC.native_shared_library_link ~tags:["profile"; "linkall"]
-                                                  "%.p.cmxa" "%.p.cmxs");
-  
-              rule "ocaml: cmx & o -> cmxs"
-                   ~tags:["ocaml"; "native"; "shared"; "library"]
-                   ~prods:["%.cmxs"]
-                   ~deps:["%.cmx"; x_o]
-                   (OC.native_shared_library_link "%.cmx" "%.cmxs");
-  
-              rule "ocaml: cmx & o -> cmxs & so"
-                   ~tags:["ocaml"; "native"; "shared"; "library"]
-                   ~prods:["%.cmxs"; x_dll]
-                   ~deps:["%.cmx"; x_o]
-                   (OC.native_shared_library_link "%.cmx" "%.cmxs");
-  
-              rule "ocaml: cmxa & a -> cmxs & so"
-                   ~tags:["ocaml"; "native"; "shared"; "library"]
-                   ~prods:["%.cmxs"; x_dll]
-                   ~deps:["%.cmxa"; x_a]
-                   (OC.native_shared_library_link ~tags:["linkall"]
-                                                  "%.cmxa" "%.cmxs");
-            end
-  
-        | After_rules -> 
+
+        | After_rules ->
             (* Declare OCaml libraries *)
-            List.iter 
+            List.iter
               (function
-                 | nm, [] ->
-                     ocaml_lib nm
-                 | nm, dir :: tl ->
+                 | nm, [], intf_modules ->
+                     ocaml_lib nm;
+                     let cmis =
+                       List.map (fun m -> (String.uncapitalize m) ^ ".cmi")
+                                intf_modules in
+                     dep ["ocaml"; "link"; "library"; "file:"^nm^".cma"] cmis
+                 | nm, dir :: tl, intf_modules ->
                      ocaml_lib ~dir:dir (dir^"/"^nm);
-                     List.iter 
-                       (fun dir -> 
+                     List.iter
+                       (fun dir ->
                           List.iter
                             (fun str ->
                                flag ["ocaml"; "use_"^nm; str] (S[A"-I"; P dir]))
                             ["compile"; "infer_interface"; "doc"])
-                       tl)
+                       tl;
+                     let cmis =
+                       List.map (fun m -> dir^"/"^(String.uncapitalize m)^".cmi")
+                                intf_modules in
+                     dep ["ocaml"; "link"; "library"; "file:"^dir^"/"^nm^".cma"]
+                         cmis)
               t.lib_ocaml;
-  
+
             (* Declare directories dependencies, replace "include" in _tags. *)
-            List.iter 
+            List.iter
               (fun (dir, include_dirs) ->
                  Pathname.define_context dir include_dirs)
               t.includes;
-  
+
             (* Declare C libraries *)
             List.iter
               (fun (lib, dir, headers) ->
@@ -495,66 +550,77 @@
                    flag ["link"; "library"; "ocaml"; "byte"; tag_libstubs lib]
                      (S[A"-dllib"; A("-l"^(nm_libstubs lib)); A"-cclib";
                         A("-l"^(nm_libstubs lib))]);
-  
+
                    flag ["link"; "library"; "ocaml"; "native"; tag_libstubs lib]
                      (S[A"-cclib"; A("-l"^(nm_libstubs lib))]);
-                        
+
                    flag ["link"; "program"; "ocaml"; "byte"; tag_libstubs lib]
                      (S[A"-dllib"; A("dll"^(nm_libstubs lib))]);
-  
+
                    (* When ocaml link something that use the C library, then one
                       need that file to be up to date.
+                      This holds both for programs and for libraries.
                     *)
-                   dep  ["link"; "ocaml"; "program"; tag_libstubs lib]
-                     [dir/"lib"^(nm_libstubs lib)^"."^(!Options.ext_lib)];
-  
-                   dep  ["compile"; "ocaml"; "program"; tag_libstubs lib]
-                     [dir/"lib"^(nm_libstubs lib)^"."^(!Options.ext_lib)];
-  
+  		 dep ["link"; "ocaml"; tag_libstubs lib]
+  		     [dir/"lib"^(nm_libstubs lib)^"."^(!Options.ext_lib)];
+
+  		 dep  ["compile"; "ocaml"; tag_libstubs lib]
+  		      [dir/"lib"^(nm_libstubs lib)^"."^(!Options.ext_lib)];
+
                    (* TODO: be more specific about what depends on headers *)
                    (* Depends on .h files *)
-                   dep ["compile"; "c"] 
+                   dep ["compile"; "c"]
                      headers;
-  
+
                    (* Setup search path for lib *)
-                   flag ["link"; "ocaml"; "use_"^lib] 
+                   flag ["link"; "ocaml"; "use_"^lib]
                      (S[A"-I"; P(dir)]);
               )
               t.lib_c;
-  
+
               (* Add flags *)
               List.iter
               (fun (tags, cond_specs) ->
-                 let spec = 
-                   BaseEnvLight.var_choose cond_specs env
+                 let spec = BaseEnvLight.var_choose cond_specs env in
+                 let rec eval_specs =
+                   function
+                     | S lst -> S (List.map eval_specs lst)
+                     | A str -> A (BaseEnvLight.var_expand str env)
+                     | spec -> spec
                  in
-                   flag tags & spec)
+                   flag tags & (eval_specs spec))
               t.flags
-        | _ -> 
+        | _ ->
             ()
-  
-  let dispatch_default t =
-    dispatch_combine 
+
+
+  let dispatch_default conf t =
+    dispatch_combine
       [
         dispatch t;
-        MyOCamlbuildFindlib.dispatch;
+        MyOCamlbuildFindlib.dispatch conf;
       ]
-  
+
+
 end
 
 
+# 608 "myocamlbuild.ml"
 open Ocamlbuild_plugin;;
 let package_default =
   {
-     MyOCamlbuildBase.lib_ocaml = [("sqlexpr_syntax", []); ("sqlexpr", [])];
+     MyOCamlbuildBase.lib_ocaml =
+       [("sqlexpr", [], []); ("sqlexpr_syntax", [], [])];
      lib_c = [];
      flags = [];
-     includes = [];
-     }
+     includes = []
+  }
   ;;
 
-let dispatch_default = MyOCamlbuildBase.dispatch_default package_default;;
+let conf = {MyOCamlbuildFindlib.no_automatic_syntax = false}
+
+let dispatch_default = MyOCamlbuildBase.dispatch_default conf package_default;;
 
-# 559 "myocamlbuild.ml"
+# 625 "myocamlbuild.ml"
 (* OASIS_STOP *)
 Ocamlbuild_plugin.dispatch dispatch_default;;
diff -r -u ../ocaml-sqlexpr-0.5.5.orig/setup.ml ./setup.ml
--- ./setup.ml
+++ ./setup.ml
@@ -1,55 +1,67 @@
 (* setup.ml generated for the first time by OASIS v0.3.0~rc3 *)
 
 (* OASIS_START *)
-(* DO NOT EDIT (digest: ccd9eaf3540d2c44a7a4a4bea21eb33a) *)
+(* DO NOT EDIT (digest: 34f7c2fba699f0bd655b747c2cee68ee) *)
 (*
-   Regenerated by OASIS v0.3.0~rc3
+   Regenerated by OASIS v0.4.5
    Visit http://oasis.forge.ocamlcore.org for more information and
    documentation about functions used in this file.
 *)
 module OASISGettext = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/oasis/OASISGettext.ml"
-  
+(* # 22 "src/oasis/OASISGettext.ml" *)
+
+
   let ns_ str =
     str
-  
+
+
   let s_ str =
     str
-  
-  let f_ (str : ('a, 'b, 'c, 'd) format4) =
+
+
+  let f_ (str: ('a, 'b, 'c, 'd) format4) =
     str
-  
+
+
   let fn_ fmt1 fmt2 n =
     if n = 1 then
       fmt1^^""
     else
       fmt2^^""
-  
+
+
   let init =
     []
-  
+
+
 end
 
 module OASISContext = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/oasis/OASISContext.ml"
-  
+(* # 22 "src/oasis/OASISContext.ml" *)
+
+
   open OASISGettext
-  
+
+
   type level =
     [ `Debug
     | `Info
     | `Warning
     | `Error]
-  
+
+
   type t =
     {
-      verbose:               bool;
+      (* TODO: replace this by a proplist. *)
+      quiet:                 bool;
+      info:                  bool;
       debug:                 bool;
       ignore_plugins:        bool;
       ignore_unknown_fields: bool;
       printf:                level -> string -> unit;
     }
-  
+
+
   let printf lvl str =
     let beg =
       match lvl with
@@ -59,117 +71,295 @@
         | `Debug -> s_ "D: "
     in
       prerr_endline (beg^str)
-  
+
+
   let default =
     ref
       {
-        verbose               = true;
+        quiet                 = false;
+        info                  = false;
         debug                 = false;
         ignore_plugins        = false;
         ignore_unknown_fields = false;
         printf                = printf;
       }
-  
+
+
   let quiet =
-    {!default with
-         verbose = false;
-         debug   = false;
-    }
-  
-  
-  let args () =
+    {!default with quiet = true}
+
+
+  let fspecs () =
+    (* TODO: don't act on default. *)
+    let ignore_plugins = ref false in
     ["-quiet",
-     Arg.Unit (fun () -> default := {!default with verbose = false}),
-     (s_ " Run quietly");
-  
+     Arg.Unit (fun () -> default := {!default with quiet = true}),
+     s_ " Run quietly";
+
+     "-info",
+     Arg.Unit (fun () -> default := {!default with info = true}),
+     s_ " Display information message";
+
+
      "-debug",
      Arg.Unit (fun () -> default := {!default with debug = true}),
-     (s_ " Output debug message")]
+     s_ " Output debug message";
+
+     "-ignore-plugins",
+     Arg.Set ignore_plugins,
+     s_ " Ignore plugin's field.";
+
+     "-C",
+     (* TODO: remove this chdir. *)
+     Arg.String (fun str -> Sys.chdir str),
+     s_ "dir Change directory before running."],
+    fun () -> {!default with ignore_plugins = !ignore_plugins}
+end
+
+module OASISString = struct
+(* # 22 "src/oasis/OASISString.ml" *)
+
+
+  (** Various string utilities.
+
+      Mostly inspired by extlib and batteries ExtString and BatString libraries.
+
+      @author Sylvain Le Gall
+    *)
+
+
+  let nsplitf str f =
+    if str = "" then
+      []
+    else
+      let buf = Buffer.create 13 in
+      let lst = ref [] in
+      let push () =
+        lst := Buffer.contents buf :: !lst;
+        Buffer.clear buf
+      in
+      let str_len = String.length str in
+        for i = 0 to str_len - 1 do
+          if f str.[i] then
+            push ()
+          else
+            Buffer.add_char buf str.[i]
+        done;
+        push ();
+        List.rev !lst
+
+
+  (** [nsplit c s] Split the string [s] at char [c]. It doesn't include the
+      separator.
+    *)
+  let nsplit str c =
+    nsplitf str ((=) c)
+
+
+  let find ~what ?(offset=0) str =
+    let what_idx = ref 0 in
+    let str_idx = ref offset in
+      while !str_idx < String.length str &&
+            !what_idx < String.length what do
+        if str.[!str_idx] = what.[!what_idx] then
+          incr what_idx
+        else
+          what_idx := 0;
+        incr str_idx
+      done;
+      if !what_idx <> String.length what then
+        raise Not_found
+      else
+        !str_idx - !what_idx
+
+
+  let sub_start str len =
+    let str_len = String.length str in
+    if len >= str_len then
+      ""
+    else
+      String.sub str len (str_len - len)
+
+
+  let sub_end ?(offset=0) str len =
+    let str_len = String.length str in
+    if len >= str_len then
+      ""
+    else
+      String.sub str 0 (str_len - len)
+
+
+  let starts_with ~what ?(offset=0) str =
+    let what_idx = ref 0 in
+    let str_idx = ref offset in
+    let ok = ref true in
+      while !ok &&
+            !str_idx < String.length str &&
+            !what_idx < String.length what do
+        if str.[!str_idx] = what.[!what_idx] then
+          incr what_idx
+        else
+          ok := false;
+        incr str_idx
+      done;
+      if !what_idx = String.length what then
+        true
+      else
+        false
+
+
+  let strip_starts_with ~what str =
+    if starts_with ~what str then
+      sub_start str (String.length what)
+    else
+      raise Not_found
+
+
+  let ends_with ~what ?(offset=0) str =
+    let what_idx = ref ((String.length what) - 1) in
+    let str_idx = ref ((String.length str) - 1) in
+    let ok = ref true in
+      while !ok &&
+            offset <= !str_idx &&
+            0 <= !what_idx do
+        if str.[!str_idx] = what.[!what_idx] then
+          decr what_idx
+        else
+          ok := false;
+        decr str_idx
+      done;
+      if !what_idx = -1 then
+        true
+      else
+        false
+
+
+  let strip_ends_with ~what str =
+    if ends_with ~what str then
+      sub_end str (String.length what)
+    else
+      raise Not_found
+
+
+  let replace_chars f s =
+    let buf = Buffer.create (String.length s) in
+    String.iter (fun c -> Buffer.add_char buf (f c)) s;
+    Buffer.contents buf
+
+  (** Like List.exists, but for strings *)
+  let exists f str =
+    let rec iter i =
+      if i < 0 then
+        false
+      else if f str.[i] then
+        true
+      else
+        iter (pred i)
+    in
+      iter (String.length str - 1)
+
+  let is_digit c =
+    '0' <= c && c <= '9'
+
+  let is_alpha c =
+    ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')
+
+  let is_whitespace =
+    function
+      | ' ' | '\r' | '\n' | '\t' -> true
+      |  _  -> false
+
 end
 
 module OASISUtils = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/oasis/OASISUtils.ml"
-  
+(* # 22 "src/oasis/OASISUtils.ml" *)
+
+
   open OASISGettext
-  
-  module MapString = Map.Make(String)
-  
-  let map_string_of_assoc assoc =
-    List.fold_left
-      (fun acc (k, v) -> MapString.add k v acc)
-      MapString.empty
-      assoc
-  
-  module SetString = Set.Make(String)
-  
-  let set_string_add_list st lst =
-    List.fold_left
-      (fun acc e -> SetString.add e acc)
-      st
-      lst
-  
-  let set_string_of_list =
-    set_string_add_list
-      SetString.empty
-  
-  
+
+
+  module MapExt =
+  struct
+    module type S =
+    sig
+      include Map.S
+      val add_list: 'a t -> (key * 'a) list -> 'a t
+      val of_list: (key * 'a) list -> 'a t
+      val to_list: 'a t -> (key * 'a) list
+    end
+
+    module Make (Ord: Map.OrderedType) =
+    struct
+      include Map.Make(Ord)
+
+      let rec add_list t =
+        function
+          | (k, v) :: tl -> add_list (add k v t) tl
+          | [] -> t
+
+      let of_list lst = add_list empty lst
+
+      let to_list t = fold (fun k v acc -> (k, v) :: acc) t []
+    end
+  end
+
+
+  module MapString = MapExt.Make(String)
+
+
+  module SetExt  =
+  struct
+    module type S =
+    sig
+      include Set.S
+      val add_list: t -> elt list -> t
+      val of_list: elt list -> t
+      val to_list: t -> elt list
+    end
+
+    module Make (Ord: Set.OrderedType) =
+    struct
+      include Set.Make(Ord)
+
+      let rec add_list t =
+        function
+          | e :: tl -> add_list (add e t) tl
+          | [] -> t
+
+      let of_list lst = add_list empty lst
+
+      let to_list = elements
+    end
+  end
+
+
+  module SetString = SetExt.Make(String)
+
+
   let compare_csl s1 s2 =
     String.compare (String.lowercase s1) (String.lowercase s2)
-  
+
+
   module HashStringCsl =
     Hashtbl.Make
       (struct
          type t = string
-  
+
          let equal s1 s2 =
              (String.lowercase s1) = (String.lowercase s2)
-  
+
          let hash s =
            Hashtbl.hash (String.lowercase s)
        end)
-  
-  let split sep str =
-    let str_len =
-      String.length str
-    in
-    let rec split_aux acc pos =
-      if pos < str_len then
-        (
-          let pos_sep =
-            try
-              String.index_from str pos sep
-            with Not_found ->
-              str_len
-          in
-          let part =
-            String.sub str pos (pos_sep - pos)
-          in
-          let acc =
-            part :: acc
-          in
-            if pos_sep >= str_len then
-              (
-                (* Nothing more in the string *)
-                List.rev acc
-              )
-            else if pos_sep = (str_len - 1) then
-              (
-                (* String end with a separator *)
-                List.rev ("" :: acc)
-              )
-            else
-              (
-                split_aux acc (pos_sep + 1)
-              )
-        )
-      else
-        (
-          List.rev acc
-        )
-    in
-      split_aux [] 0
-  
-  
+
+  module SetStringCsl =
+    SetExt.Make
+      (struct
+         type t = string
+         let compare = compare_csl
+       end)
+
+
   let varname_of_string ?(hyphen='_') s =
     if String.length s = 0 then
       begin
@@ -177,117 +367,109 @@
       end
     else
       begin
-        let buff =
-          Buffer.create (String.length s)
-        in
-          (* Start with a _ if digit *)
-          if '0' <= s.[0] && s.[0] <= '9' then
-            Buffer.add_char buff hyphen;
-  
-          String.iter
+        let buf =
+          OASISString.replace_chars
             (fun c ->
                if ('a' <= c && c <= 'z')
                  ||
                   ('A' <= c && c <= 'Z')
                  ||
                   ('0' <= c && c <= '9') then
-                 Buffer.add_char buff c
+                 c
                else
-                 Buffer.add_char buff hyphen)
+                 hyphen)
             s;
-  
-          String.lowercase (Buffer.contents buff)
+        in
+        let buf =
+          (* Start with a _ if digit *)
+          if '0' <= s.[0] && s.[0] <= '9' then
+            "_"^buf
+          else
+            buf
+        in
+          String.lowercase buf
       end
-  
+
+
   let varname_concat ?(hyphen='_') p s =
+    let what = String.make 1 hyphen in
     let p =
-      let p_len =
-        String.length p
-      in
-        if p_len > 0 && p.[p_len - 1] = hyphen then
-          String.sub p 0 (p_len - 1)
-        else
-          p
+      try
+        OASISString.strip_ends_with ~what p
+      with Not_found ->
+        p
     in
     let s =
-      let s_len =
-        String.length s
-      in
-        if s_len > 0 && s.[0] = hyphen then
-          String.sub s 1 (s_len - 1)
-        else
-          s
+      try
+        OASISString.strip_starts_with ~what s
+      with Not_found ->
+        s
     in
-      Printf.sprintf "%s%c%s" p hyphen s
-  
-  
+      p^what^s
+
+
   let is_varname str =
     str = varname_of_string str
-  
+
+
   let failwithf fmt = Printf.ksprintf failwith fmt
-  
-  let file_exists fn = 
-    let dirname = Filename.dirname fn in
-    let basename = Filename.basename fn in
-      if Sys.file_exists dirname then
-        if basename = Filename.current_dir_name then
-          true
-        else
-          List.mem
-            basename
-            (Array.to_list (Sys.readdir dirname))
-      else
-        false
-  
+
+
 end
 
 module PropList = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/oasis/PropList.ml"
-  
+(* # 22 "src/oasis/PropList.ml" *)
+
+
   open OASISGettext
-  
+
+
   type name = string
-  
+
+
   exception Not_set of name * string option
   exception No_printer of name
   exception Unknown_field of name * name
-  
+
+
   let () =
     Printexc.register_printer
       (function
          | Not_set (nm, Some rsn) ->
-             Some 
+             Some
                (Printf.sprintf (f_ "Field '%s' is not set: %s") nm rsn)
          | Not_set (nm, None) ->
-             Some 
+             Some
                (Printf.sprintf (f_ "Field '%s' is not set") nm)
          | No_printer nm ->
              Some
                (Printf.sprintf (f_ "No default printer for value %s") nm)
          | Unknown_field (nm, schm) ->
-             Some 
-               (Printf.sprintf (f_ "Field %s is not defined in schema %s") nm schm)
+             Some
+               (Printf.sprintf
+                  (f_ "Field %s is not defined in schema %s") nm schm)
          | _ ->
              None)
-  
+
+
   module Data =
   struct
-  
     type t =
         (name, unit -> unit) Hashtbl.t
-  
+
     let create () =
       Hashtbl.create 13
-  
+
     let clear t =
       Hashtbl.clear t
-  
-# 71 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/oasis/PropList.ml"
+
+
+(* # 78 "src/oasis/PropList.ml" *)
   end
-  
+
+
   module Schema =
   struct
-  
     type ('ctxt, 'extra) value =
         {
           get:   Data.t -> string;
@@ -295,7 +477,7 @@
           help:  (unit -> string) option;
           extra: 'extra;
         }
-  
+
     type ('ctxt, 'extra) t =
         {
           name:      name;
@@ -303,7 +485,7 @@
           order:     name Queue.t;
           name_norm: string -> string;
         }
-  
+
     let create ?(case_insensitive=false) nm =
       {
         name      = nm;
@@ -315,12 +497,12 @@
            else
              fun s -> s);
       }
-  
+
     let add t nm set get extra help =
       let key =
         t.name_norm nm
       in
-  
+
         if Hashtbl.mem t.fields key then
           failwith
             (Printf.sprintf
@@ -336,25 +518,25 @@
             extra = extra;
           };
         Queue.add nm t.order
-  
+
     let mem t nm =
       Hashtbl.mem t.fields nm
-  
+
     let find t nm =
       try
         Hashtbl.find t.fields (t.name_norm nm)
       with Not_found ->
         raise (Unknown_field (nm, t.name))
-  
+
     let get t data nm =
       (find t nm).get data
-  
+
     let set t data nm ?context x =
       (find t nm).set
         data
         ?context
         x
-  
+
     let fold f acc t =
       Queue.fold
         (fun acc k ->
@@ -364,20 +546,20 @@
              f acc k v.extra v.help)
         acc
         t.order
-  
+
     let iter f t =
       fold
         (fun () -> f)
         ()
         t
-  
+
     let name t =
       t.name
   end
-  
+
+
   module Field =
   struct
-  
     type ('ctxt, 'value, 'extra) t =
         {
           set:    Data.t -> ?context:'ctxt -> 'value -> unit;
@@ -387,33 +569,33 @@
           help:   (unit -> string) option;
           extra:  'extra;
         }
-  
+
     let new_id =
       let last_id =
         ref 0
       in
         fun () -> incr last_id; !last_id
-  
+
     let create ?schema ?name ?parse ?print ?default ?update ?help extra =
       (* Default value container *)
       let v =
         ref None
       in
-  
+
       (* If name is not given, create unique one *)
       let nm =
         match name with
           | Some s -> s
           | None -> Printf.sprintf "_anon_%d" (new_id ())
       in
-  
+
       (* Last chance to get a value: the default *)
       let default () =
         match default with
           | Some d -> d
           | None -> raise (Not_set (nm, Some (s_ "no default value")))
       in
-  
+
       (* Get data *)
       let get data =
         (* Get value *)
@@ -425,7 +607,7 @@
         with Not_found ->
           default ()
       in
-  
+
       (* Set data *)
       let set data ?context x =
         let x =
@@ -445,7 +627,7 @@
             nm
             (fun () -> v := Some x)
       in
-  
+
       (* Parse string value, if possible *)
       let parse =
         match parse with
@@ -459,12 +641,12 @@
                      nm
                      s)
       in
-  
+
       (* Set data, from string *)
       let sets data ?context s =
         set ?context data (parse ?context s)
       in
-  
+
       (* Output value as string, if possible *)
       let print =
         match print with
@@ -473,12 +655,12 @@
           | None ->
               fun _ -> raise (No_printer nm)
       in
-  
+
       (* Get data, as a string *)
       let gets data =
         print (get data)
       in
-  
+
         begin
           match schema with
             | Some t ->
@@ -486,7 +668,7 @@
             | None ->
                 ()
         end;
-  
+
         {
           set   = set;
           get   = get;
@@ -495,45 +677,48 @@
           help  = help;
           extra = extra;
         }
-  
+
     let fset data t ?context x =
       t.set data ?context x
-  
+
     let fget data t =
       t.get data
-  
+
     let fsets data t ?context s =
       t.sets data ?context s
-  
+
     let fgets data t =
       t.gets data
-  
   end
-  
+
+
   module FieldRO =
   struct
-  
     let create ?schema ?name ?parse ?print ?default ?update ?help extra =
       let fld =
         Field.create ?schema ?name ?parse ?print ?default ?update ?help extra
       in
         fun data -> Field.fget data fld
-  
   end
 end
 
 module OASISMessage = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/oasis/OASISMessage.ml"
-  
-  
+(* # 22 "src/oasis/OASISMessage.ml" *)
+
+
   open OASISGettext
   open OASISContext
-  
+
+
   let generic_message ~ctxt lvl fmt =
     let cond =
-      match lvl with
-        | `Debug -> ctxt.debug
-        | _ -> ctxt.verbose
+      if ctxt.quiet then
+        false
+      else
+        match lvl with
+          | `Debug -> ctxt.debug
+          | `Info  -> ctxt.info
+          | _ -> true
     in
       Printf.ksprintf
         (fun str ->
@@ -542,32 +727,41 @@
                ctxt.printf lvl str
              end)
         fmt
-  
+
+
   let debug ~ctxt fmt =
     generic_message ~ctxt `Debug fmt
-  
+
+
   let info ~ctxt fmt =
     generic_message ~ctxt `Info fmt
-  
+
+
   let warning ~ctxt fmt =
     generic_message ~ctxt `Warning fmt
-  
+
+
   let error ~ctxt fmt =
     generic_message ~ctxt `Error fmt
-  
+
 end
 
 module OASISVersion = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/oasis/OASISVersion.ml"
-  
+(* # 22 "src/oasis/OASISVersion.ml" *)
+
+
   open OASISGettext
-  
-  
-  
+
+
+
+
+
   type s = string
-  
-  type t = string 
-  
+
+
+  type t = string
+
+
   type comparator =
     | VGreater of t
     | VGreaterEqual of t
@@ -576,20 +770,22 @@
     | VLesserEqual of t
     | VOr of  comparator * comparator
     | VAnd of comparator * comparator
-    
-  
+
+
+
   (* Range of allowed characters *)
-  let is_digit c =
-    '0' <= c && c <= '9'
-  
-  let is_alpha c =
-    ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')
-  
+  let is_digit = OASISString.is_digit
+
+
+  let is_alpha = OASISString.is_alpha
+
+
   let is_special =
     function
       | '.' | '+' | '-' | '~' -> true
       | _ -> false
-  
+
+
   let rec version_compare v1 v2 =
     if v1 <> "" || v2 <> "" then
       begin
@@ -603,12 +799,12 @@
           else if is_alpha c then Char.code c
           else (Char.code c) + 256
         in
-  
+
         let len1 = String.length v1 in
         let len2 = String.length v2 in
-  
+
         let p = ref 0 in
-  
+
         (** Compare ascii part *)
         let compare_vascii () =
           let cmp = ref 0 in
@@ -625,7 +821,7 @@
           else
             !cmp
         in
-  
+
         (** Compare digit part *)
         let compare_digit () =
           let extract_int v p =
@@ -633,11 +829,11 @@
               while !p < String.length v && is_digit v.[!p] do
                 incr p
               done;
-              let substr = 
+              let substr =
                 String.sub v !p ((String.length v) - !p)
-              in 
-              let res = 
-                match String.sub v start_p (!p - start_p) with 
+              in
+              let res =
+                match String.sub v start_p (!p - start_p) with
                   | "" -> 0
                   | s -> int_of_string s
               in
@@ -647,7 +843,7 @@
           let i2, tl2 = extract_int v2 (ref !p) in
             i1 - i2, tl1, tl2
         in
-  
+
           match compare_vascii () with
             | 0 ->
                 begin
@@ -669,24 +865,18 @@
       begin
         0
       end
-  
-  
-  let version_of_string str =
-    String.iter
-      (fun c ->
-         if is_alpha c || is_digit c || is_special c then
-           ()
-         else
-           failwith
-             (Printf.sprintf
-                (f_ "Char %C is not allowed in version '%s'")
-                c str))
-      str;
-    str
-  
-  let string_of_version t =
-    t
-  
+
+
+  let version_of_string str = str
+
+
+  let string_of_version t = t
+
+
+  let version_compare_string s1 s2 =
+    version_compare (version_of_string s1) (version_of_string s2)
+
+
   let chop t =
     try
       let pos =
@@ -695,7 +885,8 @@
         String.sub t 0 pos
     with Not_found ->
       t
-  
+
+
   let rec comparator_apply v op =
     match op with
       | VGreater cv ->
@@ -712,7 +903,8 @@
           (comparator_apply v op1) || (comparator_apply v op2)
       | VAnd (op1, op2) ->
           (comparator_apply v op1) && (comparator_apply v op2)
-  
+
+
   let rec string_of_comparator =
     function
       | VGreater v  -> "> "^(string_of_version v)
@@ -724,7 +916,8 @@
           (string_of_comparator c1)^" || "^(string_of_comparator c2)
       | VAnd (c1, c2) ->
           (string_of_comparator c1)^" && "^(string_of_comparator c2)
-  
+
+
   let rec varname_of_comparator =
     let concat p v =
       OASISUtils.varname_concat
@@ -742,53 +935,86 @@
             (varname_of_comparator c1)^"_or_"^(varname_of_comparator c2)
         | VAnd (c1, c2) ->
             (varname_of_comparator c1)^"_and_"^(varname_of_comparator c2)
-  
+
+
+  let rec comparator_ge v' =
+    let cmp v = version_compare v v' >= 0 in
+    function
+      | VEqual v
+      | VGreaterEqual v
+      | VGreater v -> cmp v
+      | VLesserEqual _
+      | VLesser _ -> false
+      | VOr (c1, c2) -> comparator_ge v' c1 || comparator_ge v' c2
+      | VAnd (c1, c2) -> comparator_ge v' c1 && comparator_ge v' c2
+
+
 end
 
 module OASISLicense = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/oasis/OASISLicense.ml"
-  
+(* # 22 "src/oasis/OASISLicense.ml" *)
+
+
   (** License for _oasis fields
       @author Sylvain Le Gall
     *)
-  
-  
-  
-  type license = string 
-  
-  type license_exception = string 
-  
+
+
+
+
+
+  type license = string
+
+
+  type license_exception = string
+
+
   type license_version =
     | Version of OASISVersion.t
     | VersionOrLater of OASISVersion.t
     | NoVersion
-    
-  
+
+
+
+  type license_dep_5_unit =
+    {
+      license:   license;
+      excption:  license_exception option;
+      version:   license_version;
+    }
+
+
+
   type license_dep_5 =
-      {
-        license:    license;
-        exceptions: license_exception list;
-        version:    license_version;
-      } 
-  
+    | DEP5Unit of license_dep_5_unit
+    | DEP5Or of license_dep_5 list
+    | DEP5And of license_dep_5 list
+
+
   type t =
     | DEP5License of license_dep_5
     | OtherLicense of string (* URL *)
-    
-  
+
+
+
 end
 
 module OASISExpr = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/oasis/OASISExpr.ml"
-  
-  
-  
+(* # 22 "src/oasis/OASISExpr.ml" *)
+
+
+
+
+
   open OASISGettext
-  
-  type test = string 
-  
-  type flag = string 
-  
+
+
+  type test = string
+
+
+  type flag = string
+
+
   type t =
     | EBool of bool
     | ENot of t
@@ -796,32 +1022,34 @@
     | EOr of t * t
     | EFlag of flag
     | ETest of test * string
-    
-  
-  type 'a choices = (t * 'a) list 
-  
+
+
+
+  type 'a choices = (t * 'a) list
+
+
   let eval var_get t =
     let rec eval' =
       function
         | EBool b ->
             b
-  
+
         | ENot e ->
             not (eval' e)
-  
+
         | EAnd (e1, e2) ->
             (eval' e1) && (eval' e2)
-  
+
         | EOr (e1, e2) ->
             (eval' e1) || (eval' e2)
-  
+
         | EFlag nm ->
             let v =
               var_get nm
             in
               assert(v = "true" || v = "false");
               (v = "true")
-  
+
         | ETest (nm, vl) ->
             let v =
               var_get nm
@@ -829,7 +1057,8 @@
               (v = vl)
     in
       eval' t
-  
+
+
   let choose ?printer ?name var_get lst =
     let rec choose_aux =
       function
@@ -865,46 +1094,68 @@
                          str_lst)
     in
       choose_aux (List.rev lst)
-  
+
+
+end
+
+module OASISText = struct
+(* # 22 "src/oasis/OASISText.ml" *)
+
+
+
+  type elt =
+    | Para of string
+    | Verbatim of string
+    | BlankLine
+
+
+  type t = elt list
+
 end
 
 module OASISTypes = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/oasis/OASISTypes.ml"
-  
-  
-  
-  
-  type name          = string 
-  type package_name  = string 
-  type url           = string 
-  type unix_dirname  = string 
-  type unix_filename = string 
-  type host_dirname  = string 
-  type host_filename = string 
-  type prog          = string 
-  type arg           = string 
-  type args          = string list 
-  type command_line  = (prog * arg list) 
-  
-  type findlib_name = string 
-  type findlib_full = string 
-  
+(* # 22 "src/oasis/OASISTypes.ml" *)
+
+
+
+
+
+  type name          = string
+  type package_name  = string
+  type url           = string
+  type unix_dirname  = string
+  type unix_filename = string
+  type host_dirname  = string
+  type host_filename = string
+  type prog          = string
+  type arg           = string
+  type args          = string list
+  type command_line  = (prog * arg list)
+
+
+  type findlib_name = string
+  type findlib_full = string
+
+
   type compiled_object =
     | Byte
     | Native
     | Best
-    
-  
+
+
+
   type dependency =
     | FindlibPackage of findlib_full * OASISVersion.comparator option
     | InternalLibrary of name
-    
-  
+
+
+
   type tool =
     | ExternalTool of name
     | InternalExecutable of name
-    
-  
+
+
+
   type vcs =
     | Darcs
     | Git
@@ -915,8 +1166,9 @@
     | Arch
     | Monotone
     | OtherVCS of url
-    
-  
+
+
+
   type plugin_kind =
       [  `Configure
        | `Build
@@ -925,7 +1177,8 @@
        | `Install
        | `Extra
       ]
-  
+
+
   type plugin_data_purpose =
       [  `Configure
        | `Build
@@ -939,32 +1192,40 @@
        | `Extra
        | `Other of string
       ]
-  
-  type 'a plugin = 'a * name * OASISVersion.t option 
-  
+
+
+  type 'a plugin = 'a * name * OASISVersion.t option
+
+
   type all_plugin = plugin_kind plugin
-  
+
+
   type plugin_data = (all_plugin * plugin_data_purpose * (unit -> unit)) list
-  
-# 102 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/oasis/OASISTypes.ml"
-  
-  type 'a conditional = 'a OASISExpr.choices 
-  
+
+
+(* # 115 "src/oasis/OASISTypes.ml" *)
+
+
+  type 'a conditional = 'a OASISExpr.choices
+
+
   type custom =
       {
         pre_command:  (command_line option) conditional;
         post_command: (command_line option) conditional;
       }
-      
-  
+
+
+
   type common_section =
       {
         cs_name: name;
         cs_data: PropList.Data.t;
         cs_plugin_data: plugin_data;
       }
-      
-  
+
+
+
   type build_section =
       {
         bs_build:           bool conditional;
@@ -982,8 +1243,9 @@
         bs_byteopt:         args conditional;
         bs_nativeopt:       args conditional;
       }
-      
-  
+
+
+
   type library =
       {
         lib_modules:            string list;
@@ -992,20 +1254,30 @@
         lib_findlib_parent:     findlib_name option;
         lib_findlib_name:       findlib_name option;
         lib_findlib_containers: findlib_name list;
-      } 
-  
+      }
+
+
+  type object_ =
+      {
+        obj_modules:            string list;
+        obj_findlib_fullname:   findlib_name list option;
+      }
+
+
   type executable =
       {
         exec_custom:          bool;
         exec_main_is:         unix_filename;
-      } 
-  
+      }
+
+
   type flag =
       {
         flag_description:  string option;
         flag_default:      bool conditional;
-      } 
-  
+      }
+
+
   type source_repository =
       {
         src_repo_type:        vcs;
@@ -1015,8 +1287,9 @@
         src_repo_branch:      string option;
         src_repo_tag:         string option;
         src_repo_subdir:      unix_filename option;
-      } 
-  
+      }
+
+
   type test =
       {
         test_type:               [`Test] plugin;
@@ -1025,8 +1298,9 @@
         test_working_directory:  unix_filename option;
         test_run:                bool conditional;
         test_tools:              tool list;
-      } 
-  
+      }
+
+
   type doc_format =
     | HTML of unix_filename
     | DocText
@@ -1035,8 +1309,9 @@
     | Info of unix_filename
     | DVI
     | OtherDoc
-    
-  
+
+
+
   type doc =
       {
         doc_type:        [`Doc] plugin;
@@ -1050,147 +1325,707 @@
         doc_format:      doc_format;
         doc_data_files:  (unix_filename * unix_filename option) list;
         doc_build_tools: tool list;
-      } 
-  
+      }
+
+
   type section =
     | Library    of common_section * build_section * library
+    | Object     of common_section * build_section * object_
     | Executable of common_section * build_section * executable
     | Flag       of common_section * flag
     | SrcRepo    of common_section * source_repository
     | Test       of common_section * test
     | Doc        of common_section * doc
-    
-  
+
+
+
   type section_kind =
-      [ `Library | `Executable | `Flag | `SrcRepo | `Test | `Doc ]
-  
-  type package = 
+      [ `Library | `Object | `Executable | `Flag | `SrcRepo | `Test | `Doc ]
+
+
+  type package =
       {
-        oasis_version:    OASISVersion.t;
-        ocaml_version:    OASISVersion.comparator option;
-        findlib_version:  OASISVersion.comparator option;
-        name:             package_name;
-        version:          OASISVersion.t;
-        license:          OASISLicense.t;
-        license_file:     unix_filename option;
-        copyrights:       string list;
-        maintainers:      string list;
-        authors:          string list;
-        homepage:         url option;
-        synopsis:         string;
-        description:      string option;
-        categories:       url list;
-  
-        conf_type:        [`Configure] plugin;
-        conf_custom:      custom;
-  
-        build_type:       [`Build] plugin;
-        build_custom:     custom;
-  
-        install_type:     [`Install] plugin;
-        install_custom:   custom;
-        uninstall_custom: custom;
-  
-        clean_custom:     custom;
-        distclean_custom: custom;
-  
-        files_ab:         unix_filename list;
-        sections:         section list;
-        plugins:          [`Extra] plugin list;
-        schema_data:      PropList.Data.t;
-        plugin_data:      plugin_data;
-      } 
-  
-end
+        oasis_version:          OASISVersion.t;
+        ocaml_version:          OASISVersion.comparator option;
+        findlib_version:        OASISVersion.comparator option;
+        alpha_features:         string list;
+        beta_features:          string list;
+        name:                   package_name;
+        version:                OASISVersion.t;
+        license:                OASISLicense.t;
+        license_file:           unix_filename option;
+        copyrights:             string list;
+        maintainers:            string list;
+        authors:                string list;
+        homepage:               url option;
+        synopsis:               string;
+        description:            OASISText.t option;
+        categories:             url list;
+
+        conf_type:              [`Configure] plugin;
+        conf_custom:            custom;
+
+        build_type:             [`Build] plugin;
+        build_custom:           custom;
+
+        install_type:           [`Install] plugin;
+        install_custom:         custom;
+        uninstall_custom:       custom;
+
+        clean_custom:           custom;
+        distclean_custom:       custom;
+
+        files_ab:               unix_filename list;
+        sections:               section list;
+        plugins:                [`Extra] plugin list;
+        disable_oasis_section:  unix_filename list;
+        schema_data:            PropList.Data.t;
+        plugin_data:            plugin_data;
+      }
+
 
-module OASISUnixPath = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/oasis/OASISUnixPath.ml"
-  
-  type unix_filename = string
-  type unix_dirname = string
-  
-  type host_filename = string
-  type host_dirname = string
-  
-  let current_dir_name = "."
-  
-  let parent_dir_name = ".."
-  
-  let concat f1 f2 =
-    if f1 = current_dir_name then
-      f2
-    else if f2 = current_dir_name then
-      f1
-    else
-      f1^"/"^f2
-  
-  let make =
-    function
-      | hd :: tl ->
-          List.fold_left
-            (fun f p -> concat f p)
-            hd
-            tl
-      | [] ->
-          invalid_arg "OASISUnixPath.make"
-  
-  let dirname f =
-    try
-      String.sub f 0 (String.rindex f '/')
-    with Not_found ->
-      current_dir_name
-  
-  let basename f =
-    try
-      let pos_start =
-        (String.rindex f '/') + 1
-      in
-        String.sub f pos_start ((String.length f) - pos_start)
-    with Not_found ->
-      f
-  
-  let chop_extension f =
-    try
-      let last_dot =
-        String.rindex f '.'
-      in
-      let sub =
-        String.sub f 0 last_dot
-      in
-        try
-          let last_slash =
-            String.rindex f '/'
-          in
-            if last_slash < last_dot then
-              sub
-            else
-              f
-        with Not_found ->
-          sub
-  
-    with Not_found ->
-      f
-  
-  let capitalize_file f =
-    let dir = dirname f in
-    let base = basename f in
-    concat dir (String.capitalize base)
-  
-  let uncapitalize_file f =
-    let dir = dirname f in
-    let base = basename f in
-    concat dir (String.uncapitalize base)
 end
 
-module OASISSection = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/oasis/OASISSection.ml"
-  
+module OASISFeatures = struct
+(* # 22 "src/oasis/OASISFeatures.ml" *)
+
   open OASISTypes
-  
-  let section_kind_common = 
+  open OASISUtils
+  open OASISGettext
+  open OASISVersion
+
+  module MapPlugin =
+    Map.Make
+      (struct
+         type t = plugin_kind * name
+         let compare = Pervasives.compare
+       end)
+
+  module Data =
+  struct
+    type t =
+        {
+          oasis_version: OASISVersion.t;
+          plugin_versions: OASISVersion.t option MapPlugin.t;
+          alpha_features: string list;
+          beta_features: string list;
+        }
+
+    let create oasis_version alpha_features beta_features =
+      {
+        oasis_version = oasis_version;
+        plugin_versions = MapPlugin.empty;
+        alpha_features = alpha_features;
+        beta_features = beta_features
+      }
+
+    let of_package pkg =
+      create
+        pkg.OASISTypes.oasis_version
+        pkg.OASISTypes.alpha_features
+        pkg.OASISTypes.beta_features
+
+    let add_plugin (plugin_kind, plugin_name, plugin_version) t =
+      {t with
+           plugin_versions = MapPlugin.add
+                               (plugin_kind, plugin_name)
+                               plugin_version
+                               t.plugin_versions}
+
+    let plugin_version plugin_kind plugin_name t =
+      MapPlugin.find (plugin_kind, plugin_name) t.plugin_versions
+
+    let to_string t =
+      Printf.sprintf
+        "oasis_version: %s; alpha_features: %s; beta_features: %s; \
+         plugins_version: %s"
+        (OASISVersion.string_of_version t.oasis_version)
+        (String.concat ", " t.alpha_features)
+        (String.concat ", " t.beta_features)
+        (String.concat ", "
+           (MapPlugin.fold
+              (fun (_, plg) ver_opt acc ->
+                 (plg^
+                  (match ver_opt with
+                     | Some v ->
+                         " "^(OASISVersion.string_of_version v)
+                     | None -> ""))
+                 :: acc)
+              t.plugin_versions []))
+  end
+
+  type origin =
+    | Field of string * string
+    | Section of string
+    | NoOrigin
+
+  type stage = Alpha | Beta
+
+
+  let string_of_stage =
     function
-      | Library (cs, _, _) -> 
-          `Library, cs
+      | Alpha -> "alpha"
+      | Beta -> "beta"
+
+
+  let field_of_stage =
+    function
+      | Alpha -> "AlphaFeatures"
+      | Beta -> "BetaFeatures"
+
+  type publication = InDev of stage | SinceVersion of OASISVersion.t
+
+  type t =
+      {
+        name: string;
+        plugin: all_plugin option;
+        publication: publication;
+        description: unit -> string;
+      }
+
+  (* TODO: mutex protect this. *)
+  let all_features = Hashtbl.create 13
+
+
+  let since_version ver_str = SinceVersion (version_of_string ver_str)
+  let alpha = InDev Alpha
+  let beta = InDev Beta
+
+
+  let to_string t =
+    Printf.sprintf
+      "feature: %s; plugin: %s; publication: %s"
+      t.name
+      (match t.plugin with
+         | None -> "<none>"
+         | Some (_, nm, _) -> nm)
+      (match t.publication with
+         | InDev stage -> string_of_stage stage
+         | SinceVersion ver -> ">= "^(OASISVersion.string_of_version ver))
+
+  let data_check t data origin =
+    let no_message = "no message" in
+
+    let check_feature features stage =
+      let has_feature = List.mem t.name features in
+      if not has_feature then
+        match origin with
+          | Field (fld, where) ->
+              Some
+                (Printf.sprintf
+                   (f_ "Field %s in %s is only available when feature %s \
+                        is in field %s.")
+                   fld where t.name (field_of_stage stage))
+          | Section sct ->
+              Some
+                (Printf.sprintf
+                   (f_ "Section %s is only available when features %s \
+                        is in field %s.")
+                   sct t.name (field_of_stage stage))
+          | NoOrigin ->
+              Some no_message
+      else
+        None
+    in
+
+    let version_is_good ~min_version version fmt =
+      let version_is_good =
+        OASISVersion.comparator_apply
+          version (OASISVersion.VGreaterEqual min_version)
+      in
+        Printf.ksprintf
+          (fun str ->
+             if version_is_good then
+               None
+             else
+               Some str)
+          fmt
+    in
+
+    match origin, t.plugin, t.publication with
+      | _, _, InDev Alpha -> check_feature data.Data.alpha_features Alpha
+      | _, _, InDev Beta -> check_feature data.Data.beta_features Beta
+      | Field(fld, where), None, SinceVersion min_version ->
+          version_is_good ~min_version data.Data.oasis_version
+            (f_ "Field %s in %s is only valid since OASIS v%s, update \
+                 OASISFormat field from '%s' to '%s' after checking \
+                 OASIS changelog.")
+            fld where (string_of_version min_version)
+            (string_of_version data.Data.oasis_version)
+            (string_of_version min_version)
+
+      | Field(fld, where), Some(plugin_knd, plugin_name, _),
+        SinceVersion min_version ->
+          begin
+            try
+              let plugin_version_current =
+                try
+                  match Data.plugin_version plugin_knd plugin_name data with
+                    | Some ver -> ver
+                    | None ->
+                        failwithf
+                          (f_ "Field %s in %s is only valid for the OASIS \
+                               plugin %s since v%s, but no plugin version is \
+                               defined in the _oasis file, change '%s' to \
+                               '%s (%s)' in your _oasis file.")
+                          fld where plugin_name (string_of_version min_version)
+                          plugin_name
+                          plugin_name (string_of_version min_version)
+                with Not_found ->
+                  failwithf
+                    (f_ "Field %s in %s is only valid when the OASIS plugin %s \
+                         is defined.")
+                    fld where plugin_name
+              in
+              version_is_good ~min_version plugin_version_current
+                (f_ "Field %s in %s is only valid for the OASIS plugin %s \
+                     since v%s, update your plugin from '%s (%s)' to \
+                     '%s (%s)' after checking the plugin's changelog.")
+                fld where plugin_name (string_of_version min_version)
+                plugin_name (string_of_version plugin_version_current)
+                plugin_name (string_of_version min_version)
+            with Failure msg ->
+              Some msg
+          end
+
+      | Section sct, None, SinceVersion min_version ->
+          version_is_good ~min_version data.Data.oasis_version
+            (f_ "Section %s is only valid for since OASIS v%s, update \
+                 OASISFormat field from '%s' to '%s' after checking OASIS \
+                 changelog.")
+            sct (string_of_version min_version)
+            (string_of_version data.Data.oasis_version)
+            (string_of_version min_version)
+
+      | Section sct, Some(plugin_knd, plugin_name, _),
+        SinceVersion min_version ->
+          begin
+            try
+              let plugin_version_current =
+                try
+                  match Data.plugin_version plugin_knd plugin_name data with
+                    | Some ver -> ver
+                    | None ->
+                        failwithf
+                          (f_ "Section %s is only valid for the OASIS \
+                               plugin %s since v%s, but no plugin version is \
+                               defined in the _oasis file, change '%s' to \
+                               '%s (%s)' in your _oasis file.")
+                          sct plugin_name (string_of_version min_version)
+                          plugin_name
+                          plugin_name (string_of_version min_version)
+                with Not_found ->
+                  failwithf
+                    (f_ "Section %s is only valid when the OASIS plugin %s \
+                         is defined.")
+                    sct plugin_name
+              in
+              version_is_good ~min_version plugin_version_current
+                (f_ "Section %s is only valid for the OASIS plugin %s \
+                     since v%s, update your plugin from '%s (%s)' to \
+                     '%s (%s)' after checking the plugin's changelog.")
+                sct plugin_name (string_of_version min_version)
+                plugin_name (string_of_version plugin_version_current)
+                plugin_name (string_of_version min_version)
+            with Failure msg ->
+              Some msg
+          end
+
+      | NoOrigin, None, SinceVersion min_version ->
+          version_is_good ~min_version data.Data.oasis_version "%s" no_message
+
+      | NoOrigin, Some(plugin_knd, plugin_name, _), SinceVersion min_version ->
+          begin
+            try
+              let plugin_version_current =
+                match Data.plugin_version plugin_knd plugin_name data with
+                  | Some ver -> ver
+                  | None -> raise Not_found
+              in
+              version_is_good ~min_version plugin_version_current
+                "%s" no_message
+            with Not_found ->
+              Some no_message
+          end
+
+
+  let data_assert t data origin =
+    match data_check t data origin with
+      | None -> ()
+      | Some str -> failwith str
+
+
+  let data_test t data =
+    match data_check t data NoOrigin with
+      | None -> true
+      | Some str -> false
+
+
+  let package_test t pkg =
+    data_test t (Data.of_package pkg)
+
+
+  let create ?plugin name publication description =
+    let () =
+      if Hashtbl.mem all_features name then
+        failwithf "Feature '%s' is already declared." name
+    in
+    let t =
+      {
+        name = name;
+        plugin = plugin;
+        publication = publication;
+        description = description;
+      }
+    in
+      Hashtbl.add all_features name t;
+      t
+
+
+  let get_stage name =
+    try
+      (Hashtbl.find all_features name).publication
+    with Not_found ->
+      failwithf (f_ "Feature %s doesn't exist.") name
+
+
+  let list () =
+    Hashtbl.fold (fun _ v acc -> v :: acc) all_features []
+
+  (*
+   * Real flags.
+   *)
+
+
+  let features =
+    create "features_fields"
+      (since_version "0.4")
+      (fun () ->
+         s_ "Enable to experiment not yet official features.")
+
+
+  let flag_docs =
+    create "flag_docs"
+      (since_version "0.3")
+      (fun () ->
+         s_ "Building docs require '-docs' flag at configure.")
+
+
+  let flag_tests =
+    create "flag_tests"
+      (since_version "0.3")
+      (fun () ->
+         s_ "Running tests require '-tests' flag at configure.")
+
+
+  let pack =
+    create "pack"
+      (since_version "0.3")
+      (fun () ->
+         s_ "Allow to create packed library.")
+
+
+  let section_object =
+    create "section_object" beta
+      (fun () ->
+         s_ "Implement an object section.")
+
+
+  let dynrun_for_release =
+    create "dynrun_for_release" alpha
+      (fun () ->
+         s_ "Make '-setup-update dynamic' suitable for releasing project.")
+
+
+  let compiled_setup_ml =
+    create "compiled_setup_ml" alpha
+      (fun () ->
+         s_ "It compiles the setup.ml and speed-up actions done with it.")
+
+  let disable_oasis_section =
+    create "disable_oasis_section" alpha
+      (fun () ->
+        s_ "Allows the OASIS section comments and digest to be omitted in \
+            generated files.")
+
+  let no_automatic_syntax =
+    create "no_automatic_syntax" alpha
+      (fun () ->
+         s_ "Disable the automatic inclusion of -syntax camlp4o for packages \
+             that matches the internal heuristic (if a dependency ends with \
+             a .syntax or is a well known syntax).")
+end
+
+module OASISUnixPath = struct
+(* # 22 "src/oasis/OASISUnixPath.ml" *)
+
+
+  type unix_filename = string
+  type unix_dirname = string
+
+
+  type host_filename = string
+  type host_dirname = string
+
+
+  let current_dir_name = "."
+
+
+  let parent_dir_name = ".."
+
+
+  let is_current_dir fn =
+    fn = current_dir_name || fn = ""
+
+
+  let concat f1 f2 =
+    if is_current_dir f1 then
+      f2
+    else
+      let f1' =
+        try OASISString.strip_ends_with ~what:"/" f1 with Not_found -> f1
+      in
+        f1'^"/"^f2
+
+
+  let make =
+    function
+      | hd :: tl ->
+          List.fold_left
+            (fun f p -> concat f p)
+            hd
+            tl
+      | [] ->
+          invalid_arg "OASISUnixPath.make"
+
+
+  let dirname f =
+    try
+      String.sub f 0 (String.rindex f '/')
+    with Not_found ->
+      current_dir_name
+
+
+  let basename f =
+    try
+      let pos_start =
+        (String.rindex f '/') + 1
+      in
+        String.sub f pos_start ((String.length f) - pos_start)
+    with Not_found ->
+      f
+
+
+  let chop_extension f =
+    try
+      let last_dot =
+        String.rindex f '.'
+      in
+      let sub =
+        String.sub f 0 last_dot
+      in
+        try
+          let last_slash =
+            String.rindex f '/'
+          in
+            if last_slash < last_dot then
+              sub
+            else
+              f
+        with Not_found ->
+          sub
+
+    with Not_found ->
+      f
+
+
+  let capitalize_file f =
+    let dir = dirname f in
+    let base = basename f in
+    concat dir (String.capitalize base)
+
+
+  let uncapitalize_file f =
+    let dir = dirname f in
+    let base = basename f in
+    concat dir (String.uncapitalize base)
+
+
+end
+
+module OASISHostPath = struct
+(* # 22 "src/oasis/OASISHostPath.ml" *)
+
+
+  open Filename
+
+
+  module Unix = OASISUnixPath
+
+  let bash_cmd = ref ( fun () -> "dash.exe" )
+
+  let use_bash () = ( !bash_cmd () ) <> ""
+
+
+  (* generic quote and unixquote are taken from ocaml source *)
+  let generic_quote quotequote s =
+    let l = String.length s in
+    let b = Buffer.create (l + 20) in
+      Buffer.add_char b '\'';
+      for i = 0 to l - 1 do
+        if s.[i] = '\'' then
+          Buffer.add_string b quotequote
+        else
+          Buffer.add_char b  s.[i]
+      done;
+      Buffer.add_char b '\'';
+      Buffer.contents b
+
+  let unixquote = generic_quote "'\\''"
+
+  let win = Sys.os_type = "Win32"
+
+  let quote str =
+    if win && use_bash () then
+      unixquote str
+    else
+      quote str
+
+  (* uniform_path (only called, if Sys.os_type = "Win32")
+   * - enforces uniform path seperators
+   * - strips trailing slashes (exceptions in case of C:\ and / )
+   * - removes (some) unnecessary file components like ./././
+   *)
+
+  let get_naccu accu str first pos =
+    (* I assume c//d is identic to c/d
+     * the only exception (Network devices \\xyz\asdf)
+     * is covered in uniform_path
+     *)
+    if first = pos then
+      accu
+    else
+      let nlen = pos - first in
+      let nstr = String.sub str first nlen in
+        (* test/././ is the same as test *)
+        if nlen = 1 && nstr = "." then
+          accu
+        (* a/b/../ is the same as a *)
+        else if nlen = 2 && nstr = ".." then
+          match accu with
+            | []      -> [ nstr ]
+            | ".."::_ -> nstr::accu
+            | hd::tl  -> tl
+        else
+          nstr::accu
+
+  let is_path_sep = function
+    | '\\' | '/' -> true
+    | _ -> false
+
+
+  let uniform_path path_sep = function
+    | "" -> "" (* Raise an exception? Or an possible intermediate result?
+               * Filename.basename and dirname also don't raise exceptions *)
+    | str ->
+        let rec iter accu str len first pos =
+          if pos >= len then
+            List.rev (get_naccu accu str first pos)
+          else
+            let next = succ pos in
+              match is_path_sep str.[pos] with
+                | true -> iter (get_naccu accu str first pos) str len next next
+                | false -> iter accu str len first next
+        in
+          let is_unix_root = is_path_sep str.[0] in
+          let len = String.length str in
+          let next_sep = len > 1 && is_path_sep str.[1] in
+          let is_network_root = is_unix_root && next_sep in
+          let is_currel = str.[0] = '.' && ( next_sep || len = 1 ) in
+          let l = iter [] str len 0 0 in
+          (* Trailing slashes are normally stripped.
+           * This is not possible in case of root folders
+           * Sys.file_exists "C:" is false, Sys.file_exists "C:\\" true
+           *)
+          let l_min =
+            match l with
+              | [] -> [ "" ]
+              | _ -> l
+          in
+          let l =
+            if is_network_root then
+              ""::""::l_min
+            else if is_unix_root then
+              ""::l_min
+            else if is_currel then
+              "."::l
+            else
+              match l with
+                | s :: [] ->
+                    (* root folders like C:\ *)
+                    if String.length s = 2 && s.[1] = ':' &&
+                      len > 2 && is_path_sep str.[2]
+                    then
+                      s :: [ "" ]
+                    else
+                      l
+                | _ -> l
+          in
+            String.concat path_sep l
+
+
+
+  let make =
+    function
+      | [] ->
+          invalid_arg "OASISHostPath.make"
+      | hd :: tl ->
+          List.fold_left Filename.concat hd tl
+
+
+  let of_unix str =
+    if win = false then
+      str
+    else
+      let path_sep =
+        if use_bash () then
+          "/"
+              else
+          "\\"
+      in
+        uniform_path path_sep str
+
+
+
+  (* see findlib's src/findlib/frontend.ml for details *)
+  let ocamlfind_unquote dir =
+    match Sys.os_type with
+      | "Cygwin"
+      | "Win32" ->
+        let len = String.length dir in
+          if len < 3 || dir.[0] <> '"' || dir.[len - 1] <> '"' ||
+            String.contains dir ' ' = false then
+            dir
+              else
+            String.sub dir 1 (len - 2)
+      | _ -> dir
+
+
+end
+
+module OASISSection = struct
+(* # 22 "src/oasis/OASISSection.ml" *)
+
+
+  open OASISTypes
+
+
+  let section_kind_common =
+    function
+      | Library (cs, _, _) ->
+          `Library, cs
+      | Object (cs, _, _) ->
+          `Object, cs
       | Executable (cs, _, _) ->
           `Executable, cs
       | Flag (cs, _) ->
@@ -1201,89 +2036,128 @@
           `Test, cs
       | Doc (cs, _) ->
           `Doc, cs
-  
+
+
   let section_common sct =
     snd (section_kind_common sct)
-  
+
+
   let section_common_set cs =
     function
       | Library (_, bs, lib)     -> Library (cs, bs, lib)
+      | Object (_, bs, obj)      -> Object (cs, bs, obj)
       | Executable (_, bs, exec) -> Executable (cs, bs, exec)
       | Flag (_, flg)            -> Flag (cs, flg)
       | SrcRepo (_, src_repo)    -> SrcRepo (cs, src_repo)
       | Test (_, tst)            -> Test (cs, tst)
       | Doc (_, doc)             -> Doc (cs, doc)
-  
+
+
   (** Key used to identify section
     *)
-  let section_id sct = 
-    let k, cs = 
+  let section_id sct =
+    let k, cs =
       section_kind_common sct
     in
       k, cs.cs_name
-  
+
+
   let string_of_section sct =
     let k, nm =
       section_id sct
     in
       (match k with
-         | `Library    -> "library" 
+         | `Library    -> "library"
+         | `Object     -> "object"
          | `Executable -> "executable"
          | `Flag       -> "flag"
          | `SrcRepo    -> "src repository"
          | `Test       -> "test"
          | `Doc        -> "doc")
       ^" "^nm
-  
-end
 
-module OASISBuildSection = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/oasis/OASISBuildSection.ml"
-  
-end
 
-module OASISExecutable = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/oasis/OASISExecutable.ml"
-  
-  open OASISTypes
-  
-  let unix_exec_is (cs, bs, exec) is_native ext_dll suffix_program = 
-    let dir = 
-      OASISUnixPath.concat
-        bs.bs_path
-        (OASISUnixPath.dirname exec.exec_main_is)
+  let section_find id scts =
+    List.find
+      (fun sct -> id = section_id sct)
+      scts
+
+
+  module CSection =
+  struct
+    type t = section
+
+    let id = section_id
+
+    let compare t1 t2 =
+      compare (id t1) (id t2)
+
+    let equal t1 t2 =
+      (id t1) = (id t2)
+
+    let hash t =
+      Hashtbl.hash (id t)
+  end
+
+
+  module MapSection = Map.Make(CSection)
+  module SetSection = Set.Make(CSection)
+
+
+end
+
+module OASISBuildSection = struct
+(* # 22 "src/oasis/OASISBuildSection.ml" *)
+
+
+end
+
+module OASISExecutable = struct
+(* # 22 "src/oasis/OASISExecutable.ml" *)
+
+
+  open OASISTypes
+
+
+  let unix_exec_is (cs, bs, exec) is_native ext_dll suffix_program =
+    let dir =
+      OASISUnixPath.concat
+        bs.bs_path
+        (OASISUnixPath.dirname exec.exec_main_is)
     in
-    let is_native_exec = 
+    let is_native_exec =
       match bs.bs_compiled_object with
         | Native -> true
         | Best -> is_native ()
         | Byte -> false
     in
-  
+
       OASISUnixPath.concat
         dir
         (cs.cs_name^(suffix_program ())),
-  
-      if not is_native_exec && 
-         not exec.exec_custom && 
+
+      if not is_native_exec &&
+         not exec.exec_custom &&
          bs.bs_c_sources <> [] then
         Some (dir^"/dll"^cs.cs_name^"_stubs"^(ext_dll ()))
       else
         None
-  
+
+
 end
 
 module OASISLibrary = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/oasis/OASISLibrary.ml"
-  
+(* # 22 "src/oasis/OASISLibrary.ml" *)
+
+
   open OASISTypes
   open OASISUtils
   open OASISGettext
-  
-  type library_name = name
-  
+  open OASISSection
+
+
   (* Look for a module file, considering capitalization or not. *)
-  let find_module source_file_exists (cs, bs, lib) modul =
+  let find_module source_file_exists bs modul =
     let possible_base_fn =
       List.map
         (OASISUnixPath.concat bs.bs_path)
@@ -1320,11 +2194,12 @@
                  acc)
         (`No_sources possible_base_fn)
         possible_base_fn
-  
+
+
   let source_unix_files ~ctxt (cs, bs, lib) source_file_exists =
     List.fold_left
       (fun acc modul ->
-         match find_module source_file_exists (cs, bs, lib) modul with
+         match find_module source_file_exists bs modul with
            | `Sources (base_fn, lst) ->
                (base_fn, lst) :: acc
            | `No_sources _ ->
@@ -1336,7 +2211,8 @@
                acc)
       []
       (lib.lib_modules @ lib.lib_internal_modules)
-  
+
+
   let generated_unix_files
         ~ctxt
         ~is_native
@@ -1345,350 +2221,1064 @@
         ~ext_dll
         ~source_file_exists
         (cs, bs, lib) =
-  
-    let find_modules lst ext = 
+
+    let find_modules lst ext =
       let find_module modul =
-        match find_module source_file_exists (cs, bs, lib) modul with
+        match find_module source_file_exists bs modul with
+          | `Sources (base_fn, [fn]) when ext <> "cmi"
+                                       && Filename.check_suffix fn ".mli" ->
+              None (* No implementation files for pure interface. *)
           | `Sources (base_fn, _) ->
-              [base_fn]
+              Some [base_fn]
           | `No_sources lst ->
               OASISMessage.warning
                 ~ctxt
                 (f_ "Cannot find source file matching \
                      module '%s' in library %s")
                 modul cs.cs_name;
-              lst
+              Some lst
       in
-      List.map 
-        (fun nm -> 
-           List.map 
-             (fun base_fn -> base_fn ^"."^ext)
-             (find_module nm))
+      List.fold_left
+        (fun acc nm ->
+          match find_module nm with
+            | None -> acc
+            | Some base_fns ->
+                List.map (fun base_fn -> base_fn ^"."^ext) base_fns :: acc)
+        []
         lst
     in
-  
-    (* The headers that should be compiled along *)
-    let headers =
-      if lib.lib_pack then
-        []
-      else
-        find_modules
-          lib.lib_modules
-          "cmi"
+
+    (* The .cmx that be compiled along *)
+    let cmxs =
+      let should_be_built =
+        match bs.bs_compiled_object with
+          | Native -> true
+          | Best -> is_native
+          | Byte -> false
+      in
+        if should_be_built then
+          if lib.lib_pack then
+            find_modules
+              [cs.cs_name]
+              "cmx"
+          else
+            find_modules
+              (lib.lib_modules @ lib.lib_internal_modules)
+              "cmx"
+        else
+          []
+    in
+
+    let acc_nopath =
+      []
+    in
+
+    (* The headers and annot/cmt files that should be compiled along *)
+    let headers =
+      let sufx =
+        if lib.lib_pack
+        then [".cmti"; ".cmt"; ".annot"]
+        else [".cmi"; ".cmti"; ".cmt"; ".annot"]
+      in
+      List.map
+        begin
+          List.fold_left
+            begin fun accu s ->
+              let dot = String.rindex s '.' in
+              let base = String.sub s 0 dot in
+              List.map ((^) base) sufx @ accu
+            end
+            []
+        end
+        (find_modules lib.lib_modules "cmi")
+    in
+
+    (* Compute what libraries should be built *)
+    let acc_nopath =
+      (* Add the packed header file if required *)
+      let add_pack_header acc =
+        if lib.lib_pack then
+          [cs.cs_name^".cmi"; cs.cs_name^".cmti"; cs.cs_name^".cmt"] :: acc
+        else
+          acc
+      in
+      let byte acc =
+        add_pack_header ([cs.cs_name^".cma"] :: acc)
+      in
+      let native acc =
+        let acc =
+          add_pack_header
+            (if has_native_dynlink then
+               [cs.cs_name^".cmxs"] :: acc
+             else acc)
+        in
+          [cs.cs_name^".cmxa"] :: [cs.cs_name^ext_lib] :: acc
+      in
+        match bs.bs_compiled_object with
+          | Native ->
+              byte (native acc_nopath)
+          | Best when is_native ->
+              byte (native acc_nopath)
+          | Byte | Best ->
+              byte acc_nopath
+    in
+
+    (* Add C library to be built *)
+    let acc_nopath =
+      if bs.bs_c_sources <> [] then
+        begin
+          ["lib"^cs.cs_name^"_stubs"^ext_lib]
+          ::
+          ["dll"^cs.cs_name^"_stubs"^ext_dll]
+          ::
+          acc_nopath
+        end
+      else
+        acc_nopath
+    in
+
+      (* All the files generated *)
+      List.rev_append
+        (List.rev_map
+           (List.rev_map
+              (OASISUnixPath.concat bs.bs_path))
+           acc_nopath)
+        (headers @ cmxs)
+
+
+end
+
+module OASISObject = struct
+(* # 22 "src/oasis/OASISObject.ml" *)
+
+
+  open OASISTypes
+  open OASISGettext
+
+
+  let source_unix_files ~ctxt (cs, bs, obj) source_file_exists =
+    List.fold_left
+      (fun acc modul ->
+         match OASISLibrary.find_module source_file_exists bs modul with
+           | `Sources (base_fn, lst) ->
+               (base_fn, lst) :: acc
+           | `No_sources _ ->
+               OASISMessage.warning
+                 ~ctxt
+                 (f_ "Cannot find source file matching \
+                      module '%s' in object %s")
+                 modul cs.cs_name;
+               acc)
+      []
+      obj.obj_modules
+
+
+  let generated_unix_files
+        ~ctxt
+        ~is_native
+        ~source_file_exists
+        (cs, bs, obj) =
+
+    let find_module ext modul =
+      match OASISLibrary.find_module source_file_exists bs modul with
+        | `Sources (base_fn, _) -> [base_fn ^ ext]
+        | `No_sources lst ->
+          OASISMessage.warning
+            ~ctxt
+            (f_ "Cannot find source file matching \
+                 module '%s' in object %s")
+            modul cs.cs_name ;
+          lst
+    in
+
+    let header, byte, native, c_object, f =
+      match obj.obj_modules with
+        | [ m ] -> (find_module ".cmi" m,
+                    find_module ".cmo" m,
+                    find_module ".cmx" m,
+                    find_module ".o" m,
+                    fun x -> x)
+        | _ -> ([cs.cs_name ^ ".cmi"],
+                [cs.cs_name ^ ".cmo"],
+                [cs.cs_name ^ ".cmx"],
+                [cs.cs_name ^ ".o"],
+                OASISUnixPath.concat bs.bs_path)
+    in
+      List.map (List.map f) (
+        match bs.bs_compiled_object with
+          | Native ->
+              native :: c_object :: byte :: header :: []
+          | Best when is_native ->
+              native :: c_object :: byte :: header :: []
+          | Byte | Best ->
+              byte :: header :: [])
+
+
+end
+
+module OASISFindlib = struct
+(* # 22 "src/oasis/OASISFindlib.ml" *)
+
+
+  open OASISTypes
+  open OASISUtils
+  open OASISGettext
+  open OASISSection
+
+
+  type library_name = name
+  type findlib_part_name = name
+  type 'a map_of_findlib_part_name = 'a OASISUtils.MapString.t
+
+
+  exception InternalLibraryNotFound of library_name
+  exception FindlibPackageNotFound of findlib_name
+
+
+  type group_t =
+    | Container of findlib_name * group_t list
+    | Package of (findlib_name *
+                  common_section *
+                  build_section *
+                  [`Library of library | `Object of object_] *
+                  group_t list)
+
+
+  type data = common_section *
+              build_section *
+              [`Library of library | `Object of object_]
+  type tree =
+    | Node of (data option) * (tree MapString.t)
+    | Leaf of data
+
+
+  let findlib_mapping pkg =
+    (* Map from library name to either full findlib name or parts + parent. *)
+    let fndlb_parts_of_lib_name =
+      let fndlb_parts cs lib =
+        let name =
+          match lib.lib_findlib_name with
+            | Some nm -> nm
+            | None -> cs.cs_name
+        in
+        let name =
+          String.concat "." (lib.lib_findlib_containers @ [name])
+        in
+          name
+      in
+        List.fold_left
+          (fun mp ->
+             function
+               | Library (cs, _, lib) ->
+                   begin
+                     let lib_name = cs.cs_name in
+                     let fndlb_parts = fndlb_parts cs lib in
+                       if MapString.mem lib_name mp then
+                         failwithf
+                           (f_ "The library name '%s' is used more than once.")
+                           lib_name;
+                       match lib.lib_findlib_parent with
+                         | Some lib_name_parent ->
+                             MapString.add
+                               lib_name
+                               (`Unsolved (lib_name_parent, fndlb_parts))
+                               mp
+                         | None ->
+                             MapString.add
+                               lib_name
+                               (`Solved fndlb_parts)
+                               mp
+                   end
+
+               | Object (cs, _, obj) ->
+                   begin
+                     let obj_name = cs.cs_name in
+                     if MapString.mem obj_name mp then
+                       failwithf
+                         (f_ "The object name '%s' is used more than once.")
+                         obj_name;
+                     let findlib_full_name = match obj.obj_findlib_fullname with
+                       | Some ns -> String.concat "." ns
+                       | None -> obj_name
+                     in
+                     MapString.add
+                       obj_name
+                       (`Solved findlib_full_name)
+                       mp
+                   end
+
+               | Executable _ | Test _ | Flag _ | SrcRepo _ | Doc _ ->
+                   mp)
+          MapString.empty
+          pkg.sections
+    in
+
+    (* Solve the above graph to be only library name to full findlib name. *)
+    let fndlb_name_of_lib_name =
+      let rec solve visited mp lib_name lib_name_child =
+        if SetString.mem lib_name visited then
+          failwithf
+            (f_ "Library '%s' is involved in a cycle \
+                 with regard to findlib naming.")
+            lib_name;
+        let visited = SetString.add lib_name visited in
+          try
+            match MapString.find lib_name mp with
+              | `Solved fndlb_nm ->
+                  fndlb_nm, mp
+              | `Unsolved (lib_nm_parent, post_fndlb_nm) ->
+                  let pre_fndlb_nm, mp =
+                    solve visited mp lib_nm_parent lib_name
+                  in
+                  let fndlb_nm = pre_fndlb_nm^"."^post_fndlb_nm in
+                    fndlb_nm, MapString.add lib_name (`Solved fndlb_nm) mp
+          with Not_found ->
+            failwithf
+              (f_ "Library '%s', which is defined as the findlib parent of \
+                   library '%s', doesn't exist.")
+              lib_name lib_name_child
+      in
+      let mp =
+        MapString.fold
+          (fun lib_name status mp ->
+             match status with
+               | `Solved _ ->
+                   (* Solved initialy, no need to go further *)
+                   mp
+               | `Unsolved _ ->
+                   let _, mp = solve SetString.empty mp lib_name "<none>" in
+                     mp)
+          fndlb_parts_of_lib_name
+          fndlb_parts_of_lib_name
+      in
+        MapString.map
+          (function
+             | `Solved fndlb_nm -> fndlb_nm
+             | `Unsolved _ -> assert false)
+          mp
+    in
+
+    (* Convert an internal library name to a findlib name. *)
+    let findlib_name_of_library_name lib_nm =
+      try
+        MapString.find lib_nm fndlb_name_of_lib_name
+      with Not_found ->
+        raise (InternalLibraryNotFound lib_nm)
+    in
+
+    (* Add a library to the tree.
+     *)
+    let add sct mp =
+      let fndlb_fullname =
+        let cs, _, _ = sct in
+        let lib_name = cs.cs_name in
+          findlib_name_of_library_name lib_name
+      in
+      let rec add_children nm_lst (children: tree MapString.t) =
+        match nm_lst with
+          | (hd :: tl) ->
+              begin
+                let node =
+                  try
+                    add_node tl (MapString.find hd children)
+                  with Not_found ->
+                    (* New node *)
+                    new_node tl
+                in
+                  MapString.add hd node children
+              end
+          | [] ->
+              (* Should not have a nameless library. *)
+              assert false
+      and add_node tl node =
+        if tl = [] then
+          begin
+            match node with
+              | Node (None, children) ->
+                  Node (Some sct, children)
+              | Leaf (cs', _, _) | Node (Some (cs', _, _), _) ->
+                  (* TODO: allow to merge Package, i.e.
+                   * archive(byte) = "foo.cma foo_init.cmo"
+                   *)
+                  let cs, _, _ = sct in
+                    failwithf
+                      (f_ "Library '%s' and '%s' have the same findlib name '%s'")
+                      cs.cs_name cs'.cs_name fndlb_fullname
+          end
+        else
+          begin
+            match node with
+              | Leaf data ->
+                  Node (Some data, add_children tl MapString.empty)
+              | Node (data_opt, children) ->
+                  Node (data_opt, add_children tl children)
+          end
+      and new_node =
+        function
+          | [] ->
+              Leaf sct
+          | hd :: tl ->
+              Node (None, MapString.add hd (new_node tl) MapString.empty)
+      in
+        add_children (OASISString.nsplit fndlb_fullname '.') mp
+    in
+
+    let rec group_of_tree mp =
+      MapString.fold
+        (fun nm node acc ->
+           let cur =
+             match node with
+               | Node (Some (cs, bs, lib), children) ->
+                   Package (nm, cs, bs, lib, group_of_tree children)
+               | Node (None, children) ->
+                   Container (nm, group_of_tree children)
+               | Leaf (cs, bs, lib) ->
+                   Package (nm, cs, bs, lib, [])
+           in
+             cur :: acc)
+        mp []
+    in
+
+    let group_mp =
+      List.fold_left
+        (fun mp ->
+           function
+             | Library (cs, bs, lib) ->
+                 add (cs, bs, `Library lib) mp
+             | Object (cs, bs, obj) ->
+                 add (cs, bs, `Object obj) mp
+             | _ ->
+                 mp)
+        MapString.empty
+        pkg.sections
+    in
+
+    let groups =
+      group_of_tree group_mp
+    in
+
+    let library_name_of_findlib_name =
+      lazy begin
+        (* Revert findlib_name_of_library_name. *)
+        MapString.fold
+          (fun k v mp -> MapString.add v k mp)
+          fndlb_name_of_lib_name
+          MapString.empty
+      end
+    in
+    let library_name_of_findlib_name fndlb_nm =
+      try
+        MapString.find fndlb_nm (Lazy.force library_name_of_findlib_name)
+      with Not_found ->
+        raise (FindlibPackageNotFound fndlb_nm)
+    in
+
+      groups,
+      findlib_name_of_library_name,
+      library_name_of_findlib_name
+
+
+  let findlib_of_group =
+    function
+      | Container (fndlb_nm, _)
+      | Package (fndlb_nm, _, _, _, _) -> fndlb_nm
+
+
+  let root_of_group grp =
+    let rec root_lib_aux =
+      (* We do a DFS in the group. *)
+      function
+        | Container (_, children) ->
+            List.fold_left
+              (fun res grp ->
+                 if res = None then
+                   root_lib_aux grp
+                 else
+                   res)
+              None
+              children
+        | Package (_, cs, bs, lib, _) ->
+            Some (cs, bs, lib)
+    in
+      match root_lib_aux grp with
+        | Some res ->
+            res
+        | None ->
+            failwithf
+              (f_ "Unable to determine root library of findlib library '%s'")
+              (findlib_of_group grp)
+
+
+end
+
+module OASISFlag = struct
+(* # 22 "src/oasis/OASISFlag.ml" *)
+
+
+end
+
+module OASISPackage = struct
+(* # 22 "src/oasis/OASISPackage.ml" *)
+
+
+end
+
+module OASISSourceRepository = struct
+(* # 22 "src/oasis/OASISSourceRepository.ml" *)
+
+
+end
+
+module OASISTest = struct
+(* # 22 "src/oasis/OASISTest.ml" *)
+
+
+end
+
+module OASISDocument = struct
+(* # 22 "src/oasis/OASISDocument.ml" *)
+
+
+end
+
+module OASISExec = struct
+(* # 22 "src/oasis/OASISExec.ml" *)
+
+
+  open OASISGettext
+  open OASISUtils
+  open OASISMessage
+
+
+
+
+  (* In general, there is no chance to quote properly with the current
+   * settings. ( This is only a problem, if BaseCustom.run is used (e.g
+   * test commands, PreConfigure,....). Most of the time, OASISExec.run
+   * is used with enabled quoting.)
+   *
+   * "$rm" should ideally expand to 'rm -f' (no quotes), but "$test_exec"
+   * should ideally expand to '"C:\Program Files\dir\test.exe"' (with
+   * quotes). Paths with spaces are common on Windows, so this problem
+   * can't be ignored.
+   *
+   * Using a command with additional parameters is quite useful, not only
+   * for trivial cases like $rm. You could add an additional parameter
+   * for $make in order to use a special compatibility mode, on windows
+   * you can use it to inform ocaml that a certain program is a shell
+   * script ('sh.exe pcre-config').
+   *
+   * An additional parameter (e.g. $rm_switches) would be ugly,
+   * especially for *nix users, who don't use space characters in their
+   * installation paths anyway.
+   *
+   * I use the following workaround, which should work most of the time:
+   *
+   * - if cmd doesn't contains spaces or other suspicious characters, it
+   * can be quoted in the usual way (not ambigous, I think)
+   *
+   * - if cmd does contain spaces, a file with this name exists, and the
+   * beginning of cmd looks like a absolute pathname
+   * ('\\test\dir\foo.exe' or "C:\\sa df\\foo.exe" - not "foo.exe" ), I
+   * will also quote it. (ambigous, there could be "C:\bin\rm.exe" and
+   * "C:\bin\rm -f.exe").  Relative filenames are not considered, because
+   * I assume the source code folder contains only well named files and
+   * relative paths like "../../make.exe" are uncommon (autoconf even
+   * rejects them) *)
+
+
+  (* stricter settings as for regular windows batch lines
+   * necessary because of shell comannds like:
+   *   LC_ALL=C make ....
+   *)
+  let is_dubious_char = function
+    | '~' | ':' | '.' | '-' | '_' | '/' | '\\' -> false
+    | c ->
+      OASISString.is_digit c = false &&
+      OASISString.is_alpha c = false
+
+
+  let win_quote_needed str =
+    let f = function
+      (* this list is not exhaustive. Feel free to added common chars, that
+       * can be passed to cmd.exe without quoting *)
+      | 'a' .. 'z'  | 'A' .. 'Z' | '0' .. '9'
+      | '_' | '-' | '~' | '.' | ':' | ',' | '\\' -> false
+      | _ -> true
+    in
+      str = "" || OASISString.exists f str
+
+  let is_simple_command str =
+    String.length str > 0 &&
+    not (OASISString.exists is_dubious_char str)
+
+  let is_path_sep = function
+    | '/' | '\\' -> true
+    | _ -> false
+
+  let starts_with_absolute_path cmd =
+    let len = String.length cmd in
+      if len < 3 then
+        false
+      else
+        let c0 = cmd.[0] in
+        let c1 = cmd.[1] in
+          if is_path_sep c0 && is_path_sep c1 then (* network devices: "//" *)
+            true
+          else if len = 3 then
+            false
+          else  (* C:\.... *)
+            OASISString.is_alpha c0 && c1 = ':' && is_path_sep cmd.[2]
+
+  let exe_exts = lazy
+    begin
+      let exts =
+        try
+          OASISString.nsplit
+            (Sys.getenv "PATHEXT")
+            ';'
+        with
+          | Not_found -> []
+      in
+      let exts' =
+        List.filter
+          ( fun a -> a <> "" && a.[0] = '.' && a <> ".EXE" )
+          (List.map String.uppercase exts) (* windows file system doesn't care *)
+      in
+        ".EXE"::exts' (* .exe first, most common *)
+    end
+
+  let exe_file_exists fln =
+    Sys.file_exists fln ||
+    List.exists
+      (fun a -> Sys.file_exists ( fln ^ a ) )
+      (Lazy.force exe_exts)
+
+
+  let quote_anyway cmd =
+    if Sys.os_type <> "Win32" then (* workaround for windows only *)
+      false
+    else if is_simple_command cmd then
+      true
+    else
+      OASISString.exists OASISString.is_whitespace cmd &&
+        starts_with_absolute_path cmd &&
+        exe_file_exists cmd
+
+
+  let run_bash ~ctxt ?f_exit_code ?(quote=true) cmd args =
+    let fn = Filename.temp_file "oasis-" ".sh" in
+    let fn_deleted = ref false in
+      try
+        begin
+          let ch = open_out_bin fn in
+          let ch_closed = ref false in
+            try
+              begin
+                let cmd =
+                  if quote || quote_anyway cmd then
+                    OASISHostPath.quote (OASISHostPath.of_unix cmd)
+                  else
+                    cmd
+                in
+                  output_string ch cmd;
+                  List.iter
+                    ( fun s -> output_char ch ' '; output_string ch s )
+                    args ;
+                  output_char ch '\n';
+                  ch_closed:=true ;
+                  close_out ch;
+                  let bash = !OASISHostPath.bash_cmd () in
+                  let add_quotes = ref false in
+                  let shell_cmd =
+                    if Sys.os_type <> "Win32" then
+                      Filename.quote bash
+                    else
+                      if win_quote_needed bash = false then
+                        bash
+                      else
+                        begin
+                          add_quotes := true;
+                          Filename.quote bash
+                        end
+                  in
+                  let cmdline_orig = String.concat " " (cmd :: args) in
+                  let cmdline =
+                    let s = shell_cmd ^ " " ^ (Filename.quote fn) in
+                      if !add_quotes then
+                        "\"" ^ s ^ "\""
+                      else
+                        s
+                  in
+                    info ~ctxt (f_ "Running command '%s'") cmdline_orig;
+                    let ret = Sys.command cmdline in
+                      fn_deleted := true;
+                      Sys.remove fn;
+                      match f_exit_code, ret with
+                        | None, 0 -> ()
+                        | None, i ->
+                            failwithf
+                              (f_ "Command '%s' terminated with error code %d")
+                              cmdline_orig i
+                        | Some f, i ->
+                            f i
+              end
+            with
+              | x when !ch_closed = false ->
+                  close_out_noerr ch;
+                  raise x
+        end
+      with
+        | x when !fn_deleted = false ->
+            (try Sys.remove fn with _ -> () ) ;
+            raise x
+
+  (* TODO: I don't like this quote, it is there because $(rm) foo expands to
+   * 'rm -f' foo...
+   *)
+
+  let run_default ~ctxt ?f_exit_code ?(quote=true) cmd args =
+    let add_quotes = ref false in
+    let cmd =
+      if quote || quote_anyway cmd then
+        if Sys.os_type = "Win32" then
+          begin
+            if win_quote_needed cmd = false then
+            cmd
+        else
+              begin
+                (* Double the 1st double quote... win32... sigh *)
+                (* Above comment ist false. The whole string must be quoted.
+                 * However, an error is only triggered, if args contains also
+                 * quoted parameters *)
+                add_quotes := true;
+                Filename.quote cmd
+              end
+          end
+        else
+          Filename.quote cmd
+      else
+        cmd
+    in
+    let cmdline =
+      let s = String.concat " " (cmd :: args) in
+        match !add_quotes with
+          | true -> "\"" ^ s ^ "\""
+          | false -> s
+    in
+      info ~ctxt (f_ "Running command '%s'") cmdline;
+      match f_exit_code, Sys.command cmdline with
+        | None, 0 -> ()
+        | None, i ->
+            failwithf
+              (f_ "Command '%s' terminated with error code %d")
+              cmdline i
+        | Some f, i ->
+            f i
+
+
+
+  let run ~ctxt ?f_exit_code ?quote cmd args =
+    if OASISHostPath.use_bash () then
+      run_bash ~ctxt ?f_exit_code ?quote cmd args
+    else
+      run_default ~ctxt ?f_exit_code ?quote cmd args
+
+  let run_read_output ~ctxt ?f_exit_code cmd args =
+    let fn =
+      Filename.temp_file "oasis-" ".txt"
+    in
+      try
+        begin
+          let () =
+            run ~ctxt ?f_exit_code cmd (args @ [">"; Filename.quote fn])
+          in
+          let chn =
+            open_in fn
+          in
+          let routput =
+            ref []
+          in
+            begin
+              try
+                while true do
+                  routput := (input_line chn) :: !routput
+                done
+              with End_of_file ->
+                ()
+            end;
+            close_in chn;
+            Sys.remove fn;
+            List.rev !routput
+        end
+      with e ->
+        (try Sys.remove fn with _ -> ());
+        raise e
+
+
+  let run_read_one_line ~ctxt ?f_exit_code cmd args =
+    match run_read_output ~ctxt ?f_exit_code cmd args with
+      | [fst] ->
+          fst
+      | lst ->
+          failwithf
+            (f_ "Command return unexpected output %S")
+            (String.concat "\n" lst)
+end
+
+module OASISFileUtil = struct
+(* # 22 "src/oasis/OASISFileUtil.ml" *)
+
+
+  open OASISGettext
+
+
+  let file_exists_case fn =
+    let dirname = Filename.dirname fn in
+    let basename = Filename.basename fn in
+      if Sys.file_exists dirname then
+        if basename = Filename.current_dir_name then
+          true
+        else
+          List.mem
+            basename
+            (Array.to_list (Sys.readdir dirname))
+      else
+        false
+
+
+  let find_file ?(case_sensitive=true) paths exts =
+
+    (* Cardinal product of two list *)
+    let ( * ) lst1 lst2 =
+      List.flatten
+        (List.map
+           (fun a ->
+              List.map
+                (fun b -> a, b)
+                lst2)
+           lst1)
+    in
+
+    let rec combined_paths lst =
+      match lst with
+        | p1 :: p2 :: tl ->
+            let acc =
+              (List.map
+                 (fun (a, b) -> Filename.concat a b)
+                 (p1 * p2))
+            in
+              combined_paths (acc :: tl)
+        | [e] ->
+            e
+        | [] ->
+            []
+    in
+
+    let alternatives =
+      List.map
+        (fun (p, e) ->
+           if String.length e > 0 && e.[0] <> '.' then
+             p ^ "." ^ e
+           else
+             p ^ e)
+        ((combined_paths paths) * exts)
+    in
+      List.find (fun file ->
+        (if case_sensitive then
+           file_exists_case file
+         else
+           Sys.file_exists file)
+        && not (Sys.is_directory file)
+      ) alternatives
+
+
+  let which ~ctxt prg =
+    let path_sep =
+      match Sys.os_type with
+        | "Win32" ->
+            ';'
+        | _ ->
+            ':'
+    in
+    let path_lst = OASISString.nsplit (Sys.getenv "PATH") path_sep in
+    let exec_ext =
+      match Sys.os_type with
+        | "Win32" ->
+            "" :: (OASISString.nsplit (Sys.getenv "PATHEXT") path_sep)
+        | _ ->
+            [""]
     in
-  
-    (* The .cmx that be compiled along *)
-    let cmxs =
-      let should_be_built =
-        (not lib.lib_pack) && (* Do not install .cmx packed submodules *)
-        match bs.bs_compiled_object with
-          | Native -> true
-          | Best -> is_native
-          | Byte -> false
-      in
-        if should_be_built then
-          find_modules
-            (lib.lib_modules @ lib.lib_internal_modules)
-            "cmx"
-        else
-          []
+    let p =
+      find_file ~case_sensitive:false [path_lst; [prg]] exec_ext
     in
-  
-    let acc_nopath =
-      []
+      OASISHostPath.of_unix p
+
+
+  (**/**)
+  let rec fix_dir dn =
+    (* Windows hack because Sys.file_exists "src\\" = false when
+     * Sys.file_exists "src" = true
+     *)
+    let ln =
+      String.length dn
     in
-  
-    (* Compute what libraries should be built *)
-    let acc_nopath =
-      (* Add the packed header file if required *)
-      let add_pack_header acc =
-        if lib.lib_pack then
-          [cs.cs_name^".cmi"] :: acc
+      if Sys.os_type = "Win32" && ln > 0 && dn.[ln - 1] = '\\' then
+        fix_dir (String.sub dn 0 (ln - 1))
+      else
+        dn
+
+
+  let q s = OASISHostPath.quote (OASISHostPath.of_unix s)
+  (**/**)
+
+
+  let cp ~ctxt ?(recurse=false) src tgt =
+    if recurse then
+      (*
+        'xcopy /E' and 'cp -r' don't have the same semantic!
+        -dir2 does exist:
+          xcopy dir dir2 /E -> copys content of dir into dir2 (dir2/dir doesn't exist!)
+          cp -r dir dir2    -> copys dir to dir2 (dir2/dir does exist!)
+        -dir2 doesn't exist:
+          xcopy dir dir2 /E -> request on command line, if dir2 is an directory or file.
+          cp -r dir dir2    -> dir and dir2 have the same content (dir2/dir doesn't exist)
+        Probably, there are even more differences,....
+      *)
+      if Sys.os_type = "Win32" && OASISHostPath.use_bash () = false then
+        let tgt_real =
+          if Sys.file_exists tgt = false then
+            begin
+              OASISExec.run ~ctxt "md" [q tgt];
+              tgt
+            end
+    else
+            let base = Filename.basename src in
+            if base = "." then
+              tgt
+            else
+              let tgt_real = Filename.concat tgt base in
+                if Sys.file_exists tgt_real = false then
+                  OASISExec.run ~ctxt "md" [q tgt_real];
+              tgt_real
+        in
+        OASISExec.run ~ctxt "xcopy" [q src; q tgt_real; "/E" ; "/Q" ; "/Y"]
+      else
+        OASISExec.run ~ctxt "cp" ["-r"; q src; q tgt]
+    else
+      if Sys.os_type = "Win32" && OASISHostPath.use_bash () = false then
+        OASISExec.run ~ctxt "copy" [q src; q tgt ; "/Y"]
+      else
+        OASISExec.run ~ctxt "cp" [q src; q tgt]
+
+
+  let mkdir ~ctxt tgt =
+    OASISExec.run ~ctxt
+      ( if Sys.os_type = "Win32" && not (OASISHostPath.use_bash ()) then
+          "md"
         else
-          acc
-      in
-      let byte acc =
-        add_pack_header ([cs.cs_name^".cma"] :: acc)
-      in
-      let native acc =
-        let acc = [cs.cs_name^".cmxa"] :: [cs.cs_name^ext_lib] :: acc in
-        add_pack_header
-          (if has_native_dynlink then
-             [cs.cs_name^".cmxs"] :: acc
-           else acc)
-      in
-        match bs.bs_compiled_object with
-          | Native ->
-              byte (native acc_nopath)
-          | Best when is_native ->
-              byte (native acc_nopath)
-          | Byte | Best ->
-              byte acc_nopath
+          "mkdir" )
+      [q tgt]
+
+
+  let rec mkdir_parent ~ctxt f tgt =
+    let tgt =
+      fix_dir tgt
     in
-  
-    (* Add C library to be built *)
-    let acc_nopath =
-      if bs.bs_c_sources <> [] then
+      if Sys.file_exists tgt then
         begin
-          ["lib"^cs.cs_name^"_stubs"^ext_lib]
-          ::
-          ["dll"^cs.cs_name^"_stubs"^ext_dll]
-          ::
-          acc_nopath
+          if not (Sys.is_directory tgt) then
+            OASISUtils.failwithf
+              (f_ "Cannot create directory '%s', a file of the same name already \
+                   exists")
+              tgt
         end
       else
-        acc_nopath
-    in
-  
-      (* All the files generated *)
-      List.rev_append
-        (List.rev_map
-           (List.rev_map
-              (OASISUnixPath.concat bs.bs_path))
-           acc_nopath)
-        (headers @ cmxs)
-  
-  
-  type group_t =
-    | Container of findlib_name * (group_t list)
-    | Package of (findlib_name *
-                  common_section *
-                  build_section *
-                  library *
-                  (group_t list))
-  
-  let group_libs pkg =
-    (** Associate a name with its children *)
-    let children =
-      List.fold_left
-        (fun mp ->
-           function
-             | Library (cs, bs, lib) ->
-                 begin
-                   match lib.lib_findlib_parent with
-                     | Some p_nm ->
-                         begin
-                           let children =
-                             try
-                               MapString.find p_nm mp
-                             with Not_found ->
-                               []
-                           in
-                             MapString.add p_nm ((cs, bs, lib) :: children) mp
-                         end
-                     | None ->
-                         mp
-                 end
-             | _ ->
-                 mp)
-        MapString.empty
-        pkg.sections
-    in
-  
-    (* Compute findlib name of a single node *)
-    let findlib_name (cs, _, lib) =
-      match lib.lib_findlib_name with
-        | Some nm -> nm
-        | None -> cs.cs_name
-    in
-  
-    (** Build a package tree *)
-    let rec tree_of_library containers ((cs, bs, lib) as acc) =
-      match containers with
-        | hd :: tl ->
-            Container (hd, [tree_of_library tl acc])
-        | [] ->
-            Package 
-              (findlib_name acc, cs, bs, lib,
-               (try
-                  List.rev_map
-                    (fun ((_, _, child_lib) as child_acc) ->
-                       tree_of_library
-                         child_lib.lib_findlib_containers
-                         child_acc)
-                    (MapString.find cs.cs_name children)
-                with Not_found ->
-                  []))
-    in
-  
-    (** Merge containers with the same name *)
-    let rec merge_containers groups =
-      (* Collect packages and create the map "container name -> merged children" *)
-      let packages, containers =
-        List.fold_left
-          (fun (packages, containers) group ->
-             match group with
-               | Container(name, children) ->
-                   let children' =
-                     try
-                       MapString.find name containers
-                     with Not_found ->
-                       []
-                   in
-                   (packages,
-                    MapString.add name (children' @ children) containers)
-               | Package(name, cs, bs, lib, children) ->
-                   (Package(name, cs, bs, lib, merge_containers children) :: packages,
-                    containers))
-          ([], MapString.empty)
-          groups
-      in
-      (* Recreate the list of groups *)
-      packages @
-        (MapString.fold
-           (fun name children acc ->
-              Container(name, merge_containers children) :: acc)
-           containers [])
-    in
-  
-      (* TODO: check that libraries are unique *)
-      merge_containers
-        (List.fold_left
-           (fun acc ->
-              function
-                | Library (cs, bs, lib) when lib.lib_findlib_parent = None -> 
-                    (tree_of_library lib.lib_findlib_containers (cs, bs, lib)) :: acc
-                | _ ->
-                    acc)
-           []
-           pkg.sections)
-  
-  (** Compute internal to findlib library matchings, including subpackage
-      and return a map of it.
-    *)
-  let findlib_name_map pkg =
-  
-    (* Compute names in a tree *)
-    let rec findlib_names_aux path mp grp =
-      let fndlb_nm, children, mp =
-        match grp with
-          | Container (fndlb_nm, children) ->
-              fndlb_nm, children, mp
-  
-          | Package (fndlb_nm, {cs_name = nm}, _, _, children) ->
-              fndlb_nm, children, (MapString.add nm (path, fndlb_nm) mp)
-      in
-      let fndlb_nm_full =
-        (match path with
-           | Some pth -> pth^"."
-           | None -> "")^
-        fndlb_nm
-      in
-        List.fold_left
-          (findlib_names_aux (Some fndlb_nm_full))
-          mp
-          children
-    in
-  
-      List.fold_left
-        (findlib_names_aux None)
-        MapString.empty
-        (group_libs pkg)
-  
-  
-  let findlib_of_name ?(recurse=false) map nm =
-    try
-      let (path, fndlb_nm) =
-        MapString.find nm map
-      in
-        match path with
-          | Some pth when recurse -> pth^"."^fndlb_nm
-          | _ -> fndlb_nm
-  
-    with Not_found ->
-      failwithf
-        (f_ "Unable to translate internal library '%s' to findlib name")
-        nm
-  
-  let name_findlib_map pkg =
-    let mp =
-      findlib_name_map pkg
-    in
-      MapString.fold
-        (fun nm _ acc ->
-           let fndlb_nm_full =
-             findlib_of_name
-               ~recurse:true
-               mp
-               nm
-           in
-             MapString.add fndlb_nm_full nm acc)
-        mp
-        MapString.empty
-  
-  let findlib_of_group =
-    function
-      | Container (fndlb_nm, _)
-      | Package (fndlb_nm, _, _, _, _) -> fndlb_nm
-  
-  let root_of_group grp =
-    let rec root_lib_aux =
-      function
-        | Container (_, children) ->
-            root_lib_lst children
-        | Package (_, cs, bs, lib, children) ->
-            if lib.lib_findlib_parent = None then
-              cs, bs, lib
-            else
-              root_lib_lst children
-    and root_lib_lst =
-      function
-        | [] ->
-            raise Not_found
-        | hd :: tl ->
-            try
-              root_lib_aux hd
-            with Not_found ->
-              root_lib_lst tl
-    in
-      try
-        root_lib_aux grp
-      with Not_found ->
-        failwithf
-          (f_ "Unable to determine root library of findlib library '%s'")
-          (findlib_of_group grp)
-  
-  
-end
-
-module OASISFlag = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/oasis/OASISFlag.ml"
-  
-end
+        begin
+          mkdir_parent ~ctxt f (Filename.dirname tgt);
+          if not (Sys.file_exists tgt) then
+            begin
+              f tgt;
+              mkdir ~ctxt tgt
+            end
+        end
 
-module OASISPackage = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/oasis/OASISPackage.ml"
-  
-end
 
-module OASISSourceRepository = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/oasis/OASISSourceRepository.ml"
-  
-end
+  let rmdir ~ctxt tgt =
+    if Sys.readdir tgt = [||] then begin
+      if Sys.os_type = "Win32" && OASISHostPath.use_bash () = false then
+            OASISExec.run ~ctxt "rd" [q tgt]
+      else
+            OASISExec.run ~ctxt "rm" ["-r"; q tgt]
+    end else begin
+      OASISMessage.error ~ctxt
+        (f_ "Cannot remove directory '%s': not empty.")
+        tgt
+    end
 
-module OASISTest = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/oasis/OASISTest.ml"
-  
-end
 
-module OASISDocument = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/oasis/OASISDocument.ml"
-  
+  let glob ~ctxt fn =
+   let basename =
+     Filename.basename fn
+   in
+     if String.length basename >= 2 &&
+        basename.[0] = '*' &&
+        basename.[1] = '.' then
+       begin
+         let ext_len =
+           (String.length basename) - 2
+         in
+         let ext =
+           String.sub basename 2 ext_len
+         in
+         let dirname =
+           Filename.dirname fn
+         in
+           Array.fold_left
+             (fun acc fn ->
+                try
+                  let fn_ext =
+                    String.sub
+                      fn
+                      ((String.length fn) - ext_len)
+                      ext_len
+                  in
+                    if fn_ext = ext then
+                      (Filename.concat dirname fn) :: acc
+                    else
+                      acc
+                with Invalid_argument _ ->
+                  acc)
+             []
+             (Sys.readdir dirname)
+       end
+     else
+       begin
+         if file_exists_case fn then
+           [fn]
+         else
+           []
+       end
 end
 
 
+# 3265 "setup.ml"
 module BaseEnvLight = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/base/BaseEnvLight.ml"
-  
+(* # 22 "src/base/BaseEnvLight.ml" *)
+
+
   module MapString = Map.Make(String)
-  
+
+
   type t = string MapString.t
-  
+
+
   let default_filename =
     Filename.concat
       (Sys.getcwd ())
       "setup.data"
-  
+
+
   let load ?(allow_empty=false) ?(filename=default_filename) () =
     if Sys.file_exists filename then
       begin
@@ -1745,28 +3335,31 @@
              "Unable to load environment, the file '%s' doesn't exist."
              filename)
       end
-  
-  let var_get name env =
-    let rec var_expand str =
-      let buff =
-        Buffer.create ((String.length str) * 2)
-      in
-        Buffer.add_substitute
-          buff
-          (fun var ->
-             try
-               var_expand (MapString.find var env)
-             with Not_found ->
-               failwith
-                 (Printf.sprintf
-                    "No variable %s defined when trying to expand %S."
-                    var
-                    str))
-          str;
-        Buffer.contents buff
+
+
+  let rec var_expand str env =
+    let buff =
+      Buffer.create ((String.length str) * 2)
     in
-      var_expand (MapString.find name env)
-  
+      Buffer.add_substitute
+        buff
+        (fun var ->
+           try
+             var_expand (MapString.find var env) env
+           with Not_found ->
+             failwith
+               (Printf.sprintf
+                  "No variable %s defined when trying to expand %S."
+                  var
+                  str))
+        str;
+      Buffer.contents buff
+
+
+  let var_get name env =
+    var_expand (MapString.find name env) env
+
+
   let var_choose lst env =
     OASISExpr.choose
       (fun nm -> var_get nm env)
@@ -1774,90 +3367,71 @@
 end
 
 
+# 3370 "setup.ml"
 module BaseContext = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/base/BaseContext.ml"
-  
+(* # 22 "src/base/BaseContext.ml" *)
+
+  (* TODO: get rid of this module. *)
   open OASISContext
-  
-  let args = args
-  
+
+
+  let args () = fst (fspecs ())
+
+
   let default = default
-  
+
 end
 
 module BaseMessage = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/base/BaseMessage.ml"
-  
+(* # 22 "src/base/BaseMessage.ml" *)
+
+
   (** Message to user, overrid for Base
       @author Sylvain Le Gall
     *)
   open OASISMessage
   open BaseContext
-  
+
+
   let debug fmt   = debug ~ctxt:!default fmt
-  
+
+
   let info fmt    = info ~ctxt:!default fmt
-  
+
+
   let warning fmt = warning ~ctxt:!default fmt
-  
+
+
   let error fmt = error ~ctxt:!default fmt
-  
-end
 
-module BaseFilePath = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/base/BaseFilePath.ml"
-  
-  
-  open Filename
-  
-  module Unix = OASISUnixPath
-  
-  let make =
-    function
-      | [] ->
-          invalid_arg "BaseFilename.make"
-      | hd :: tl ->
-          List.fold_left Filename.concat hd tl
-  
-  let of_unix ufn =
-    if Sys.os_type = "Unix" then
-      ufn
-    else
-      make
-        (List.map
-           (fun p ->
-              if p = Unix.current_dir_name then
-                current_dir_name
-              else if p = Unix.parent_dir_name then
-                parent_dir_name
-              else
-                p)
-           (OASISUtils.split '/' ufn))
-  
 end
 
 module BaseEnv = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/base/BaseEnv.ml"
-  
+(* # 22 "src/base/BaseEnv.ml" *)
+
   open OASISGettext
   open OASISUtils
   open PropList
-  
+
+
   module MapString = BaseEnvLight.MapString
-  
+
+
   type origin_t =
     | ODefault
     | OGetEnv
     | OFileLoad
     | OCommandLine
-  
+
+
   type cli_handle_t =
     | CLINone
     | CLIAuto
     | CLIWith
     | CLIEnable
     | CLIUser of (Arg.key * Arg.spec * Arg.doc) list
-  
+
+
   type definition_t =
       {
         hide:       bool;
@@ -1866,23 +3440,28 @@
         arg_help:   string option;
         group:      string option;
       }
-  
+
+
   let schema =
     Schema.create "environment"
-  
+
+
   (* Environment data *)
   let env =
     Data.create ()
-  
+
+
   (* Environment data from file *)
   let env_from_file =
     ref MapString.empty
-  
+
+
   (* Lexer for var *)
   let var_lxr =
     Genlex.make_lexer []
-  
-  let rec var_expand str =
+
+
+  let rec var_expand ?(quoted=false) str =
     let buff =
       Buffer.create ((String.length str) * 2)
     in
@@ -1902,15 +3481,19 @@
              in
                match Stream.npeek 3 st with
                  | [Genlex.Ident "utoh"; Genlex.Ident nm] ->
-                     BaseFilePath.of_unix (var_get nm)
+                     OASISHostPath.of_unix (var_get nm)
                  | [Genlex.Ident "utoh"; Genlex.String s] ->
-                     BaseFilePath.of_unix s
+                     OASISHostPath.of_unix s
                  | [Genlex.Ident "ocaml_escaped"; Genlex.Ident nm] ->
                      String.escaped (var_get nm)
                  | [Genlex.Ident "ocaml_escaped"; Genlex.String s] ->
                      String.escaped s
                  | [Genlex.Ident nm] ->
-                     var_get nm
+                     let s = var_get nm in
+                     if quoted then
+                       OASISHostPath.quote s
+                     else
+                       s
                  | _ ->
                      failwithf
                        (f_ "Unknown expression '%s' in variable expansion of %s.")
@@ -1931,7 +3514,8 @@
                    e)
         str;
       Buffer.contents buff
-  
+
+
   and var_get name =
     let vl =
       try
@@ -1945,14 +3529,16 @@
         end
     in
       var_expand vl
-  
+
+
   let var_choose ?printer ?name lst =
     OASISExpr.choose
       ?printer
       ?name
       var_get
       lst
-  
+
+
   let var_protect vl =
     let buff =
       Buffer.create (String.length vl)
@@ -1963,7 +3549,8 @@
            | c   -> Buffer.add_char   buff c)
         vl;
       Buffer.contents buff
-  
+
+
   let var_define
         ?(hide=false)
         ?(dump=true)
@@ -1974,7 +3561,7 @@
         name (* TODO: type constraint on the fact that name must be a valid OCaml
                   id *)
         dflt =
-  
+
     let default =
       [
         OFileLoad, (fun () -> MapString.find name !env_from_file);
@@ -1982,7 +3569,7 @@
         OGetEnv,   (fun () -> Sys.getenv name);
       ]
     in
-  
+
     let extra =
       {
         hide     = hide;
@@ -1992,7 +3579,7 @@
         group    = group;
       }
     in
-  
+
     (* Try to find a value that can be defined
      *)
     let var_get_low lst =
@@ -2027,13 +3614,13 @@
           | None, lst ->
               raise (Not_set (name, Some (String.concat (s_ ", ") lst)))
     in
-  
+
     let help =
       match short_desc with
         | Some fs -> Some fs
         | None -> None
     in
-  
+
     let var_get_lst =
       FieldRO.create
         ~schema
@@ -2045,10 +3632,11 @@
         ?help
         extra
     in
-  
+
       fun () ->
         var_expand (var_get_low (var_get_lst env))
-  
+
+
   let var_redefine
         ?hide
         ?dump
@@ -2076,10 +3664,11 @@
           name
           dflt
       end
-  
-  let var_ignore (e : unit -> string) =
-    ()
-  
+
+
+  let var_ignore (e: unit -> string) = ()
+
+
   let print_hidden =
     var_define
       ~hide:true
@@ -2088,7 +3677,8 @@
       ~arg_help:"Print even non-printable variable. (debug)"
       "print_hidden"
       (fun () -> "false")
-  
+
+
   let var_all () =
     List.rev
       (Schema.fold
@@ -2099,25 +3689,29 @@
               acc)
          []
          schema)
-  
+
+
   let default_filename =
     BaseEnvLight.default_filename
-  
+
+
   let load ?allow_empty ?filename () =
     env_from_file := BaseEnvLight.load ?allow_empty ?filename ()
-  
+
+
   let unload () =
     env_from_file := MapString.empty;
     Data.clear env
-  
+
+
   let dump ?(filename=default_filename) () =
     let chn =
       open_out_bin filename
     in
-    let output nm value = 
+    let output nm value =
       Printf.fprintf chn "%s=%S\n" nm value
     in
-    let mp_todo = 
+    let mp_todo =
       (* Dump data from schema *)
       Schema.fold
         (fun mp_todo nm def _ ->
@@ -2140,10 +3734,11 @@
     in
       (* Dump data defined outside of schema *)
       MapString.iter output mp_todo;
-  
+
       (* End of the dump *)
       close_out chn
-  
+
+
   let print () =
     let printable_vars =
       Schema.fold
@@ -2179,14 +3774,15 @@
     let dot_pad str =
       String.make ((max_length - (String.length str)) + 3) '.'
     in
-  
+
     Printf.printf "\nConfiguration: \n";
     List.iter
-      (fun (name,value) ->
+      (fun (name, value) ->
         Printf.printf "%s: %s %s\n" name (dot_pad name) value)
       (List.rev printable_vars);
     Printf.printf "\n%!"
-  
+
+
   let args () =
     let arg_concat =
       OASISUtils.varname_concat ~hyphen:'-'
@@ -2213,7 +3809,7 @@
                ]
            ),
         "var+val  Override any configuration variable.";
-  
+
       ]
       @
       List.flatten
@@ -2227,23 +3823,23 @@
                  name
                  s
              in
-  
+
              let arg_name =
                OASISUtils.varname_of_string ~hyphen:'-' name
              in
-  
+
              let hlp =
                match short_descr_opt with
                  | Some txt -> txt ()
                  | None -> ""
              in
-  
+
              let arg_hlp =
                match def.arg_help with
                  | Some s -> s
                  | None   -> "str"
              in
-  
+
              let default_value =
                try
                  Printf.sprintf
@@ -2255,7 +3851,7 @@
                with Not_set _ ->
                  ""
              in
-  
+
              let args =
                match def.cli with
                  | CLINone ->
@@ -2270,282 +3866,46 @@
                      [
                        arg_concat "--with-" arg_name,
                        Arg.String var_set,
-                       Printf.sprintf (f_ "%s %s%s") arg_hlp hlp default_value
-                     ]
-                 | CLIEnable ->
-                     let dflt =
-                       if default_value = " [true]" then
-                         s_ " [default: enabled]"
-                       else
-                         s_ " [default: disabled]"
-                     in
-                       [
-                         arg_concat "--enable-" arg_name,
-                         Arg.Unit (fun () -> var_set "true"),
-                         Printf.sprintf (f_ " %s%s") hlp dflt;
-  
-                         arg_concat "--disable-" arg_name,
-                         Arg.Unit (fun () -> var_set "false"),
-                         Printf.sprintf (f_ " %s%s") hlp dflt
-                       ]
-                 | CLIUser lst ->
-                     lst
-             in
-               args :: acc)
-           []
-           schema)
-end
-
-module BaseExec = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/base/BaseExec.ml"
-  
-  open OASISGettext
-  open OASISUtils
-  open BaseMessage
-  
-  let run ?f_exit_code cmd args =
-    let cmdline =
-      String.concat " " (cmd :: args)
-    in
-      info (f_ "Running command '%s'") cmdline;
-      match f_exit_code, Sys.command cmdline with
-        | None, 0 -> ()
-        | None, i ->
-            failwithf
-              (f_ "Command '%s' terminated with error code %d")
-              cmdline i
-        | Some f, i ->
-            f i
-  
-  let run_read_output ?f_exit_code cmd args =
-    let fn =
-      Filename.temp_file "oasis-" ".txt"
-    in
-    let () =
-      try
-        run ?f_exit_code cmd (args @ [">"; Filename.quote fn])
-      with e ->
-        Sys.remove fn;
-        raise e
-    in
-    let chn =
-      open_in fn
-    in
-    let routput =
-      ref []
-    in
-      (
-        try
-          while true do
-            routput := (input_line chn) :: !routput
-          done
-        with End_of_file ->
-          ()
-      );
-      close_in chn;
-      Sys.remove fn;
-      List.rev !routput
-  
-  let run_read_one_line ?f_exit_code cmd args =
-    match run_read_output ?f_exit_code cmd args with
-      | [fst] ->
-          fst
-      | lst ->
-          failwithf
-            (f_ "Command return unexpected output %S")
-            (String.concat "\n" lst)
-end
-
-module BaseFileUtil = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/base/BaseFileUtil.ml"
-  
-  open OASISGettext
-  
-  let find_file paths exts =
-  
-    (* Cardinal product of two list *)
-    let ( * ) lst1 lst2 =
-      List.flatten
-        (List.map
-           (fun a ->
-              List.map
-                (fun b -> a,b)
-                lst2)
-           lst1)
-    in
-  
-    let rec combined_paths lst =
-      match lst with
-        | p1 :: p2 :: tl ->
-            let acc =
-              (List.map
-                 (fun (a,b) -> Filename.concat a b)
-                 (p1 * p2))
-            in
-              combined_paths (acc :: tl)
-        | [e] ->
-            e
-        | [] ->
-            []
-    in
-  
-    let alternatives =
-      List.map
-        (fun (p,e) ->
-           if String.length e > 0 && e.[0] <> '.' then
-             p ^ "." ^ e
-           else
-             p ^ e)
-        ((combined_paths paths) * exts)
-    in
-      List.find
-        OASISUtils.file_exists
-        alternatives
-  
-  let which prg =
-    let path_sep =
-      match Sys.os_type with
-        | "Win32" ->
-            ';'
-        | _ ->
-            ':'
-    in
-    let path_lst =
-      OASISUtils.split
-        path_sep
-        (Sys.getenv "PATH")
-    in
-    let exec_ext =
-      match Sys.os_type with
-        | "Win32" ->
-            ""
-            ::
-            (OASISUtils.split
-               path_sep
-               (Sys.getenv "PATHEXT"))
-        | _ ->
-            [""]
-    in
-      find_file [path_lst; [prg]] exec_ext
-  
-  (**/**)
-  let rec fix_dir dn =
-    (* Windows hack because Sys.file_exists "src\\" = false when
-     * Sys.file_exists "src" = true
-     *)
-    let ln =
-      String.length dn
-    in
-      if Sys.os_type = "Win32" && ln > 0 && dn.[ln - 1] = '\\' then
-        fix_dir (String.sub dn 0 (ln - 1))
-      else
-        dn
-  
-  let q = Filename.quote
-  (**/**)
-  
-  let cp src tgt =
-    BaseExec.run
-      (match Sys.os_type with
-       | "Win32" -> "copy"
-       | _ -> "cp")
-      [q src; q tgt]
-  
-  let mkdir tgt =
-    BaseExec.run
-      (match Sys.os_type with
-         | "Win32" -> "md"
-         | _ -> "mkdir")
-      [q tgt]
-  
-  let rec mkdir_parent f tgt =
-    let tgt =
-      fix_dir tgt
-    in
-      if OASISUtils.file_exists tgt then
-        begin
-          if not (Sys.is_directory tgt) then
-            OASISUtils.failwithf
-              (f_ "Cannot create directory '%s', a file of the same name already \
-                   exists")
-              tgt
-        end
-      else
-        begin
-          mkdir_parent f (Filename.dirname tgt);
-          if not (OASISUtils.file_exists tgt) then
-            begin
-              f tgt;
-              mkdir tgt
-            end
-        end
-  
-  let rmdir tgt =
-    if Sys.readdir tgt = [||] then
-      begin
-        match Sys.os_type with
-          | "Win32" ->
-              BaseExec.run "rd" [q tgt]
-          | _ ->
-              BaseExec.run "rm" ["-r"; q tgt]
-      end
-  
-  let glob fn =
-   let basename =
-     Filename.basename fn
-   in
-     if String.length basename >= 2 &&
-        basename.[0] = '*' &&
-        basename.[1] = '.' then
-       begin
-         let ext_len =
-           (String.length basename) - 2
-         in
-         let ext =
-           String.sub basename 2 ext_len
-         in
-         let dirname =
-           Filename.dirname fn
-         in
-           Array.fold_left
-             (fun acc fn ->
-                try
-                  let fn_ext =
-                    String.sub
-                      fn
-                      ((String.length fn) - ext_len)
-                      ext_len
-                  in
-                    if fn_ext = ext then
-                      (Filename.concat dirname fn) :: acc
-                    else
-                      acc
-                with Invalid_argument _ ->
-                  acc)
-             []
-             (Sys.readdir dirname)
-       end
-     else
-       begin
-         if OASISUtils.file_exists fn then
-           [fn]
-         else
+                       Printf.sprintf (f_ "%s %s%s") arg_hlp hlp default_value
+                     ]
+                 | CLIEnable ->
+                     let dflt =
+                       if default_value = " [true]" then
+                         s_ " [default: enabled]"
+                       else
+                         s_ " [default: disabled]"
+                     in
+                       [
+                         arg_concat "--enable-" arg_name,
+                         Arg.Unit (fun () -> var_set "true"),
+                         Printf.sprintf (f_ " %s%s") hlp dflt;
+
+                         arg_concat "--disable-" arg_name,
+                         Arg.Unit (fun () -> var_set "false"),
+                         Printf.sprintf (f_ " %s%s") hlp dflt
+                       ]
+                 | CLIUser lst ->
+                     lst
+             in
+               args :: acc)
            []
-       end
+           schema)
 end
 
 module BaseArgExt = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/base/BaseArgExt.ml"
-  
+(* # 22 "src/base/BaseArgExt.ml" *)
+
+
   open OASISUtils
   open OASISGettext
-  
+
+
   let parse argv args =
       (* Simulate command line for Arg *)
       let current =
         ref 0
       in
-  
+
         try
           Arg.parse_argv
             ~current:current
@@ -2563,13 +3923,15 @@
 end
 
 module BaseCheck = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/base/BaseCheck.ml"
-  
+(* # 22 "src/base/BaseCheck.ml" *)
+
+
   open BaseEnv
   open BaseMessage
   open OASISUtils
   open OASISGettext
-  
+
+
   let prog_best prg prg_lst =
     var_redefine
       prg
@@ -2582,7 +3944,7 @@
                       res
                   | None ->
                       try
-                        Some (BaseFileUtil.which e)
+                        Some (OASISFileUtil.which ~ctxt:!BaseContext.default e)
                       with Not_found ->
                         None)
              None
@@ -2591,16 +3953,20 @@
            match alternate with
              | Some prg -> prg
              | None -> raise Not_found)
-  
+
+
   let prog prg =
     prog_best prg [prg]
-  
+
+
   let prog_opt prg =
     prog_best prg [prg^".opt"; prg]
-  
+
+
   let ocamlfind =
     prog "ocamlfind"
-  
+
+
   let version
         var_prefix
         cmp
@@ -2641,12 +4007,14 @@
                  (OASISVersion.string_of_comparator cmp)
                  version_str)
         ()
-  
+
+
   let package_version pkg =
-    BaseExec.run_read_one_line
+    OASISExec.run_read_one_line ~ctxt:!BaseContext.default
       (ocamlfind ())
       ["query"; "-format"; "%v"; pkg]
-  
+
+
   let package ?version_comparator pkg () =
     let var =
       OASISUtils.varname_concat
@@ -2655,9 +4023,11 @@
     in
     let findlib_dir pkg =
       let dir =
-        BaseExec.run_read_one_line
+        OASISHostPath.of_unix (
+          OASISHostPath.ocamlfind_unquote (
+        OASISExec.run_read_one_line ~ctxt:!BaseContext.default
           (ocamlfind ())
-          ["query"; "-format"; "%d"; pkg]
+              ["query"; "-format"; "%d"; pkg] ) )
       in
         if Sys.file_exists dir && Sys.is_directory dir then
           dir
@@ -2689,18 +4059,21 @@
 end
 
 module BaseOCamlcConfig = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/base/BaseOCamlcConfig.ml"
-  
-  
+(* # 22 "src/base/BaseOCamlcConfig.ml" *)
+
+
   open BaseEnv
   open OASISUtils
   open OASISGettext
-  
+
+
   module SMap = Map.Make(String)
-  
+
+
   let ocamlc =
     BaseCheck.prog_opt "ocamlc"
-  
+
+
   let ocamlc_config_map =
     (* Map name to value for ocamlc -config output
        (name ^": "^value)
@@ -2745,14 +4118,15 @@
         | [] ->
             mp
     in
-  
-    let cache = 
+
+    let cache =
       lazy
         (var_protect
            (Marshal.to_string
               (split_field
                  SMap.empty
-                 (BaseExec.run_read_output
+                 (OASISExec.run_read_output
+                    ~ctxt:!BaseContext.default
                     (ocamlc ()) ["-config"]))
               []))
     in
@@ -2763,7 +4137,8 @@
         (fun () ->
            (* TODO: update if ocamlc change !!! *)
            Lazy.force cache)
-  
+
+
   let var_define nm =
     (* Extract data from ocamlc -config *)
     let avlbl_config_get () =
@@ -2772,16 +4147,19 @@
         0
     in
     let chop_version_suffix s =
-      try 
+      try
         String.sub s 0 (String.index s '+')
-      with _ -> 
+      with _ ->
         s
      in
-  
+
     let nm_config, value_config =
       match nm with
-        | "ocaml_version" -> 
+        | "ocaml_version" ->
             "version", chop_version_suffix
+        | "standard_library"
+        | "standard_library_default" ->
+            nm, ( fun x -> OASISHostPath.of_unix x)
         | _ -> nm, (fun x -> x)
     in
       var_redefine
@@ -2800,58 +4178,83 @@
                (f_ "Cannot find field '%s' in '%s -config' output")
                nm
                (ocamlc ()))
-  
+
 end
 
 module BaseStandardVar = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/base/BaseStandardVar.ml"
-  
-  
+(* # 22 "src/base/BaseStandardVar.ml" *)
+
+
   open OASISGettext
   open OASISTypes
   open OASISExpr
   open BaseCheck
   open BaseEnv
-  
+
+
   let ocamlfind  = BaseCheck.ocamlfind
   let ocamlc     = BaseOCamlcConfig.ocamlc
   let ocamlopt   = prog_opt "ocamlopt"
   let ocamlbuild = prog "ocamlbuild"
-  
-  
+
+
   (**/**)
   let rpkg =
     ref None
-  
+
+
   let pkg_get () =
     match !rpkg with
       | Some pkg -> pkg
       | None -> failwith (s_ "OASIS Package is not set")
+
+
+  let var_cond = ref []
+
+
+  let var_define_cond ~since_version f dflt =
+    let holder = ref (fun () -> dflt) in
+    let since_version =
+      OASISVersion.VGreaterEqual (OASISVersion.version_of_string since_version)
+    in
+      var_cond :=
+      (fun ver ->
+         if OASISVersion.comparator_apply ver since_version then
+           holder := f ()) :: !var_cond;
+      fun () -> !holder ()
+
+
   (**/**)
-  
+
+
   let pkg_name =
     var_define
       ~short_desc:(fun () -> s_ "Package name")
       "pkg_name"
       (fun () -> (pkg_get ()).name)
-  
+
+
   let pkg_version =
     var_define
       ~short_desc:(fun () -> s_ "Package version")
       "pkg_version"
       (fun () ->
          (OASISVersion.string_of_version (pkg_get ()).version))
-  
+
+
   let c = BaseOCamlcConfig.var_define
-  
+
+
   let os_type        = c "os_type"
   let system         = c "system"
   let architecture   = c "architecture"
   let ccomp_type     = c "ccomp_type"
   let ocaml_version  = c "ocaml_version"
-  
+
+
   (* TODO: Check standard variable presence at runtime *)
-  
+
+
   let standard_library_default = c "standard_library_default"
   let standard_library         = c "standard_library"
   let standard_runtime         = c "standard_runtime"
@@ -2864,8 +4267,28 @@
   let ext_dll                  = c "ext_dll"
   let default_executable_name  = c "default_executable_name"
   let systhread_supported      = c "systhread_supported"
-  
-  
+
+
+  let flexlink =
+    BaseCheck.prog "flexlink"
+
+
+  let flexdll_version =
+    var_define
+      ~short_desc:(fun () -> "FlexDLL version (Win32)")
+      "flexdll_version"
+      (fun () ->
+         let lst =
+           OASISExec.run_read_output ~ctxt:!BaseContext.default
+             (flexlink ()) ["-help"]
+         in
+           match lst with
+             | line :: _ ->
+                 Scanf.sscanf line "FlexDLL version %s" (fun ver -> ver)
+             | [] ->
+                 raise Not_found)
+
+
   (**/**)
   let p name hlp dflt =
     var_define
@@ -2874,120 +4297,181 @@
       ~arg_help:"dir"
       name
       dflt
-  
+
+
   let (/) a b =
-    if os_type () = Sys.os_type then
+    let os = os_type () in
+      if os = Sys.os_type then
+        if Sys.os_type = "Win32" && OASISHostPath.use_bash () then
+          OASISUnixPath.concat a b
+        else
       Filename.concat a b
-    else if os_type () = "Unix" then
-      BaseFilePath.Unix.concat a b
+      else if os = "Unix" then
+      OASISUnixPath.concat a b
     else
       OASISUtils.failwithf (f_ "Cannot handle os_type %s filename concat")
         (os_type ())
   (**/**)
-  
+
+  let bash_cmd =
+    var_define
+      ~short_desc:(fun () -> s_ "Enforced bash shell:")
+      ~cli:CLIAuto
+      ~arg_help:"program"
+      "use_bash"
+      (fun () -> "dash.exe")
+
+
   let prefix =
     p "prefix"
       (fun () -> s_ "Install architecture-independent files dir")
       (fun () ->
          match os_type () with
            | "Win32" ->
+               let getenv w =
+                 try
+                   Some(Sys.getenv w)
+                 with
+                   | Not_found -> None
+               in
+               let s =
+                 if Sys.word_size = 64 then
+                   getenv "ProgramW6432"
+                 else
+                   None
+               in
+               let s =
+                 if s = None then
+                   getenv "PROGRAMFILES"
+                 else
+                   s
+               in
                let program_files =
-                 Sys.getenv "PROGRAMFILES"
+                 match s with
+                   | None -> "C:\\Program Files"
+                   | Some x -> x
                in
-                 program_files/(pkg_name ())
+                 OASISHostPath.of_unix (program_files/(pkg_name ()))
            | _ ->
                "/usr/local")
-  
+
+
   let exec_prefix =
     p "exec_prefix"
       (fun () -> s_ "Install architecture-dependent files in dir")
       (fun () -> "$prefix")
-  
+
+
   let bindir =
     p "bindir"
       (fun () -> s_ "User executables")
       (fun () -> "$exec_prefix"/"bin")
-  
+
+
   let sbindir =
     p "sbindir"
       (fun () -> s_ "System admin executables")
       (fun () -> "$exec_prefix"/"sbin")
-  
+
+
   let libexecdir =
     p "libexecdir"
       (fun () -> s_ "Program executables")
       (fun () -> "$exec_prefix"/"libexec")
-  
+
+
   let sysconfdir =
     p "sysconfdir"
       (fun () -> s_ "Read-only single-machine data")
       (fun () -> "$prefix"/"etc")
-  
+
+
   let sharedstatedir =
     p "sharedstatedir"
       (fun () -> s_ "Modifiable architecture-independent data")
       (fun () -> "$prefix"/"com")
-  
+
+
   let localstatedir =
     p "localstatedir"
       (fun () -> s_ "Modifiable single-machine data")
       (fun () -> "$prefix"/"var")
-  
+
+
   let libdir =
     p "libdir"
       (fun () -> s_ "Object code libraries")
       (fun () -> "$exec_prefix"/"lib")
-  
+
+
   let datarootdir =
     p "datarootdir"
       (fun () -> s_ "Read-only arch-independent data root")
       (fun () -> "$prefix"/"share")
-  
+
+
   let datadir =
     p "datadir"
       (fun () -> s_ "Read-only architecture-independent data")
       (fun () -> "$datarootdir")
-  
+
+
   let infodir =
     p "infodir"
       (fun () -> s_ "Info documentation")
       (fun () -> "$datarootdir"/"info")
-  
+
+
   let localedir =
     p "localedir"
       (fun () -> s_ "Locale-dependent data")
       (fun () -> "$datarootdir"/"locale")
-  
+
+
   let mandir =
     p "mandir"
       (fun () -> s_ "Man documentation")
       (fun () -> "$datarootdir"/"man")
-  
+
+
   let docdir =
     p "docdir"
       (fun () -> s_ "Documentation root")
-      (fun () -> "$datarootdir"/"doc"/"$pkg_name")
-  
+      (fun () ->
+        (* TODO: (Windows only?) "$pkg_name" is not always substituted
+         * (at least if datarootdir contains spaces or other garbage)
+         * I haven't looked up why.
+         *)
+        match os_type () with
+          | "Win32" -> "$datarootdir"/"doc"/ ( pkg_name () )
+          | _ -> "$datarootdir"/"doc"/"$pkg_name"
+      )
+
+
   let htmldir =
     p "htmldir"
       (fun () -> s_ "HTML documentation")
       (fun () -> "$docdir")
-  
+
+
   let dvidir =
     p "dvidir"
       (fun () -> s_ "DVI documentation")
       (fun () -> "$docdir")
-  
+
+
   let pdfdir =
     p "pdfdir"
       (fun () -> s_ "PDF documentation")
       (fun () -> "$docdir")
-  
+
+
   let psdir =
     p "psdir"
       (fun () -> s_ "PS documentation")
       (fun () -> "$docdir")
-  
+
+
   let destdir =
     p "destdir"
       (fun () -> s_ "Prepend a path when installing package")
@@ -2996,83 +4480,101 @@
            (PropList.Not_set
               ("destdir",
                Some (s_ "undefined by construct"))))
-  
+
+
   let findlib_version =
     var_define
       "findlib_version"
       (fun () ->
          BaseCheck.package_version "findlib")
-  
+
+
   let is_native =
     var_define
       "is_native"
       (fun () ->
          try
-           let _s : string =
+           let _s: string =
              ocamlopt ()
            in
              "true"
          with PropList.Not_set _ ->
-           let _s : string =
+           let _s: string =
              ocamlc ()
            in
              "false")
-  
+
+
   let ext_program =
     var_define
       "suffix_program"
       (fun () ->
          match os_type () with
-           | "Win32" -> ".exe"
+           | "Win32" | "Cygwin" -> ".exe"
            | _ -> "")
-  
+
+
   let rm =
     var_define
       ~short_desc:(fun () -> s_ "Remove a file.")
       "rm"
       (fun () ->
-         match os_type () with
-           | "Win32" -> "del"
-           | _ -> "rm -f")
-  
+         if not (OASISHostPath.use_bash ()) && os_type () = "Win32" then
+           "del"
+         else
+           "rm -f" )
+
+
   let rmdir =
     var_define
       ~short_desc:(fun () -> s_ "Remove a directory.")
       "rmdir"
       (fun () ->
-         match os_type () with
-           | "Win32" -> "rd"
-           | _ -> "rm -rf")
-  
+         if not (OASISHostPath.use_bash ()) && os_type () = "Win32" then
+           "rd"
+         else
+           "rm -rf")
+
+
   let debug =
     var_define
       ~short_desc:(fun () -> s_ "Turn ocaml debug flag on")
       ~cli:CLIEnable
       "debug"
       (fun () -> "true")
-  
+
+
   let profile =
     var_define
       ~short_desc:(fun () -> s_ "Turn ocaml profile flag on")
       ~cli:CLIEnable
       "profile"
       (fun () -> "false")
-  
+
+
   let tests =
-    var_define
-      ~short_desc:(fun () ->
-                     s_ "Compile tests executable and library and run them")
-      ~cli:CLIEnable
-      "tests"
-      (fun () -> "false")
-  
+    var_define_cond ~since_version:"0.3"
+      (fun () ->
+         var_define
+           ~short_desc:(fun () ->
+                          s_ "Compile tests executable and library and run them")
+           ~cli:CLIEnable
+           "tests"
+           (fun () -> "false"))
+      "true"
+
+
   let docs =
-    var_define
-      ~short_desc:(fun () -> s_ "Create documentations")
-      ~cli:CLIEnable
-      "docs"
-      (fun () -> "true")
-  
+    var_define_cond ~since_version:"0.3"
+      (fun () ->
+         var_define
+           ~short_desc:(fun () -> s_ "Create documentations")
+           ~cli:CLIEnable
+           "docs"
+           (fun () -> "true"))
+      "true"
+
+
   let native_dynlink =
     var_define
       ~short_desc:(fun () -> s_ "Compiler support generation of .cmxs.")
@@ -3080,47 +4582,94 @@
       "native_dynlink"
       (fun () ->
          let res =
-           if bool_of_string (is_native ()) then
-             begin
-               let ocamlfind = ocamlfind () in
-                 try
-                   let fn =
-                     BaseExec.run_read_one_line
-                      ocamlfind
-                      ["query"; "-predicates"; "native"; "dynlink";
-                       "-format"; "%d/%a"]
-                   in
-                     Sys.file_exists fn
-                 with _ ->
-                   false
-             end
-           else
-             false
+           let ocaml_lt_312 () =
+             OASISVersion.comparator_apply
+               (OASISVersion.version_of_string (ocaml_version ()))
+               (OASISVersion.VLesser
+                  (OASISVersion.version_of_string "3.12.0"))
+           in
+           let flexdll_lt_030 () =
+             OASISVersion.comparator_apply
+               (OASISVersion.version_of_string (flexdll_version ()))
+               (OASISVersion.VLesser
+                  (OASISVersion.version_of_string "0.30"))
+           in
+           let has_native_dynlink =
+             let ocamlfind = ocamlfind () in
+               try
+                 (* -format %d/%a doesn't work, because ocamlfind quotes %d
+                  * and %a separatly *)
+                 let fn1 =
+                   OASISHostPath.ocamlfind_unquote (
+                     OASISExec.run_read_one_line
+                       ~ctxt:!BaseContext.default
+                       ocamlfind
+                       ["query"; "-predicates"; "native"; "dynlink";
+                        "-format"; "%d"] )
+                 in
+                 let fn2 =
+                   OASISHostPath.ocamlfind_unquote (
+                   OASISExec.run_read_one_line
+                     ~ctxt:!BaseContext.default
+                     ocamlfind
+                     ["query"; "-predicates"; "native"; "dynlink";
+                        "-format"; "%a"] )
+                 in
+                   if fn1 <> "" && fn2 <> "" &&
+                     Sys.file_exists (Filename.concat fn1 fn2) then
+                     true
+                   else
+                     false
+               with _ ->
+                 false
+           in
+             if not has_native_dynlink then
+               false
+             else if ocaml_lt_312 () then
+               false
+             else if (os_type () = "Win32" || os_type () = "Cygwin")
+                     && flexdll_lt_030 () then
+               begin
+                 BaseMessage.warning
+                   (f_ ".cmxs generation disabled because FlexDLL needs to be \
+                        at least 0.30. Please upgrade FlexDLL from %s to 0.30.")
+                   (flexdll_version ());
+                 false
+               end
+             else
+               true
          in
            string_of_bool res)
-  
+
+
   let init pkg =
-    rpkg := Some pkg
-  
+    rpkg := Some pkg;
+    List.iter (fun f -> f pkg.oasis_version) !var_cond
+
+  let () =
+    OASISHostPath.bash_cmd := bash_cmd
 end
 
 module BaseFileAB = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/base/BaseFileAB.ml"
-  
+(* # 22 "src/base/BaseFileAB.ml" *)
+
+
   open BaseEnv
   open OASISGettext
   open BaseMessage
-  
+
+
   let to_filename fn =
     let fn =
-      BaseFilePath.of_unix fn
+      OASISHostPath.of_unix fn
     in
       if not (Filename.check_suffix fn ".ab") then
         warning
           (f_ "File '%s' doesn't have '.ab' extension")
           fn;
       Filename.chop_extension fn
-  
+
+
   let replace fn_lst =
     let buff =
       Buffer.create 13
@@ -3128,7 +4677,7 @@
       List.iter
         (fun fn ->
            let fn =
-             BaseFilePath.of_unix fn
+             OASISHostPath.of_unix fn
            in
            let chn_in =
              open_in fn
@@ -3153,15 +4702,18 @@
 end
 
 module BaseLog = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/base/BaseLog.ml"
-  
+(* # 22 "src/base/BaseLog.ml" *)
+
+
   open OASISUtils
-  
+
+
   let default_filename =
     Filename.concat
       (Filename.dirname BaseEnv.default_filename)
       "setup.log"
-  
+
+
   module SetTupleString =
     Set.Make
       (struct
@@ -3171,7 +4723,8 @@
              | 0 -> String.compare s12 s22
              | n -> n
        end)
-  
+
+
   let load () =
     if Sys.file_exists default_filename then
       begin
@@ -3220,14 +4773,16 @@
       begin
         []
       end
-  
+
+
   let register event data =
     let chn_out =
       open_out_gen [Open_append; Open_creat; Open_text] 0o644 default_filename
     in
       Printf.fprintf chn_out "%S %S\n" event data;
       close_out chn_out
-  
+
+
   let unregister event data =
     if Sys.file_exists default_filename then
       begin
@@ -3252,7 +4807,8 @@
           if not !write_something then
             Sys.remove default_filename
       end
-  
+
+
   let filter events =
     let st_events =
       List.fold_left
@@ -3264,7 +4820,8 @@
       List.filter
         (fun (e, _) -> SetString.mem e st_events)
         (load ())
-  
+
+
   let exists event data =
     List.exists
       (fun v -> (event, data) = v)
@@ -3272,31 +4829,38 @@
 end
 
 module BaseBuilt = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/base/BaseBuilt.ml"
-  
+(* # 22 "src/base/BaseBuilt.ml" *)
+
+
   open OASISTypes
   open OASISGettext
   open BaseStandardVar
   open BaseMessage
-  
+
+
   type t =
     | BExec    (* Executable *)
     | BExecLib (* Library coming with executable *)
     | BLib     (* Library *)
+    | BObj     (* Library *)
     | BDoc     (* Document *)
-  
+
+
   let to_log_event_file t nm =
     "built_"^
     (match t with
        | BExec -> "exec"
        | BExecLib -> "exec_lib"
        | BLib -> "lib"
+       | BObj -> "obj"
        | BDoc -> "doc")^
     "_"^nm
-  
+
+
   let to_log_event_done t nm =
     "is_"^(to_log_event_file t nm)
-  
+
+
   let register t nm lst =
     BaseLog.register
       (to_log_event_done t nm)
@@ -3306,7 +4870,7 @@
          let registered =
            List.fold_left
              (fun registered fn ->
-                if OASISUtils.file_exists fn then
+                if OASISFileUtil.file_exists_case fn then
                   begin
                     BaseLog.register
                       (to_log_event_file t nm)
@@ -3326,7 +4890,8 @@
                (f_ "Cannot find an existing alternative files among: %s")
                (String.concat (s_ ", ") alt))
       lst
-  
+
+
   let unregister t nm =
     List.iter
       (fun (e, d) ->
@@ -3334,11 +4899,12 @@
       (BaseLog.filter
          [to_log_event_file t nm;
           to_log_event_done t nm])
-  
+
+
   let fold t nm f acc =
     List.fold_left
       (fun acc (_, fn) ->
-         if OASISUtils.file_exists fn then
+         if OASISFileUtil.file_exists_case fn then
            begin
              f acc fn
            end
@@ -3354,6 +4920,8 @@
                          (f_ "executable %s")
                      | BLib ->
                          (f_ "library %s")
+                     | BObj ->
+                         (f_ "object %s")
                      | BDoc ->
                          (f_ "documentation %s"))
                   nm);
@@ -3362,7 +4930,8 @@
       acc
       (BaseLog.filter
          [to_log_event_file t nm])
-  
+
+
   let is_built t nm =
     List.fold_left
       (fun is_built (_, d) ->
@@ -3373,7 +4942,8 @@
       false
       (BaseLog.filter
          [to_log_event_done t nm])
-  
+
+
   let of_executable ffn (cs, bs, exec) =
     let unix_exec_is, unix_dll_opt =
       OASISExecutable.unix_exec_is
@@ -3396,13 +4966,14 @@
       evs,
       unix_exec_is,
       unix_dll_opt
-  
+
+
   let of_library ffn (cs, bs, lib) =
     let unix_lst =
       OASISLibrary.generated_unix_files
         ~ctxt:!BaseContext.default
         ~source_file_exists:(fun fn ->
-           OASISUtils.file_exists (BaseFilePath.of_unix fn))
+           OASISFileUtil.file_exists_case (OASISHostPath.of_unix fn))
         ~is_native:(bool_of_string (is_native ()))
         ~has_native_dynlink:(bool_of_string (native_dynlink ()))
         ~ext_lib:(ext_lib ())
@@ -3415,24 +4986,44 @@
        List.map (List.map ffn) unix_lst]
     in
       evs, unix_lst
-  
+
+
+  let of_object ffn (cs, bs, obj) =
+    let unix_lst =
+      OASISObject.generated_unix_files
+        ~ctxt:!BaseContext.default
+        ~source_file_exists:(fun fn ->
+           OASISFileUtil.file_exists_case (OASISHostPath.of_unix fn))
+        ~is_native:(bool_of_string (is_native ()))
+        (cs, bs, obj)
+    in
+    let evs =
+      [BObj,
+       cs.cs_name,
+       List.map (List.map ffn) unix_lst]
+    in
+      evs, unix_lst
+
 end
 
 module BaseCustom = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/base/BaseCustom.ml"
-  
+(* # 22 "src/base/BaseCustom.ml" *)
+
+
   open BaseEnv
   open BaseMessage
   open OASISTypes
   open OASISGettext
-  
+
+
   let run cmd args extra_args =
-    BaseExec.run
+    OASISExec.run ~ctxt:!BaseContext.default ~quote:false
       (var_expand cmd)
       (List.map
-         var_expand
+         (var_expand ~quoted:true)
          (args @ (Array.to_list extra_args)))
-  
+
+
   let hook ?(failsafe=false) cstm f e =
     let optional_command lst =
       let printer =
@@ -3469,15 +5060,18 @@
 end
 
 module BaseDynVar = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/base/BaseDynVar.ml"
-  
-  
+(* # 22 "src/base/BaseDynVar.ml" *)
+
+
   open OASISTypes
   open OASISGettext
   open BaseEnv
   open BaseBuilt
-  
+
+
   let init pkg =
+    (* TODO: disambiguate exec vs other variable by adding exec_VARNAME. *)
+    (* TODO: provide compile option for library libary_byte_args_VARNAME... *)
     List.iter
       (function
          | Executable (cs, bs, exec) ->
@@ -3490,7 +5084,7 @@
                                    Printf.sprintf
                                      (f_ "Filename of executable '%s'")
                                      cs.cs_name)
-                    cs.cs_name
+                    (OASISUtils.varname_of_string cs.cs_name)
                     (fun () ->
                        let fn_opt =
                          fold
@@ -3507,23 +5101,25 @@
                                      Some (Printf.sprintf
                                              (f_ "Executable '%s' not yet built.")
                                              cs.cs_name)))))
-  
-         | Library _ | Flag _ | Test _ | SrcRepo _ | Doc _ ->
+
+         | Library _ | Object _ | Flag _ | Test _ | SrcRepo _ | Doc _ ->
              ())
       pkg.sections
 end
 
 module BaseTest = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/base/BaseTest.ml"
-  
+(* # 22 "src/base/BaseTest.ml" *)
+
+
   open BaseEnv
   open BaseMessage
   open OASISTypes
   open OASISExpr
   open OASISGettext
-  
+
+
   let test lst pkg extra_args =
-  
+
     let one_test (failure, n) (test_plugin, cs, test) =
       if var_choose
            ~name:(Printf.sprintf
@@ -3547,7 +5143,7 @@
                   in
                     chdir dir;
                     fun () -> chdir cwd
-  
+
               | None ->
                   fun () -> ()
           in
@@ -3572,7 +5168,7 @@
           (failure, n)
         end
     in
-    let (failed, n) =
+    let failed, n =
       List.fold_left
         one_test
         (0.0, 0)
@@ -3592,19 +5188,29 @@
       if failure_percent > 0.0 then
         failwith msg
       else
-        info "%s" msg
+        info "%s" msg;
+
+      (* Possible explanation why the tests where not run. *)
+      if OASISFeatures.package_test OASISFeatures.flag_tests pkg &&
+         not (bool_of_string (BaseStandardVar.tests ())) &&
+         lst <> [] then
+        BaseMessage.warning
+          "Tests are turned off, consider enabling with \
+           'ocaml setup.ml -configure --enable-tests'"
 end
 
 module BaseDoc = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/base/BaseDoc.ml"
-  
+(* # 22 "src/base/BaseDoc.ml" *)
+
+
   open BaseEnv
   open BaseMessage
   open OASISTypes
   open OASISGettext
-  
+
+
   let doc lst pkg extra_args =
-  
+
     let one_doc (doc_plugin, cs, doc) =
       if var_choose
            ~name:(Printf.sprintf
@@ -3620,27 +5226,35 @@
             extra_args
         end
     in
-      List.iter
-        one_doc
-        lst
+      List.iter one_doc lst;
+
+      if OASISFeatures.package_test OASISFeatures.flag_docs pkg &&
+         not (bool_of_string (BaseStandardVar.docs ())) &&
+         lst <> [] then
+        BaseMessage.warning
+          "Docs are turned off, consider enabling with \
+           'ocaml setup.ml -configure --enable-docs'"
 end
 
 module BaseSetup = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/base/BaseSetup.ml"
-  
+(* # 22 "src/base/BaseSetup.ml" *)
+
   open BaseEnv
   open BaseMessage
   open OASISTypes
   open OASISSection
   open OASISGettext
   open OASISUtils
-  
+
+
   type std_args_fun =
       package -> string array -> unit
-  
+
+
   type ('a, 'b) section_args_fun =
       name * (package -> (common_section * 'a) -> string array -> 'b)
-  
+
+
   type t =
       {
         configure:        std_args_fun;
@@ -3661,8 +5275,10 @@
         oasis_digest:     Digest.t option;
         oasis_exec:       string option;
         oasis_setup_args: string list;
+        setup_update:     bool;
       }
-  
+
+
   (* Associate a plugin function with data from package *)
   let join_plugin_sections filter_map lst =
     List.rev
@@ -3675,7 +5291,8 @@
                   acc)
          []
          lst)
-  
+
+
   (* Search for plugin data associated with a section name *)
   let lookup_plugin_section plugin action nm lst =
     try
@@ -3686,12 +5303,31 @@
         plugin
         nm
         action
-  
+
+
   let configure t args =
     (* Run configure *)
+
+    (* use-bash is an exception. It's already needed to run the
+       pre-configure script. *)
+    let rec f = function
+      | [] ->
+        begin
+          try
+            let x = Sys.getenv "USE_BASH" in
+              OASISHostPath.bash_cmd := (fun () -> x);
+          with
+            _ -> ()
+        end
+      | "--use-bash"::x::_ ->
+          OASISHostPath.bash_cmd := (fun () -> x);
+      | _::tl -> f tl
+    in
+      f (Array.to_list args);
     BaseCustom.hook
       t.package.conf_custom
-      (fun () -> 
+      (fun () ->
+           OASISHostPath.bash_cmd := BaseStandardVar.bash_cmd;
          (* Reload if preconf has changed it *)
          begin
            try
@@ -3700,78 +5336,72 @@
            with _ ->
              ()
          end;
-  
+
          (* Run plugin's configure *)
          t.configure t.package args;
-  
+
          (* Dump to allow postconf to change it *)
          dump ())
       ();
-  
+
     (* Reload environment *)
     unload ();
     load ();
-  
+
     (* Save environment *)
     print ();
-  
+
     (* Replace data in file *)
     BaseFileAB.replace t.package.files_ab
-  
+
+
   let build t args =
     BaseCustom.hook
       t.package.build_custom
       (t.build t.package)
       args
-  
+
+
   let doc t args =
-    if bool_of_string (BaseStandardVar.docs ()) then
-      BaseDoc.doc
-        (join_plugin_sections
-           (function
-              | Doc (cs, e) ->
-                  Some
-                    (lookup_plugin_section
-                       "documentation"
-                       (s_ "build")
-                       cs.cs_name
-                       t.doc,
-                     cs,
-                     e)
-              | _ ->
-                  None)
-           t.package.sections)
-        t.package
-        args
-    else
-      BaseMessage.warning
-        "Docs are turned off, consider enabling with \
-         'ocaml setup.ml -configure --enable-docs'"
-  
+    BaseDoc.doc
+      (join_plugin_sections
+         (function
+            | Doc (cs, e) ->
+                Some
+                  (lookup_plugin_section
+                     "documentation"
+                     (s_ "build")
+                     cs.cs_name
+                     t.doc,
+                   cs,
+                   e)
+            | _ ->
+                None)
+         t.package.sections)
+      t.package
+      args
+
+
   let test t args =
-    if bool_of_string (BaseStandardVar.tests ()) then
-      BaseTest.test
-        (join_plugin_sections
-           (function
-              | Test (cs, e) ->
-                  Some
-                    (lookup_plugin_section
-                       "test"
-                       (s_ "run")
-                       cs.cs_name
-                       t.test,
-                     cs,
-                     e)
-              | _ ->
-                  None)
-           t.package.sections)
-        t.package
-        args
-    else
-      BaseMessage.warning
-        "Tests are turned off, consider enabling with \
-         'ocaml setup.ml -configure --enable-tests'"
-  
+    BaseTest.test
+      (join_plugin_sections
+         (function
+            | Test (cs, e) ->
+                Some
+                  (lookup_plugin_section
+                     "test"
+                     (s_ "run")
+                     cs.cs_name
+                     t.test,
+                   cs,
+                   e)
+            | _ ->
+                None)
+         t.package.sections)
+      t.package
+      args
+
+
   let all t args =
     let rno_doc =
       ref false
@@ -3779,6 +5409,9 @@
     let rno_test =
       ref false
     in
+    let arg_rest =
+      ref []
+    in
       Arg.parse_argv
         ~current:(ref 0)
         (Array.of_list
@@ -3788,23 +5421,27 @@
           "-no-doc",
           Arg.Set rno_doc,
           s_ "Don't run doc target";
-  
+
           "-no-test",
           Arg.Set rno_test,
           s_ "Don't run test target";
+
+          "--",
+          Arg.Rest (fun arg -> arg_rest := arg :: !arg_rest),
+          s_ "All arguments for configure.";
         ]
         (failwithf (f_ "Don't know what to do with '%s'"))
         "";
-  
+
       info "Running configure step";
-      configure t [||];
-  
+      configure t (Array.of_list (List.rev !arg_rest));
+
       info "Running build step";
       build     t [||];
-  
+
       (* Load setup.log dynamic variables *)
       BaseDynVar.init t.package;
-  
+
       if not !rno_doc then
         begin
           info "Running doc step";
@@ -3814,7 +5451,7 @@
         begin
           info "Skipping doc step"
         end;
-  
+
       if not !rno_test then
         begin
           info "Running test step";
@@ -3824,23 +5461,27 @@
         begin
           info "Skipping test step"
         end
-  
+
+
   let install t args =
     BaseCustom.hook
       t.package.install_custom
       (t.install t.package)
       args
-  
+
+
   let uninstall t args =
     BaseCustom.hook
       t.package.uninstall_custom
       (t.uninstall t.package)
       args
-  
+
+
   let reinstall t args =
     uninstall t args;
     install t args
-  
+
+
   let clean, distclean =
     let failsafe f a =
       try
@@ -3852,7 +5493,7 @@
              | Failure msg -> msg
              | e -> Printexc.to_string e)
     in
-  
+
     let generic_clean t cstm mains docs tests args =
       BaseCustom.hook
         ~failsafe:true
@@ -3882,6 +5523,7 @@
                         (f t.package (cs, doc))
                         args
                 | Library _
+                | Object _
                 | Executable _
                 | Flag _
                 | SrcRepo _ ->
@@ -3896,7 +5538,7 @@
              mains)
         ()
     in
-  
+
     let clean t args =
       generic_clean
         t
@@ -3906,11 +5548,20 @@
         t.clean_test
         args
     in
-  
+
     let distclean t args =
       (* Call clean *)
       clean t args;
-  
+
+      (* Call distclean code *)
+      generic_clean
+        t
+        t.package.distclean_custom
+        t.distclean
+        t.distclean_doc
+        t.distclean_test
+        args;
+
       (* Remove generated file *)
       List.iter
         (fun fn ->
@@ -3923,35 +5574,32 @@
          ::
          BaseLog.default_filename
          ::
-         (List.rev_map BaseFileAB.to_filename t.package.files_ab));
-  
-      (* Call distclean code *)
-      generic_clean
-        t
-        t.package.distclean_custom
-        t.distclean
-        t.distclean_doc
-        t.distclean_test
-        args
+         (List.rev_map BaseFileAB.to_filename t.package.files_ab))
     in
-  
+
       clean, distclean
-  
+
+
   let version t _ =
     print_endline t.oasis_version
-  
+
+
   let update_setup_ml, no_update_setup_ml_cli =
     let b = ref true in
       b,
       ("-no-update-setup-ml",
        Arg.Clear b,
        s_ " Don't try to update setup.ml, even if _oasis has changed.")
-  
+
+
+  let default_oasis_fn = "_oasis"
+
+
   let update_setup_ml t =
     let oasis_fn =
       match t.oasis_fn with
         | Some fn -> fn
-        | None -> "_oasis"
+        | None -> default_oasis_fn
     in
     let oasis_exec =
       match t.oasis_exec with
@@ -3981,7 +5629,8 @@
     let no_update_setup_ml_cli, _, _ = no_update_setup_ml_cli in
     let do_update () =
       let oasis_exec_version =
-        BaseExec.run_read_one_line
+        OASISExec.run_read_one_line
+          ~ctxt:!BaseContext.default
           ~f_exit_code:
           (function
              | 0 ->
@@ -4020,7 +5669,8 @@
                 (String.concat " " (oasis_exec :: "setup" :: t.oasis_setup_args))
             else
               begin
-                BaseExec.run
+                OASISExec.run
+                  ~ctxt:!BaseContext.default
                   ~f_exit_code:
                   (function
                      | 0 ->
@@ -4031,7 +5681,7 @@
                                 please fix the problem and retry.")
                            oasis_exec)
                   oasis_exec ("setup" :: t.oasis_setup_args);
-                BaseExec.run ocaml (setup_ml :: args)
+                OASISExec.run ~ctxt:!BaseContext.default ocaml (setup_ml :: args)
               end
           end
         else
@@ -4041,13 +5691,14 @@
                  least oasis v%s.")
             oasis_exec oasis_exec_version setup_ml t.oasis_version
     in
-  
+
     if !update_setup_ml then
       begin
         try
           match t.oasis_digest with
             | Some dgst ->
-              if Sys.file_exists oasis_fn && dgst <> Digest.file "_oasis" then
+              if Sys.file_exists oasis_fn &&
+                 dgst <> Digest.file default_oasis_fn then
                 begin
                   do_update ();
                   true
@@ -4066,7 +5717,8 @@
       end
     else
       false
-  
+
+
   let setup t =
     let catch_exn =
       ref true
@@ -4078,7 +5730,7 @@
                    (f_ "No action defined, run '%s %s -help'")
                    Sys.executable_name
                    Sys.argv.(0))
-  
+
         in
         let extra_args_ref =
           ref []
@@ -4090,77 +5742,80 @@
           Arg.Tuple
             [
               Arg.Rest (fun str -> extra_args_ref := str :: !extra_args_ref);
-  
+
               Arg.Unit
                 (fun () ->
                    allow_empty_env_ref := allow_empty_env;
                    act_ref := act);
             ]
         in
-  
+
           Arg.parse
             (Arg.align
-               [
+               ([
                  "-configure",
                  arg_handle ~allow_empty_env:true configure,
                  s_ "[options*] Configure the whole build process.";
-  
+
                  "-build",
                  arg_handle build,
                  s_ "[options*] Build executables and libraries.";
-  
+
                  "-doc",
                  arg_handle doc,
                  s_ "[options*] Build documents.";
-  
+
                  "-test",
                  arg_handle test,
                  s_ "[options*] Run tests.";
-  
+
                  "-all",
                  arg_handle ~allow_empty_env:true all,
                  s_ "[options*] Run configure, build, doc and test targets.";
-  
+
                  "-install",
                  arg_handle install,
                  s_ "[options*] Install libraries, data, executables \
                                 and documents.";
-  
+
                  "-uninstall",
                  arg_handle uninstall,
                  s_ "[options*] Uninstall libraries, data, executables \
                                 and documents.";
-  
+
                  "-reinstall",
                  arg_handle reinstall,
                  s_ "[options*] Uninstall and install libraries, data, \
                                 executables and documents.";
-  
+
                  "-clean",
                  arg_handle ~allow_empty_env:true clean,
                  s_ "[options*] Clean files generated by a build.";
-  
+
                  "-distclean",
                  arg_handle ~allow_empty_env:true distclean,
                  s_ "[options*] Clean files generated by a build and configure.";
-  
+
                  "-version",
                  arg_handle ~allow_empty_env:true version,
                  s_ " Display version of OASIS used to generate this setup.ml.";
-  
+
                  "-no-catch-exn",
                  Arg.Clear catch_exn,
                  s_ " Don't catch exception, useful for debugging.";
-  
-                 no_update_setup_ml_cli;
                ]
-             @ (BaseContext.args ()))
+               @
+                (if t.setup_update then
+                   [no_update_setup_ml_cli]
+                 else
+                   [])
+               @ (BaseContext.args ())))
             (failwithf (f_ "Don't know what to do with '%s'"))
             (s_ "Setup and run build process current package\n");
-  
+
           (* Build initial environment *)
           load ~allow_empty:!allow_empty_env_ref ();
-  
+
           (** Initialize flags *)
           List.iter
             (function
@@ -4191,53 +5846,49 @@
                | _ ->
                    ())
             t.package.sections;
-  
+
           BaseStandardVar.init t.package;
-  
+
           BaseDynVar.init t.package;
-  
-          if not (update_setup_ml t) then
+
+          if t.setup_update && update_setup_ml t then
+            ()
+          else
             !act_ref t (Array.of_list (List.rev !extra_args_ref))
-  
+
       with e when !catch_exn ->
         error "%s" (Printexc.to_string e);
         exit 1
-  
+
+
 end
 
 
+# 5867 "setup.ml"
 module InternalConfigurePlugin = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/plugins/internal/InternalConfigurePlugin.ml"
-  
+(* # 22 "src/plugins/internal/InternalConfigurePlugin.ml" *)
+
+
   (** Configure using internal scheme
       @author Sylvain Le Gall
     *)
-  
+
+
   open BaseEnv
   open OASISTypes
   open OASISUtils
   open OASISGettext
   open BaseMessage
-  
+
+
   (** Configure build using provided series of check to be done
     * and then output corresponding file.
     *)
   let configure pkg argv =
-    let var_ignore_eval var =
-      let _s : string =
-        var ()
-      in
-        ()
-    in
-  
-    let errors =
-      ref SetString.empty
-    in
-  
-    let buff =
-      Buffer.create 13
-    in
-  
+    let var_ignore_eval var = let _s: string = var () in () in
+    let errors = ref SetString.empty in
+    let buff = Buffer.create 13 in
+
     let add_errors fmt =
       Printf.kbprintf
         (fun b ->
@@ -4246,11 +5897,11 @@
         buff
         fmt
     in
-  
+
     let warn_exception e =
       warning "%s" (Printexc.to_string e)
     in
-  
+
     (* Check tools *)
     let check_tools lst =
       List.iter
@@ -4280,7 +5931,7 @@
                  pkg.sections)
         lst
     in
-  
+
     let build_checks sct bs =
       if var_choose bs.bs_build then
         begin
@@ -4294,10 +5945,10 @@
                   (f_ "Section %s requires native compilation")
                   (OASISSection.string_of_section sct)
             end;
-  
+
           (* Check tools *)
           check_tools bs.bs_build_tools;
-  
+
           (* Check depends *)
           List.iter
             (function
@@ -4337,10 +5988,10 @@
             bs.bs_build_depends
         end
     in
-  
+
     (* Parse command line *)
     BaseArgExt.parse argv (BaseEnv.args ());
-  
+
     (* OCaml version *)
     begin
       match pkg.ocaml_version with
@@ -4362,7 +6013,7 @@
         | None ->
             ()
     end;
-  
+
     (* Findlib version *)
     begin
       match pkg.findlib_version with
@@ -4384,7 +6035,32 @@
         | None ->
             ()
     end;
-  
+    (* Make sure the findlib version is fine for the OCaml compiler. *)
+    begin
+      let ocaml_ge4 =
+        OASISVersion.version_compare
+          (OASISVersion.version_of_string (BaseStandardVar.ocaml_version()))
+          (OASISVersion.version_of_string "4.0.0") >= 0 in
+      if ocaml_ge4 then
+        let findlib_lt132 =
+          OASISVersion.version_compare
+            (OASISVersion.version_of_string (BaseStandardVar.findlib_version()))
+            (OASISVersion.version_of_string "1.3.2") < 0 in
+        if findlib_lt132 then
+          add_errors "OCaml >= 4.0.0 requires Findlib version >= 1.3.2"
+    end;
+
+    (* FlexDLL *)
+    if BaseStandardVar.os_type () = "Win32" ||
+       BaseStandardVar.os_type () = "Cygwin" then
+      begin
+        try
+          var_ignore_eval BaseStandardVar.flexlink
+        with e ->
+          warn_exception e;
+          add_errors (f_ "Cannot find 'flexlink'")
+      end;
+
     (* Check build depends *)
     List.iter
       (function
@@ -4400,7 +6076,7 @@
          | _ ->
              ())
       pkg.sections;
-  
+
     (* Check if we need native dynlink (presence of libraries that compile to
      * native)
      *)
@@ -4420,7 +6096,7 @@
         if has_cmxa then
           var_ignore_eval BaseStandardVar.native_dynlink
     end;
-  
+
     (* Check errors *)
     if SetString.empty != !errors then
       begin
@@ -4434,44 +6110,134 @@
              (SetString.cardinal !errors))
           (SetString.cardinal !errors)
       end
-  
+
+
 end
 
 module InternalInstallPlugin = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/plugins/internal/InternalInstallPlugin.ml"
-  
+(* # 22 "src/plugins/internal/InternalInstallPlugin.ml" *)
+
+
   (** Install using internal scheme
       @author Sylvain Le Gall
     *)
-  
+
+
   open BaseEnv
   open BaseStandardVar
   open BaseMessage
   open OASISTypes
-  open OASISLibrary
+  open OASISFindlib
   open OASISGettext
   open OASISUtils
-  
+
+
   let exec_hook =
     ref (fun (cs, bs, exec) -> cs, bs, exec)
-  
+
+
   let lib_hook =
     ref (fun (cs, bs, lib) -> cs, bs, lib, [])
-  
+
+
+  let obj_hook =
+    ref (fun (cs, bs, obj) -> cs, bs, obj, [])
+
+
   let doc_hook =
     ref (fun (cs, doc) -> cs, doc)
-  
+
+
   let install_file_ev =
     "install-file"
-  
+
+
   let install_dir_ev =
     "install-dir"
-  
+
+
   let install_findlib_ev =
     "install-findlib"
-  
+
+
+  let split_install_command ocamlfind findlib_name meta files =
+    if Sys.os_type = "Win32" then
+      let f s =
+        OASISHostPath.quote ( OASISHostPath.of_unix s )
+      in
+      let files = List.map f files in
+      let meta = f meta  in
+      let win32_max_command_line_length =
+        if OASISHostPath.use_bash () = false then
+          8000
+        else
+          30000
+      in
+      (* Arguments for the first command: *)
+      let first_args = ["install"; findlib_name; meta] in
+      (* Arguments for remaining commands: *)
+      let other_args = ["install"; findlib_name; "-add"] in
+      (* Extract as much files as possible from [files], [len] is
+         the current command line length: *)
+      let rec get_files len acc files =
+        match files with
+          | [] ->
+              (List.rev acc, [])
+          | file :: rest ->
+              let len = len + 1 + String.length file in
+              if len > win32_max_command_line_length then
+                (List.rev acc, files)
+              else
+                get_files len (file :: acc) rest
+      in
+      (* Split the command into several commands. *)
+      let rec split args files =
+        match files with
+          | [] ->
+              []
+          | _ ->
+              (* Length of "ocamlfind install <lib> [META|-add]" *)
+              let len =
+                List.fold_left
+                  (fun len arg ->
+                     len + 1 (* for the space *) + String.length arg)
+                  (String.length ocamlfind)
+                  args
+              in
+              match get_files len [] files with
+                | ([], _) ->
+                    failwith (s_ "Command line too long.")
+                | (firsts, others) ->
+                    let cmd = args @ firsts in
+                    (* Use -add for remaining commands: *)
+                    let () =
+                      let findlib_ge_132 =
+                        OASISVersion.comparator_apply
+                          (OASISVersion.version_of_string
+                             (BaseStandardVar.findlib_version ()))
+                          (OASISVersion.VGreaterEqual
+                             (OASISVersion.version_of_string "1.3.2"))
+                      in
+                        if not findlib_ge_132 then
+                          failwithf
+                            (f_ "Installing the library %s require to use the \
+                                 flag '-add' of ocamlfind because the command \
+                                 line is too long. This flag is only available \
+                                 for findlib 1.3.2. Please upgrade findlib from \
+                                 %s to 1.3.2")
+                            findlib_name (BaseStandardVar.findlib_version ())
+                    in
+                    let cmds = split other_args others in
+                    cmd :: cmds
+      in
+      (* The first command does not use -add: *)
+      split first_args files
+    else
+      ["install" :: findlib_name :: meta :: files]
+
+
   let install pkg argv =
-  
+
     let in_destdir =
       try
         let destdir =
@@ -4484,7 +6250,7 @@
       with PropList.Not_set _ ->
         fun fn -> fn
     in
-  
+
     let install_file ?tgt_fn src_file envdir =
       let tgt_dir =
         in_destdir (envdir ())
@@ -4499,27 +6265,29 @@
                  Filename.basename src_file)
       in
         (* Create target directory if needed *)
-        BaseFileUtil.mkdir_parent
+        OASISFileUtil.mkdir_parent
+          ~ctxt:!BaseContext.default
           (fun dn ->
              info (f_ "Creating directory '%s'") dn;
              BaseLog.register install_dir_ev dn)
           tgt_dir;
-  
+
         (* Really install files *)
         info (f_ "Copying file '%s' to '%s'") src_file tgt_file;
-        BaseFileUtil.cp src_file tgt_file;
+        OASISFileUtil.cp ~ctxt:!BaseContext.default src_file tgt_file;
         BaseLog.register install_file_ev tgt_file
     in
-  
+
     (* Install data into defined directory *)
     let install_data srcdir lst tgtdir =
       let tgtdir =
-        BaseFilePath.of_unix (var_expand tgtdir)
+        OASISHostPath.of_unix (var_expand tgtdir)
       in
         List.iter
           (fun (src, tgt_opt) ->
              let real_srcs =
-               BaseFileUtil.glob
+               OASISFileUtil.glob
+                 ~ctxt:!BaseContext.default
                  (Filename.concat srcdir src)
              in
                if real_srcs = [] then
@@ -4533,69 +6301,152 @@
                       (fun () ->
                          match tgt_opt with
                            | Some s ->
-                               BaseFilePath.of_unix (var_expand s)
+                               OASISHostPath.of_unix (var_expand s)
                            | None ->
                                tgtdir))
                  real_srcs)
           lst
     in
-  
+
+    let make_fnames modul sufx =
+      List.fold_right
+        begin fun sufx accu ->
+          (String.capitalize modul ^ sufx) ::
+          (String.uncapitalize modul ^ sufx) ::
+          accu
+        end
+        sufx
+        []
+    in
+
     (** Install all libraries *)
     let install_libs pkg =
-  
+
       let files_of_library (f_data, acc) data_lib =
         let cs, bs, lib, lib_extra =
           !lib_hook data_lib
         in
           if var_choose bs.bs_install &&
-             BaseBuilt.is_built BaseBuilt.BLib cs.cs_name then
+             BaseBuilt.is_built BaseBuilt.BLib cs.cs_name then
+            begin
+              let acc =
+                (* Start with acc + lib_extra *)
+                List.rev_append lib_extra acc
+              in
+              let acc =
+                (* Add uncompiled header from the source tree *)
+                let path =
+                  OASISHostPath.of_unix bs.bs_path
+                in
+                  List.fold_left
+                    begin fun acc modul ->
+                      begin
+                        try
+                          [List.find
+                            OASISFileUtil.file_exists_case
+                            (List.map
+                               (Filename.concat path)
+                               (make_fnames modul [".mli"; ".ml"]))]
+                        with Not_found ->
+                          warning
+                            (f_ "Cannot find source header for module %s \
+                                 in library %s")
+                            modul cs.cs_name;
+                          []
+                      end
+                      @
+                      List.filter
+                        OASISFileUtil.file_exists_case
+                        (List.map
+                           (Filename.concat path)
+                           (make_fnames modul [".annot";".cmti";".cmt"]))
+                      @ acc
+                    end
+                    acc
+                    lib.lib_modules
+              in
+
+              let acc =
+               (* Get generated files *)
+               BaseBuilt.fold
+                 BaseBuilt.BLib
+                 cs.cs_name
+                 (fun acc fn -> fn :: acc)
+                 acc
+              in
+
+              let f_data () =
+                (* Install data associated with the library *)
+                install_data
+                  bs.bs_path
+                  bs.bs_data_files
+                  (Filename.concat
+                     (datarootdir ())
+                     pkg.name);
+                f_data ()
+              in
+
+                (f_data, acc)
+            end
+           else
+            begin
+              (f_data, acc)
+            end
+      and files_of_object (f_data, acc) data_obj =
+        let cs, bs, obj, obj_extra =
+          !obj_hook data_obj
+        in
+          if var_choose bs.bs_install &&
+             BaseBuilt.is_built BaseBuilt.BObj cs.cs_name then
             begin
               let acc =
-                (* Start with acc + lib_extra *)
-                List.rev_append lib_extra acc
+                (* Start with acc + obj_extra *)
+                List.rev_append obj_extra acc
               in
               let acc =
                 (* Add uncompiled header from the source tree *)
                 let path =
-                  BaseFilePath.of_unix bs.bs_path
+                  OASISHostPath.of_unix bs.bs_path
                 in
                   List.fold_left
-                    (fun acc modul ->
-                       try
-                         List.find
-                           OASISUtils.file_exists
-                           (List.map
-                              (Filename.concat path)
-                              [modul^".mli";
-                               modul^".ml";
-                               String.uncapitalize modul^".mli";
-                               String.capitalize   modul^".mli";
-                               String.uncapitalize modul^".ml";
-                               String.capitalize   modul^".ml"])
-                         :: acc
-                       with Not_found ->
-                         begin
-                           warning
-                             (f_ "Cannot find source header for module %s \
-                                  in library %s")
-                             modul cs.cs_name;
-                           acc
-                         end)
+                    begin fun acc modul ->
+                      begin
+                        try
+                          [List.find
+                             OASISFileUtil.file_exists_case
+                             (List.map
+                                (Filename.concat path)
+                                (make_fnames modul [".mli"; ".ml"]))]
+                        with Not_found ->
+                          warning
+                            (f_ "Cannot find source header for module %s \
+                                 in object %s")
+                            modul cs.cs_name;
+                          []
+                      end
+                      @
+                      List.filter
+                        OASISFileUtil.file_exists_case
+                        (List.map
+                           (Filename.concat path)
+                           (make_fnames modul [".annot";".cmti";".cmt"]))
+                      @ acc
+                    end
                     acc
-                    lib.lib_modules
+                    obj.obj_modules
               in
-  
+
               let acc =
                (* Get generated files *)
                BaseBuilt.fold
-                 BaseBuilt.BLib
+                 BaseBuilt.BObj
                  cs.cs_name
                  (fun acc fn -> fn :: acc)
                  acc
               in
-  
+
               let f_data () =
-                (* Install data associated with the library *)
+                (* Install data associated with the object *)
                 install_data
                   bs.bs_path
                   bs.bs_data_files
@@ -4604,15 +6455,16 @@
                      pkg.name);
                 f_data ()
               in
-  
+
                 (f_data, acc)
             end
            else
             begin
               (f_data, acc)
             end
+
       in
-  
+
       (* Install one group of library *)
       let install_group_lib grp =
         (* Iterate through all group nodes *)
@@ -4621,30 +6473,32 @@
             match grp with
               | Container (_, children) ->
                   data_and_files, children
-              | Package (_, cs, bs, lib, children) ->
+              | Package (_, cs, bs, `Library lib, children) ->
                   files_of_library data_and_files (cs, bs, lib), children
+              | Package (_, cs, bs, `Object obj, children) ->
+                  files_of_object data_and_files (cs, bs, obj), children
           in
             List.fold_left
               install_group_lib_aux
               data_and_files
               children
         in
-  
+
         (* Findlib name of the root library *)
         let findlib_name =
           findlib_of_group grp
         in
-  
+
         (* Determine root library *)
         let root_lib =
           root_of_group grp
         in
-  
+
         (* All files to install for this library *)
         let f_data, files =
           install_group_lib_aux (ignore, []) grp
         in
-  
+
           (* Really install, if there is something to install *)
           if files = [] then
             begin
@@ -4656,20 +6510,20 @@
             begin
               let meta =
                 (* Search META file *)
-                let (_, bs, _) =
+                let _, bs, _ =
                   root_lib
                 in
                 let res =
                   Filename.concat bs.bs_path "META"
                 in
-                  if not (OASISUtils.file_exists res) then
+                  if not (OASISFileUtil.file_exists_case res) then
                     failwithf
                       (f_ "Cannot find file '%s' for findlib library %s")
                       res
                       findlib_name;
                   res
               in
-              let files = 
+              let files =
                 (* Make filename shorter to avoid hitting command max line length
                  * too early, esp. on Windows.
                  *)
@@ -4678,48 +6532,58 @@
                   let nlen = String.length n in
                     if plen <= nlen && String.sub n 0 plen = p then
                       begin
-                        let fn_sep = 
+                        let fn_sep =
                           if Sys.os_type = "Win32" then
                             '\\'
                           else
                             '/'
                         in
                         let cutpoint = plen +
-                          (if plen < nlen && n.[plen] = fn_sep then 
+                          (if plen < nlen && n.[plen] = fn_sep then
                              1
-                           else 
+                           else
                              0)
                         in
                           String.sub n cutpoint (nlen - cutpoint)
                       end
-                    else 
+                    else
                       n
                 in
-                  List.map (remove_prefix (Sys.getcwd ())) files 
+                  List.map (remove_prefix (Sys.getcwd ())) files
               in
                 info
                   (f_ "Installing findlib library '%s'")
                   findlib_name;
-                BaseExec.run
-                  (ocamlfind ())
-                  ("install" :: findlib_name :: meta :: files);
+                let ocamlfind = ocamlfind () in
+                let commands =
+                  split_install_command
+                    ocamlfind
+                    findlib_name
+                    meta
+                    files
+                in
+                List.iter
+                  (OASISExec.run ~ctxt:!BaseContext.default ocamlfind)
+                  commands;
                 BaseLog.register install_findlib_ev findlib_name
             end;
-  
+
           (* Install data files *)
           f_data ();
-  
+
+      in
+
+      let group_libs, _, _ =
+        findlib_mapping pkg
       in
-  
+
         (* We install libraries in groups *)
-        List.iter
-          install_group_lib
-          (group_libs pkg)
+        List.iter install_group_lib group_libs
     in
-  
+
     let install_execs pkg =
       let install_exec data_exec =
-        let (cs, bs, exec) =
+        let cs, bs, exec =
           !exec_hook data_exec
         in
           if var_choose bs.bs_install &&
@@ -4735,7 +6599,7 @@
                   cs.cs_name
                   (fun () fn ->
                      install_file
-                       ~tgt_fn:cs.cs_name
+                       ~tgt_fn:(cs.cs_name ^ ext_program ())
                        fn
                        bindir)
                   ();
@@ -4763,17 +6627,17 @@
                  ())
           pkg.sections
     in
-  
+
     let install_docs pkg =
       let install_doc data =
-        let (cs, doc) =
+        let cs, doc =
           !doc_hook data
         in
           if var_choose doc.doc_install &&
              BaseBuilt.is_built BaseBuilt.BDoc cs.cs_name then
             begin
               let tgt_dir =
-                BaseFilePath.of_unix (var_expand doc.doc_install_dir)
+                OASISHostPath.of_unix (var_expand doc.doc_install_dir)
               in
                 BaseBuilt.fold
                   BaseBuilt.BDoc
@@ -4797,18 +6661,19 @@
                  ())
           pkg.sections
     in
-  
+
       install_libs  pkg;
       install_execs pkg;
       install_docs  pkg
-  
+
+
   (* Uninstall already installed data *)
   let uninstall _ argv =
     List.iter
       (fun (ev, data) ->
          if ev = install_file_ev then
            begin
-             if OASISUtils.file_exists data then
+             if OASISFileUtil.file_exists_case data then
                begin
                  info
                    (f_ "Removing file '%s'")
@@ -4824,14 +6689,14 @@
            end
          else if ev = install_dir_ev then
            begin
-             if OASISUtils.file_exists data && Sys.is_directory data then
+             if Sys.file_exists data && Sys.is_directory data then
                begin
                  if Sys.readdir data = [||] then
                    begin
                      info
                        (f_ "Removing directory '%s'")
                        data;
-                     BaseFileUtil.rmdir data
+                     OASISFileUtil.rmdir ~ctxt:!BaseContext.default data
                    end
                  else
                    begin
@@ -4854,7 +6719,8 @@
          else if ev = install_findlib_ev then
            begin
              info (f_ "Removing findlib library '%s'") data;
-             BaseExec.run (ocamlfind ()) ["remove"; data]
+             OASISExec.run ~ctxt:!BaseContext.default
+               (ocamlfind ()) ["remove"; data]
            end
          else
            failwithf (f_ "Unknown log event '%s'") ev;
@@ -4864,30 +6730,42 @@
          (BaseLog.filter
             [install_file_ev;
              install_dir_ev;
-             install_findlib_ev;]))
-  
+             install_findlib_ev]))
+
+
 end
 
 
+# 6739 "setup.ml"
 module OCamlbuildCommon = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/plugins/ocamlbuild/OCamlbuildCommon.ml"
-  
+(* # 22 "src/plugins/ocamlbuild/OCamlbuildCommon.ml" *)
+
+
   (** Functions common to OCamlbuild build and doc plugin
     *)
-  
+
+
   open OASISGettext
   open BaseEnv
   open BaseStandardVar
-  
-  let ocamlbuild_clean_ev =
-    "ocamlbuild-clean"
-  
+  open OASISTypes
+
+
+
+
+  type extra_args = string list
+
+
+  let ocamlbuild_clean_ev = "ocamlbuild-clean"
+
+
   let ocamlbuildflags =
     var_define
       ~short_desc:(fun () -> "OCamlbuild additional flags")
       "ocamlbuildflags"
       (fun () -> "")
-  
+
+
   (** Fix special arguments depending on environment *)
   let fix_args args extra_argv =
     List.flatten
@@ -4898,11 +6776,11 @@
             "-no-log";
             "-no-links";
             "-install-lib-dir";
-            (Filename.concat (standard_library ()) "ocamlbuild")
+            (OASISHostPath.quote (OASISHostPath.of_unix (Filename.concat (standard_library ()) "ocamlbuild")))
           ]
         else
           [];
-  
+
         if not (bool_of_string (is_native ())) || (os_type ()) = "Win32" then
           [
             "-byte-plugin"
@@ -4910,22 +6788,28 @@
         else
           [];
         args;
-  
+
         if bool_of_string (debug ()) then
           ["-tag"; "debug"]
         else
           [];
-  
+
+        if bool_of_string (tests ()) then
+          ["-tag"; "tests"]
+        else
+          [];
+
         if bool_of_string (profile ()) then
           ["-tag"; "profile"]
         else
           [];
-  
-        OASISUtils.split ' ' (ocamlbuildflags ());
-  
+
+        OASISString.nsplit (ocamlbuildflags ()) ' ';
+
         Array.to_list extra_argv;
       ]
-  
+
+
   (** Run 'ocamlbuild -clean' if not already done *)
   let run_clean extra_argv =
     let extra_cli =
@@ -4934,7 +6818,8 @@
       (* Run if never called with these args *)
       if not (BaseLog.exists ocamlbuild_clean_ev extra_cli) then
         begin
-          BaseExec.run (ocamlbuild ()) (fix_args ["-clean"] extra_argv);
+          OASISExec.run ~ctxt:!BaseContext.default
+            (ocamlbuild ()) (fix_args ["-clean"] extra_argv);
           BaseLog.register ocamlbuild_clean_ev extra_cli;
           at_exit
             (fun () ->
@@ -4943,17 +6828,20 @@
                with _ ->
                  ())
         end
-  
+
+
   (** Run ocamlbuild, unregister all clean events *)
   let run_ocamlbuild args extra_argv =
     (* TODO: enforce that target in args must be UNIX encoded i.e. toto/index.html
      *)
-    BaseExec.run (ocamlbuild ()) (fix_args args extra_argv);
+    OASISExec.run ~ctxt:!BaseContext.default
+      (ocamlbuild ()) (fix_args args extra_argv);
     (* Remove any clean event, we must run it again *)
     List.iter
       (fun (e, d) -> BaseLog.unregister e d)
       (BaseLog.filter [ocamlbuild_clean_ev])
-  
+
+
   (** Determine real build directory *)
   let build_dir extra_argv =
     let rec search_args dir =
@@ -4966,41 +6854,49 @@
             dir
     in
       search_args "_build" (fix_args [] extra_argv)
-  
+
+
 end
 
 module OCamlbuildPlugin = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/plugins/ocamlbuild/OCamlbuildPlugin.ml"
-  
+(* # 22 "src/plugins/ocamlbuild/OCamlbuildPlugin.ml" *)
+
+
   (** Build using ocamlbuild
       @author Sylvain Le Gall
     *)
-  
+
+
   open OASISTypes
   open OASISGettext
   open OASISUtils
+  open OASISString
   open BaseEnv
   open OCamlbuildCommon
   open BaseStandardVar
   open BaseMessage
-  
+
+
+
+
+
   let cond_targets_hook =
     ref (fun lst -> lst)
-  
-  let build pkg argv =
-  
+
+
+  let build extra_args pkg argv =
     (* Return the filename in build directory *)
     let in_build_dir fn =
       Filename.concat
         (build_dir argv)
         fn
     in
-  
+
     (* Return the unix filename in host build directory *)
     let in_build_dir_of_unix fn =
-      in_build_dir (BaseFilePath.of_unix fn)
+      in_build_dir (OASISHostPath.of_unix fn)
     in
-  
+
     let cond_targets =
       List.fold_left
         (fun acc ->
@@ -5012,19 +6908,7 @@
                        in_build_dir_of_unix
                        (cs, bs, lib)
                    in
-  
-                   let ends_with nd fn =
-                     let nd_len =
-                       String.length nd
-                     in
-                       (String.length fn >= nd_len)
-                       &&
-                       (String.sub
-                          fn
-                          (String.length fn - nd_len)
-                          nd_len) = nd
-                   in
-  
+
                    let tgts =
                      List.flatten
                        (List.filter
@@ -5032,14 +6916,14 @@
                           (List.map
                              (List.filter
                                 (fun fn ->
-                                 ends_with ".cma" fn
-                                 || ends_with ".cmxs" fn
-                                 || ends_with ".cmxa" fn
-                                 || ends_with (ext_lib ()) fn
-                                 || ends_with (ext_dll ()) fn))
+                                 ends_with ~what:".cma" fn
+                                 || ends_with ~what:".cmxs" fn
+                                 || ends_with ~what:".cmxa" fn
+                                 || ends_with ~what:(ext_lib ()) fn
+                                 || ends_with ~what:(ext_dll ()) fn))
                              unix_files))
                    in
-  
+
                      match tgts with
                        | _ :: _ ->
                            (evs, tgts) :: acc
@@ -5048,7 +6932,36 @@
                              (f_ "No possible ocamlbuild targets for library %s")
                              cs.cs_name
                  end
-  
+
+             | Object (cs, bs, obj) when var_choose bs.bs_build ->
+                 begin
+                   let evs, unix_files =
+                     BaseBuilt.of_object
+                       in_build_dir_of_unix
+                       (cs, bs, obj)
+                   in
+
+                   let tgts =
+                     List.flatten
+                       (List.filter
+                          (fun l -> l <> [])
+                          (List.map
+                             (List.filter
+                                (fun fn ->
+                                 ends_with ".cmo" fn
+                                 || ends_with ".cmx" fn))
+                             unix_files))
+                   in
+
+                     match tgts with
+                       | _ :: _ ->
+                           (evs, tgts) :: acc
+                       | [] ->
+                           failwithf
+                             (f_ "No possible ocamlbuild targets for object %s")
+                             cs.cs_name
+                 end
+
              | Executable (cs, bs, exec) when var_choose bs.bs_build ->
                  begin
                    let evs, unix_exec_is, unix_dll_opt =
@@ -5056,27 +6969,28 @@
                        in_build_dir_of_unix
                        (cs, bs, exec)
                    in
-  
+
                    let target ext =
                      let unix_tgt =
-                       (BaseFilePath.Unix.concat
+                       (OASISUnixPath.concat
                           bs.bs_path
-                          (BaseFilePath.Unix.chop_extension
+                          (OASISUnixPath.chop_extension
                              exec.exec_main_is))^ext
                      in
-                     let evs = 
+                     let evs =
                        (* Fix evs, we want to use the unix_tgt, without copying *)
                        List.map
                          (function
                             | BaseBuilt.BExec, nm, lst when nm = cs.cs_name ->
-                                BaseBuilt.BExec, nm, [[in_build_dir_of_unix unix_tgt]]
+                                BaseBuilt.BExec, nm,
+                                [[in_build_dir_of_unix unix_tgt]]
                             | ev ->
                                 ev)
                          evs
                      in
                        evs, [unix_tgt]
                    in
-  
+
                    (* Add executable *)
                    let acc =
                      match bs.bs_compiled_object with
@@ -5090,43 +7004,39 @@
                    in
                      acc
                  end
-  
-             | Library _ | Executable _ | Test _
+
+             | Library _ | Object _ | Executable _ | Test _
              | SrcRepo _ | Flag _ | Doc _ ->
                  acc)
         []
         (* Keep the pkg.sections ordered *)
         (List.rev pkg.sections);
     in
-  
+
     (* Check and register built files *)
     let check_and_register (bt, bnm, lst) =
       List.iter
         (fun fns ->
-           if not (List.exists OASISUtils.file_exists fns) then
+           if not (List.exists OASISFileUtil.file_exists_case fns) then
              failwithf
-               (f_ "No one of expected built files %s exists")
-               (String.concat (s_ ", ") (List.map (Printf.sprintf "'%s'") fns)))
+               (fn_
+                  "Expected built file %s doesn't exist."
+                  "None of expected built files %s exists."
+                  (List.length fns))
+               (String.concat (s_ " or ") (List.map (Printf.sprintf "'%s'") fns)))
         lst;
         (BaseBuilt.register bt bnm lst)
     in
-  
-    let cond_targets =
-      (* Run the hook *)
-      !cond_targets_hook cond_targets
-    in
-  
-      (* Run a list of target... *)
-      run_ocamlbuild 
-        (List.flatten 
-           (List.map snd cond_targets))
-        argv;
-      (* ... and register events *)
-      List.iter
-        check_and_register
-        (List.flatten (List.map fst cond_targets))
-  
-  
+
+    (* Run the hook *)
+    let cond_targets = !cond_targets_hook cond_targets in
+
+    (* Run a list of target... *)
+    run_ocamlbuild (List.flatten (List.map snd cond_targets) @ extra_args) argv;
+    (* ... and register events *)
+    List.iter check_and_register (List.flatten (List.map fst cond_targets))
+
+
   let clean pkg extra_args  =
     run_clean extra_args;
     List.iter
@@ -5139,71 +7049,95 @@
          | _ ->
              ())
       pkg.sections
-  
+
+
 end
 
 module OCamlbuildDocPlugin = struct
-# 21 "/home/mfp/src/ocsigen-bundle-2.2.2/others/oasis-0.3.0~rc3/src/plugins/ocamlbuild/OCamlbuildDocPlugin.ml"
-  
+(* # 22 "src/plugins/ocamlbuild/OCamlbuildDocPlugin.ml" *)
+
+
   (* Create documentation using ocamlbuild .odocl files
      @author Sylvain Le Gall
    *)
-  
+
+
   open OASISTypes
   open OASISGettext
   open OASISMessage
   open OCamlbuildCommon
   open BaseStandardVar
-  
-  
-  
-  let doc_build path pkg (cs, doc) argv =
+
+
+
+
+  type run_t =
+    {
+      extra_args: string list;
+      run_path: unix_filename;
+    }
+
+
+  let doc_build run pkg (cs, doc) argv =
     let index_html =
-      BaseFilePath.Unix.make
+      OASISUnixPath.make
         [
-          path;
+          run.run_path;
           cs.cs_name^".docdir";
           "index.html";
         ]
     in
     let tgt_dir =
-      BaseFilePath.make
+      OASISHostPath.make
         [
           build_dir argv;
-          BaseFilePath.of_unix path;
+          OASISHostPath.of_unix run.run_path;
           cs.cs_name^".docdir";
         ]
     in
-      run_ocamlbuild [index_html] argv;
+      run_ocamlbuild (index_html :: run.extra_args) argv;
       List.iter
         (fun glb ->
            BaseBuilt.register
              BaseBuilt.BDoc
              cs.cs_name
-             [BaseFileUtil.glob
+             [OASISFileUtil.glob ~ctxt:!BaseContext.default
                 (Filename.concat tgt_dir glb)])
         ["*.html"; "*.css"]
-  
-  let doc_clean t pkg (cs, doc) argv =
+
+
+  let doc_clean run pkg (cs, doc) argv =
     run_clean argv;
     BaseBuilt.unregister BaseBuilt.BDoc cs.cs_name
-  
+
+
 end
 
 
+# 7117 "setup.ml"
 open OASISTypes;;
 
 let setup_t =
   {
      BaseSetup.configure = InternalConfigurePlugin.configure;
-     build = OCamlbuildPlugin.build;
+     build = OCamlbuildPlugin.build [];
      test = [];
-     doc = [("sqlexpr", OCamlbuildDocPlugin.doc_build ".")];
+     doc =
+       [
+          ("sqlexpr",
+            OCamlbuildDocPlugin.doc_build
+              {OCamlbuildDocPlugin.extra_args = []; run_path = "."})
+       ];
      install = InternalInstallPlugin.install;
      uninstall = InternalInstallPlugin.uninstall;
      clean = [OCamlbuildPlugin.clean];
      clean_test = [];
-     clean_doc = [("sqlexpr", OCamlbuildDocPlugin.doc_clean ".")];
+     clean_doc =
+       [
+          ("sqlexpr",
+            OCamlbuildDocPlugin.doc_clean
+              {OCamlbuildDocPlugin.extra_args = []; run_path = "."})
+       ];
      distclean = [];
      distclean_test = [];
      distclean_doc = [];
@@ -5212,15 +7146,18 @@
           oasis_version = "0.3";
           ocaml_version = None;
           findlib_version = None;
+          alpha_features = [];
+          beta_features = [];
           name = "ocaml-sqlexpr";
           version = "0.5.5";
           license =
             OASISLicense.DEP5License
-              {
-                 OASISLicense.license = "LGPL";
-                 exceptions = ["OCaml linking"];
-                 version = OASISLicense.Version "2.1";
-                 };
+              (OASISLicense.DEP5Unit
+                 {
+                    OASISLicense.license = "LGPL";
+                    excption = Some "OCaml linking";
+                    version = OASISLicense.Version "2.1"
+                 });
           license_file = None;
           copyrights = [];
           maintainers = ["Mauricio Fernandez <mfp@acm.org>"];
@@ -5229,113 +7166,86 @@
           synopsis = "Type-safe, convenient SQLite database access.";
           description =
             Some
-              "Minimalistic library and syntax extension for type-safe, convenient execution\nof SQL statements. Currently compatible with Sqlite3.\n\nSqlexpr features:\n\n* automated prepared statement caching, param binding, data extraction, error\n  checking (including automatic stmt reset to avoid BUSY/LOCKED errors in\n  subsequent queries), stmt finalization on db close, etc.\n\n* HOFs like iter, fold, transaction\n\n* support for different concurrency models: everything is functorized over a\n  THREAD monad, so you can for instance do concurrent folds/iters with Lwt\n\n* support for SQL stmt syntax checks and some extra semantic checking (column\n  names, etc)";
+              [
+                 OASISText.Para
+                   "Minimalistic library and syntax extension for type-safe, convenient execution of SQL statements. Currently compatible with Sqlite3.";
+                 OASISText.Para "Sqlexpr features:";
+                 OASISText.Para
+                   "* automated prepared statement caching, param binding, data extraction, error";
+                 OASISText.Verbatim
+                   " checking (including automatic stmt reset to avoid BUSY/LOCKED errors in";
+                 OASISText.Verbatim
+                   " subsequent queries), stmt finalization on db close, etc.";
+                 OASISText.BlankLine;
+                 OASISText.Para "* HOFs like iter, fold, transaction";
+                 OASISText.Para
+                   "* support for different concurrency models: everything is functorized over a";
+                 OASISText.Verbatim
+                   " THREAD monad, so you can for instance do concurrent folds/iters with Lwt";
+                 OASISText.BlankLine;
+                 OASISText.Para
+                   "* support for SQL stmt syntax checks and some extra semantic checking (column";
+                 OASISText.Verbatim " names, etc)"
+              ];
           categories = [];
-          conf_type = (`Configure, "internal", Some "0.3");
+          conf_type = (`Configure, "internal", Some "0.4");
           conf_custom =
             {
                pre_command = [(OASISExpr.EBool true, None)];
-               post_command = [(OASISExpr.EBool true, None)];
-               };
-          build_type = (`Build, "ocamlbuild", Some "0.3");
+               post_command = [(OASISExpr.EBool true, None)]
+            };
+          build_type = (`Build, "ocamlbuild", Some "0.4");
           build_custom =
             {
                pre_command = [(OASISExpr.EBool true, None)];
-               post_command = [(OASISExpr.EBool true, None)];
-               };
-          install_type = (`Install, "internal", Some "0.3");
+               post_command = [(OASISExpr.EBool true, None)]
+            };
+          install_type = (`Install, "internal", Some "0.4");
           install_custom =
             {
                pre_command = [(OASISExpr.EBool true, None)];
-               post_command = [(OASISExpr.EBool true, None)];
-               };
+               post_command = [(OASISExpr.EBool true, None)]
+            };
           uninstall_custom =
             {
                pre_command = [(OASISExpr.EBool true, None)];
-               post_command = [(OASISExpr.EBool true, None)];
-               };
+               post_command = [(OASISExpr.EBool true, None)]
+            };
           clean_custom =
             {
                pre_command = [(OASISExpr.EBool true, None)];
-               post_command = [(OASISExpr.EBool true, None)];
-               };
+               post_command = [(OASISExpr.EBool true, None)]
+            };
           distclean_custom =
             {
                pre_command = [(OASISExpr.EBool true, None)];
-               post_command = [(OASISExpr.EBool true, None)];
-               };
+               post_command = [(OASISExpr.EBool true, None)]
+            };
           files_ab = [];
           sections =
             [
-               Doc
-                 ({
-                     cs_name = "sqlexpr";
-                     cs_data = PropList.Data.create ();
-                     cs_plugin_data = [];
-                     },
-                   {
-                      doc_type = (`Doc, "ocamlbuild", Some "0.3");
-                      doc_custom =
-                        {
-                           pre_command = [(OASISExpr.EBool true, None)];
-                           post_command = [(OASISExpr.EBool true, None)];
-                           };
-                      doc_build =
-                        [
-                           (OASISExpr.EBool true, false);
-                           (OASISExpr.EFlag "docs", true)
-                        ];
-                      doc_install = [(OASISExpr.EBool true, true)];
-                      doc_install_dir = "$htmldir/sqlexpr";
-                      doc_title = "API reference for Sqlexpr";
-                      doc_authors = [];
-                      doc_abstract = None;
-                      doc_format = OtherDoc;
-                      doc_data_files = [];
-                      doc_build_tools =
-                        [ExternalTool "ocamlbuild"; ExternalTool "ocamldoc"];
-                      });
-               Library
+               SrcRepo
                  ({
-                     cs_name = "sqlexpr_syntax";
+                     cs_name = "github";
                      cs_data = PropList.Data.create ();
-                     cs_plugin_data = [];
-                     },
-                   {
-                      bs_build = [(OASISExpr.EBool true, true)];
-                      bs_install = [(OASISExpr.EBool true, true)];
-                      bs_path = ".";
-                      bs_compiled_object = Best;
-                      bs_build_depends =
-                        [
-                           FindlibPackage ("camlp4.lib", None);
-                           FindlibPackage ("camlp4.quotations.r", None);
-                           FindlibPackage ("estring", None)
-                        ];
-                      bs_build_tools = [ExternalTool "ocamlbuild"];
-                      bs_c_sources = [];
-                      bs_data_files = [];
-                      bs_ccopt = [(OASISExpr.EBool true, [])];
-                      bs_cclib = [(OASISExpr.EBool true, [])];
-                      bs_dlllib = [(OASISExpr.EBool true, [])];
-                      bs_dllpath = [(OASISExpr.EBool true, [])];
-                      bs_byteopt = [(OASISExpr.EBool true, [])];
-                      bs_nativeopt = [(OASISExpr.EBool true, [])];
-                      },
+                     cs_plugin_data = []
+                  },
                    {
-                      lib_modules = ["Pa_sql"];
-                      lib_pack = false;
-                      lib_internal_modules = [];
-                      lib_findlib_parent = Some "sqlexpr";
-                      lib_findlib_name = Some "syntax";
-                      lib_findlib_containers = [];
-                      });
+                      src_repo_type = Git;
+                      src_repo_location =
+                        "git://github.com/mfp/ocaml-sqlexpr.git";
+                      src_repo_browser = None;
+                      src_repo_module = None;
+                      src_repo_branch = None;
+                      src_repo_tag = None;
+                      src_repo_subdir = None
+                   });
                Library
                  ({
                      cs_name = "sqlexpr";
                      cs_data = PropList.Data.create ();
-                     cs_plugin_data = [];
-                     },
+                     cs_plugin_data = []
+                  },
                    {
                       bs_build = [(OASISExpr.EBool true, true)];
                       bs_install = [(OASISExpr.EBool true, true)];
@@ -5365,8 +7275,8 @@
                       bs_dlllib = [(OASISExpr.EBool true, [])];
                       bs_dllpath = [(OASISExpr.EBool true, [])];
                       bs_byteopt = [(OASISExpr.EBool true, [])];
-                      bs_nativeopt = [(OASISExpr.EBool true, [])];
-                      },
+                      bs_nativeopt = [(OASISExpr.EBool true, [])]
+                   },
                    {
                       lib_modules =
                         [
@@ -5378,39 +7288,88 @@
                       lib_internal_modules = [];
                       lib_findlib_parent = None;
                       lib_findlib_name = None;
-                      lib_findlib_containers = [];
-                      });
-               SrcRepo
+                      lib_findlib_containers = []
+                   });
+               Library
                  ({
-                     cs_name = "github";
+                     cs_name = "sqlexpr_syntax";
                      cs_data = PropList.Data.create ();
-                     cs_plugin_data = [];
-                     },
+                     cs_plugin_data = []
+                  },
                    {
-                      src_repo_type = Git;
-                      src_repo_location =
-                        "git://github.com/mfp/ocaml-sqlexpr.git";
-                      src_repo_browser = None;
-                      src_repo_module = None;
-                      src_repo_branch = None;
-                      src_repo_tag = None;
-                      src_repo_subdir = None;
-                      })
+                      bs_build = [(OASISExpr.EBool true, true)];
+                      bs_install = [(OASISExpr.EBool true, true)];
+                      bs_path = ".";
+                      bs_compiled_object = Best;
+                      bs_build_depends =
+                        [
+                           FindlibPackage ("camlp4.lib", None);
+                           FindlibPackage ("camlp4.quotations.r", None);
+                           FindlibPackage ("estring", None)
+                        ];
+                      bs_build_tools = [ExternalTool "ocamlbuild"];
+                      bs_c_sources = [];
+                      bs_data_files = [];
+                      bs_ccopt = [(OASISExpr.EBool true, [])];
+                      bs_cclib = [(OASISExpr.EBool true, [])];
+                      bs_dlllib = [(OASISExpr.EBool true, [])];
+                      bs_dllpath = [(OASISExpr.EBool true, [])];
+                      bs_byteopt = [(OASISExpr.EBool true, [])];
+                      bs_nativeopt = [(OASISExpr.EBool true, [])]
+                   },
+                   {
+                      lib_modules = ["Pa_sql"];
+                      lib_pack = false;
+                      lib_internal_modules = [];
+                      lib_findlib_parent = Some "sqlexpr";
+                      lib_findlib_name = Some "syntax";
+                      lib_findlib_containers = []
+                   });
+               Doc
+                 ({
+                     cs_name = "sqlexpr";
+                     cs_data = PropList.Data.create ();
+                     cs_plugin_data = []
+                  },
+                   {
+                      doc_type = (`Doc, "ocamlbuild", Some "0.3");
+                      doc_custom =
+                        {
+                           pre_command = [(OASISExpr.EBool true, None)];
+                           post_command = [(OASISExpr.EBool true, None)]
+                        };
+                      doc_build =
+                        [
+                           (OASISExpr.ENot (OASISExpr.EFlag "docs"), false);
+                           (OASISExpr.EFlag "docs", true)
+                        ];
+                      doc_install = [(OASISExpr.EBool true, true)];
+                      doc_install_dir = "$htmldir/sqlexpr";
+                      doc_title = "API reference for Sqlexpr";
+                      doc_authors = [];
+                      doc_abstract = None;
+                      doc_format = OtherDoc;
+                      doc_data_files = [];
+                      doc_build_tools =
+                        [ExternalTool "ocamlbuild"; ExternalTool "ocamldoc"]
+                   })
             ];
           plugins =
             [(`Extra, "DevFiles", Some "0.3"); (`Extra, "META", Some "0.3")];
+          disable_oasis_section = [];
           schema_data = PropList.Data.create ();
-          plugin_data = [];
-          };
+          plugin_data = []
+       };
      oasis_fn = Some "_oasis";
-     oasis_version = "0.3.0~rc3";
+     oasis_version = "0.4.5";
      oasis_digest = Some "\bG\174\172EN\182VF8\027\012\023k\029_";
      oasis_exec = None;
      oasis_setup_args = [];
-     };;
+     setup_update = false
+  };;
 
 let setup () = BaseSetup.setup setup_t;;
 
-# 5415 "setup.ml"
+# 7374 "setup.ml"
 (* OASIS_STOP *)
 let () = setup ();;
Only in .: sqlexpr.mldylib
Only in .: sqlexpr_syntax.mldylib
diff -r -u ../ocaml-sqlexpr-0.5.5.orig/_tags ./_tags
--- ./_tags
+++ ./_tags
@@ -1,10 +1,11 @@
 <**/*.ml>: syntax_camlp4o
 
 # OASIS_START
-# DO NOT EDIT (digest: dfffe6ec960f8ff3b4403d34c7548c58)
-# Ignore VCS directories, you can use the same kind of rule outside 
-# OASIS_START/STOP if you want to exclude directories that contains 
+# DO NOT EDIT (digest: 2f199f6e4a16ad6e5d6a441d642ba224)
+# Ignore VCS directories, you can use the same kind of rule outside
+# OASIS_START/STOP if you want to exclude directories that contains
 # useless stuff for the build process
+true: annot, bin_annot
 <**/.svn>: -traverse
 <**/.svn>: not_hygienic
 ".bzr": -traverse
@@ -15,19 +16,19 @@
 ".git": not_hygienic
 "_darcs": -traverse
 "_darcs": not_hygienic
-# Library sqlexpr_syntax
-"sqlexpr_syntax.cmxs": use_sqlexpr_syntax
-<*.ml{,i}>: pkg_camlp4.quotations.r
-<*.ml{,i}>: pkg_camlp4.lib
 # Library sqlexpr
 "sqlexpr.cmxs": use_sqlexpr
-<*.ml{,i}>: pkg_unix
-<*.ml{,i}>: pkg_threads
-<*.ml{,i}>: pkg_sqlite3
-<*.ml{,i}>: pkg_lwt.unix
-<*.ml{,i}>: pkg_lwt.syntax
-<*.ml{,i}>: pkg_lwt
-<*.ml{,i}>: pkg_estring
-<*.ml{,i}>: pkg_csv
-<*.ml{,i}>: pkg_batteries
+<*.ml{,i,y}>: pkg_batteries
+<*.ml{,i,y}>: pkg_csv
+<*.ml{,i,y}>: pkg_lwt
+<*.ml{,i,y}>: pkg_lwt.syntax
+<*.ml{,i,y}>: pkg_lwt.unix
+<*.ml{,i,y}>: pkg_sqlite3
+<*.ml{,i,y}>: pkg_threads
+<*.ml{,i,y}>: pkg_unix
+# Library sqlexpr_syntax
+"sqlexpr_syntax.cmxs": use_sqlexpr_syntax
+<*.ml{,i,y}>: pkg_camlp4.lib
+<*.ml{,i,y}>: pkg_camlp4.quotations.r
+<*.ml{,i,y}>: pkg_estring
 # OASIS_STOP
