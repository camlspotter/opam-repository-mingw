--- ./Makefile
+++ ./Makefile
@@ -1,5 +1,5 @@
 # OASIS_START
-# DO NOT EDIT (digest: 7b2408909643717852b95f994b273fee)
+# DO NOT EDIT (digest: a3c674b4239234cbbe53afe090018954)
 
 SETUP = ocaml setup.ml
 
@@ -33,6 +33,9 @@
 setup.data:
 	$(SETUP) -configure $(CONFIGUREFLAGS)
 
+configure:
+	$(SETUP) -configure $(CONFIGUREFLAGS)
+
 .PHONY: build doc test all install uninstall reinstall clean distclean configure
 
 # OASIS_STOP
--- ./_tags
+++ ./_tags
@@ -1,8 +1,9 @@
 # OASIS_START
-# DO NOT EDIT (digest: 55b366f59702f11c8eef276a36f22281)
+# DO NOT EDIT (digest: 5068cc46f8b352e829418fe6413ec207)
 # Ignore VCS directories, you can use the same kind of rule outside
 # OASIS_START/STOP if you want to exclude directories that contains
 # useless stuff for the build process
+true: annot, bin_annot
 <**/.svn>: -traverse
 <**/.svn>: not_hygienic
 ".bzr": -traverse
--- ./myocamlbuild.ml
+++ ./myocamlbuild.ml
@@ -1,5 +1,5 @@
 (* OASIS_START *)
-(* DO NOT EDIT (digest: 00bd10ebfbafc22cc92e3bd778ce1be6) *)
+(* DO NOT EDIT (digest: a97bb9fbd93111fb7def72d01d35e460) *)
 module OASISGettext = struct
 (* # 22 "src/oasis/OASISGettext.ml" *)
 
@@ -39,10 +39,10 @@
   open OASISGettext
 
 
-  type test = string 
+  type test = string
 
 
-  type flag = string 
+  type flag = string
 
 
   type t =
@@ -52,10 +52,10 @@
     | EOr of t * t
     | EFlag of flag
     | ETest of test * string
-    
 
 
-  type 'a choices = (t * 'a) list 
+
+  type 'a choices = (t * 'a) list
 
 
   let eval var_get t =
@@ -204,26 +204,27 @@
       end
 
 
-  let var_get name env =
-    let rec var_expand str =
-      let buff =
-        Buffer.create ((String.length str) * 2)
-      in
-        Buffer.add_substitute
-          buff
-          (fun var ->
-             try
-               var_expand (MapString.find var env)
-             with Not_found ->
-               failwith
-                 (Printf.sprintf
-                    "No variable %s defined when trying to expand %S."
-                    var
-                    str))
-          str;
-        Buffer.contents buff
+  let rec var_expand str env =
+    let buff =
+      Buffer.create ((String.length str) * 2)
     in
-      var_expand (MapString.find name env)
+      Buffer.add_substitute
+        buff
+        (fun var ->
+           try
+             var_expand (MapString.find var env) env
+           with Not_found ->
+             failwith
+               (Printf.sprintf
+                  "No variable %s defined when trying to expand %S."
+                  var
+                  str))
+        str;
+      Buffer.contents buff
+
+
+  let var_get name env =
+    var_expand (MapString.find name env) env
 
 
   let var_choose lst env =
@@ -233,7 +234,7 @@
 end
 
 
-# 236 "myocamlbuild.ml"
+# 237 "myocamlbuild.ml"
 module MyOCamlbuildFindlib = struct
 (* # 22 "src/plugins/ocamlbuild/MyOCamlbuildFindlib.ml" *)
 
@@ -248,6 +249,9 @@
     *)
   open Ocamlbuild_plugin
 
+  type conf =
+    { no_automatic_syntax: bool;
+    }
 
   (* these functions are not really officially exported *)
   let run_and_read =
@@ -258,6 +262,31 @@
     Ocamlbuild_pack.Lexers.blank_sep_strings
 
 
+  let exec_from_conf exec =
+    let exec =
+      let env_filename = Pathname.basename BaseEnvLight.default_filename in
+      let env = BaseEnvLight.load ~filename:env_filename ~allow_empty:true () in
+      try
+        BaseEnvLight.var_get exec env
+      with Not_found ->
+        Printf.eprintf "W: Cannot get variable %s\n" exec;
+        exec
+    in
+    let fix_win32 str =
+      if Sys.os_type = "Win32" then begin
+        let buff = Buffer.create (String.length str) in
+        (* Adapt for windowsi, ocamlbuild + win32 has a hard time to handle '\\'.
+         *)
+        String.iter
+          (fun c -> Buffer.add_char buff (if c = '\\' then '/' else c))
+          str;
+        Buffer.contents buff
+      end else begin
+        str
+      end
+    in
+      fix_win32 exec
+
   let split s ch =
     let buf = Buffer.create 13 in
     let x = ref [] in
@@ -285,30 +314,38 @@
     with Not_found -> s
 
   (* ocamlfind command *)
-  let ocamlfind x =
-    let ocamlfind_prog =
-      let env_filename = Pathname.basename BaseEnvLight.default_filename in
-      let env = BaseEnvLight.load ~filename:env_filename ~allow_empty:true () in
-      try
-        BaseEnvLight.var_get "ocamlfind" env
-      with Not_found ->
-        Printf.eprintf "W: Cannot get variable ocamlfind";
-        "ocamlfind"
-    in
-      S[Sh ocamlfind_prog; x]
+  let ocamlfind x = S[Sh (
+    Ocamlbuild_pack.Shell.quote_filename_if_needed
+      (exec_from_conf "ocamlfind") ); x]
 
   (* This lists all supported packages. *)
   let find_packages () =
-    List.map before_space (split_nl & run_and_read "ocamlfind list")
+    List.map before_space (split_nl & run_and_read (exec_from_conf "ocamlfind" ^ " list"))
 
 
   (* Mock to list available syntaxes. *)
   let find_syntaxes () = ["camlp4o"; "camlp4r"]
 
 
-  let dispatch =
+  let well_known_syntax = [
+    "camlp4.quotations.o";
+    "camlp4.quotations.r";
+    "camlp4.exceptiontracer";
+    "camlp4.extend";
+    "camlp4.foldgenerator";
+    "camlp4.listcomprehension";
+    "camlp4.locationstripper";
+    "camlp4.macro";
+    "camlp4.mapgenerator";
+    "camlp4.metagenerator";
+    "camlp4.profiler";
+    "camlp4.tracer"
+  ]
+
+
+  let dispatch conf =
     function
-      | Before_options ->
+      | After_options ->
           (* By using Before_options one let command line options have an higher
            * priority on the contrary using After_options will guarantee to have
            * the higher priority override default commands by ocamlfind ones *)
@@ -325,27 +362,39 @@
            * -linkpkg *)
           flag ["ocaml"; "link"; "program"] & A"-linkpkg";
 
-          (* For each ocamlfind package one inject the -package option when
-           * compiling, computing dependencies, generating documentation and
-           * linking. *)
-          List.iter
-            begin fun pkg ->
-              let base_args = [A"-package"; A pkg] in
-              let syn_args = [A"-syntax"; A "camlp4o"] in
-              let args =
-          (* Heuristic to identify syntax extensions: whether they end in
-           * ".syntax"; some might not *)
-                if Filename.check_suffix pkg "syntax"
-                then syn_args @ base_args
-                else base_args
-              in
-              flag ["ocaml"; "compile";  "pkg_"^pkg] & S args;
-              flag ["ocaml"; "ocamldep"; "pkg_"^pkg] & S args;
-              flag ["ocaml"; "doc";      "pkg_"^pkg] & S args;
-              flag ["ocaml"; "link";     "pkg_"^pkg] & S base_args;
-              flag ["ocaml"; "infer_interface"; "pkg_"^pkg] & S args;
-            end
-            (find_packages ());
+          if not (conf.no_automatic_syntax) then begin
+            (* For each ocamlfind package one inject the -package option when
+             * compiling, computing dependencies, generating documentation and
+             * linking. *)
+            List.iter
+              begin fun pkg ->
+                let base_args = [A"-package"; A pkg] in
+                (* TODO: consider how to really choose camlp4o or camlp4r. *)
+                let syn_args = [A"-syntax"; A "camlp4o"] in
+                let (args, pargs) =
+                  (* Heuristic to identify syntax extensions: whether they end in
+                     ".syntax"; some might not.
+                  *)
+                  if Filename.check_suffix pkg "syntax" ||
+                     List.mem pkg well_known_syntax then
+                    (syn_args @ base_args, syn_args)
+                  else
+                    (base_args, [])
+                in
+                flag ["ocaml"; "compile";  "pkg_"^pkg] & S args;
+                flag ["ocaml"; "ocamldep"; "pkg_"^pkg] & S args;
+                flag ["ocaml"; "doc";      "pkg_"^pkg] & S args;
+                flag ["ocaml"; "link";     "pkg_"^pkg] & S base_args;
+                flag ["ocaml"; "infer_interface"; "pkg_"^pkg] & S args;
+
+                (* TODO: Check if this is allowed for OCaml < 3.12.1 *)
+                flag ["ocaml"; "compile";  "package("^pkg^")"] & S pargs;
+                flag ["ocaml"; "ocamldep"; "package("^pkg^")"] & S pargs;
+                flag ["ocaml"; "doc";      "package("^pkg^")"] & S pargs;
+                flag ["ocaml"; "infer_interface"; "package("^pkg^")"] & S pargs;
+              end
+              (find_packages ());
+          end;
 
           (* Like -package but for extensions syntax. Morover -syntax is useless
            * when linking. *)
@@ -394,10 +443,10 @@
   module OC = Ocamlbuild_pack.Ocaml_compiler
 
 
-  type dir = string 
-  type file = string 
-  type name = string 
-  type tag = string 
+  type dir = string
+  type file = string
+  type name = string
+  type tag = string
 
 
 (* # 62 "src/plugins/ocamlbuild/MyOCamlbuildBase.ml" *)
@@ -412,7 +461,7 @@
          * directory.
          *)
         includes:  (dir * dir list) list;
-      } 
+      }
 
 
   let env_filename =
@@ -455,7 +504,7 @@
                    try
                      opt := no_trailing_dot (BaseEnvLight.var_get var env)
                    with Not_found ->
-                     Printf.eprintf "W: Cannot get variable %s" var)
+                     Printf.eprintf "W: Cannot get variable %s\n" var)
                 [
                   Options.ext_obj, "ext_obj";
                   Options.ext_lib, "ext_lib";
@@ -510,12 +559,13 @@
 
                    (* When ocaml link something that use the C library, then one
                       need that file to be up to date.
+                      This holds both for programs and for libraries.
                     *)
-                   dep ["link"; "ocaml"; "program"; tag_libstubs lib]
-                     [dir/"lib"^(nm_libstubs lib)^"."^(!Options.ext_lib)];
+  		 dep ["link"; "ocaml"; tag_libstubs lib]
+  		     [dir/"lib"^(nm_libstubs lib)^"."^(!Options.ext_lib)];
 
-                   dep  ["compile"; "ocaml"; "program"; tag_libstubs lib]
-                     [dir/"lib"^(nm_libstubs lib)^"."^(!Options.ext_lib)];
+  		 dep  ["compile"; "ocaml"; tag_libstubs lib]
+  		      [dir/"lib"^(nm_libstubs lib)^"."^(!Options.ext_lib)];
 
                    (* TODO: be more specific about what depends on headers *)
                    (* Depends on .h files *)
@@ -531,27 +581,31 @@
               (* Add flags *)
               List.iter
               (fun (tags, cond_specs) ->
-                 let spec =
-                   BaseEnvLight.var_choose cond_specs env
+                 let spec = BaseEnvLight.var_choose cond_specs env in
+                 let rec eval_specs =
+                   function
+                     | S lst -> S (List.map eval_specs lst)
+                     | A str -> A (BaseEnvLight.var_expand str env)
+                     | spec -> spec
                  in
-                   flag tags & spec)
+                   flag tags & (eval_specs spec))
               t.flags
         | _ ->
             ()
 
 
-  let dispatch_default t =
+  let dispatch_default conf t =
     dispatch_combine
       [
         dispatch t;
-        MyOCamlbuildFindlib.dispatch;
+        MyOCamlbuildFindlib.dispatch conf;
       ]
 
 
 end
 
 
-# 554 "myocamlbuild.ml"
+# 608 "myocamlbuild.ml"
 open Ocamlbuild_plugin;;
 let package_default =
   {
@@ -562,8 +616,10 @@
   }
   ;;
 
-let dispatch_default = MyOCamlbuildBase.dispatch_default package_default;;
+let conf = {MyOCamlbuildFindlib.no_automatic_syntax = false}
+
+let dispatch_default = MyOCamlbuildBase.dispatch_default conf package_default;;
 
-# 568 "myocamlbuild.ml"
+# 624 "myocamlbuild.ml"
 (* OASIS_STOP *)
 Ocamlbuild_plugin.dispatch dispatch_default;;
--- ./setup.ml
+++ ./setup.ml
@@ -1,9 +1,9 @@
 (* setup.ml generated for the first time by OASIS v0.4.1 *)
 
 (* OASIS_START *)
-(* DO NOT EDIT (digest: c07787a9c41f584b90eadbb0b005a9c3) *)
+(* DO NOT EDIT (digest: d7c029aeb369103383d89aaa7c363aa4) *)
 (*
-   Regenerated by OASIS v0.4.1
+   Regenerated by OASIS v0.4.5
    Visit http://oasis.forge.ocamlcore.org for more information and
    documentation about functions used in this file.
 *)
@@ -52,6 +52,7 @@
 
   type t =
     {
+      (* TODO: replace this by a proplist. *)
       quiet:                 bool;
       info:                  bool;
       debug:                 bool;
@@ -88,19 +89,31 @@
     {!default with quiet = true}
 
 
-  let args () =
+  let fspecs () =
+    (* TODO: don't act on default. *)
+    let ignore_plugins = ref false in
     ["-quiet",
      Arg.Unit (fun () -> default := {!default with quiet = true}),
-     (s_ " Run quietly");
+     s_ " Run quietly";
 
      "-info",
      Arg.Unit (fun () -> default := {!default with info = true}),
-     (s_ " Display information message");
+     s_ " Display information message";
 
 
      "-debug",
      Arg.Unit (fun () -> default := {!default with debug = true}),
-     (s_ " Output debug message")]
+     s_ " Output debug message";
+
+     "-ignore-plugins",
+     Arg.Set ignore_plugins,
+     s_ " Ignore plugin's field.";
+
+     "-C",
+     (* TODO: remove this chdir. *)
+     Arg.String (fun str -> Sys.chdir str),
+     s_ "dir Change directory before running."],
+    fun () -> {!default with ignore_plugins = !ignore_plugins}
 end
 
 module OASISString = struct
@@ -229,12 +242,32 @@
 
 
   let replace_chars f s =
-    let buf = String.make (String.length s) 'X' in
-      for i = 0 to String.length s - 1 do
-        buf.[i] <- f s.[i]
-      done;
-      buf
+    let buf = Buffer.create (String.length s) in
+    String.iter (fun c -> Buffer.add_char buf (f c)) s;
+    Buffer.contents buf
+
+  (** Like List.exists, but for strings *)
+  let exists f str =
+    let rec iter i =
+      if i < 0 then
+        false
+      else if f str.[i] then
+        true
+      else
+        iter (pred i)
+    in
+      iter (String.length str - 1)
+
+  let is_digit c =
+    '0' <= c && c <= '9'
 
+  let is_alpha c =
+    ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')
+
+  let is_whitespace =
+    function
+      | ' ' | '\r' | '\n' | '\t' -> true
+      |  _  -> false
 
 end
 
@@ -245,29 +278,62 @@
   open OASISGettext
 
 
-  module MapString = Map.Make(String)
+  module MapExt =
+  struct
+    module type S =
+    sig
+      include Map.S
+      val add_list: 'a t -> (key * 'a) list -> 'a t
+      val of_list: (key * 'a) list -> 'a t
+      val to_list: 'a t -> (key * 'a) list
+    end
+
+    module Make (Ord: Map.OrderedType) =
+    struct
+      include Map.Make(Ord)
 
+      let rec add_list t =
+        function
+          | (k, v) :: tl -> add_list (add k v t) tl
+          | [] -> t
 
-  let map_string_of_assoc assoc =
-    List.fold_left
-      (fun acc (k, v) -> MapString.add k v acc)
-      MapString.empty
-      assoc
+      let of_list lst = add_list empty lst
 
+      let to_list t = fold (fun k v acc -> (k, v) :: acc) t []
+    end
+  end
 
-  module SetString = Set.Make(String)
 
+  module MapString = MapExt.Make(String)
 
-  let set_string_add_list st lst =
-    List.fold_left
-      (fun acc e -> SetString.add e acc)
-      st
-      lst
+
+  module SetExt  =
+  struct
+    module type S =
+    sig
+      include Set.S
+      val add_list: t -> elt list -> t
+      val of_list: elt list -> t
+      val to_list: t -> elt list
+    end
+
+    module Make (Ord: Set.OrderedType) =
+    struct
+      include Set.Make(Ord)
+
+      let rec add_list t =
+        function
+          | e :: tl -> add_list (add e t) tl
+          | [] -> t
+
+      let of_list lst = add_list empty lst
+
+      let to_list = elements
+    end
+  end
 
 
-  let set_string_of_list =
-    set_string_add_list
-      SetString.empty
+  module SetString = SetExt.Make(String)
 
 
   let compare_csl s1 s2 =
@@ -286,6 +352,13 @@
            Hashtbl.hash (String.lowercase s)
        end)
 
+  module SetStringCsl =
+    SetExt.Make
+      (struct
+         type t = string
+         let compare = compare_csl
+       end)
+
 
   let varname_of_string ?(hyphen='_') s =
     if String.length s = 0 then
@@ -686,7 +759,7 @@
   type s = string
 
 
-  type t = string 
+  type t = string
 
 
   type comparator =
@@ -697,16 +770,14 @@
     | VLesserEqual of t
     | VOr of  comparator * comparator
     | VAnd of comparator * comparator
-    
+
 
 
   (* Range of allowed characters *)
-  let is_digit c =
-    '0' <= c && c <= '9'
+  let is_digit = OASISString.is_digit
 
 
-  let is_alpha c =
-    ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')
+  let is_alpha = OASISString.is_alpha
 
 
   let is_special =
@@ -892,17 +963,17 @@
 
 
 
-  type license = string 
+  type license = string
 
 
-  type license_exception = string 
+  type license_exception = string
 
 
   type license_version =
     | Version of OASISVersion.t
     | VersionOrLater of OASISVersion.t
     | NoVersion
-    
+
 
 
   type license_dep_5_unit =
@@ -911,20 +982,19 @@
       excption:  license_exception option;
       version:   license_version;
     }
-    
+
 
 
   type license_dep_5 =
     | DEP5Unit of license_dep_5_unit
     | DEP5Or of license_dep_5 list
     | DEP5And of license_dep_5 list
-    
 
 
   type t =
     | DEP5License of license_dep_5
     | OtherLicense of string (* URL *)
-    
+
 
 
 end
@@ -939,10 +1009,10 @@
   open OASISGettext
 
 
-  type test = string 
+  type test = string
 
 
-  type flag = string 
+  type flag = string
 
 
   type t =
@@ -952,10 +1022,10 @@
     | EOr of t * t
     | EFlag of flag
     | ETest of test * string
-    
 
 
-  type 'a choices = (t * 'a) list 
+
+  type 'a choices = (t * 'a) list
 
 
   let eval var_get t =
@@ -1028,6 +1098,21 @@
 
 end
 
+module OASISText = struct
+(* # 22 "src/oasis/OASISText.ml" *)
+
+
+
+  type elt =
+    | Para of string
+    | Verbatim of string
+    | BlankLine
+
+
+  type t = elt list
+
+end
+
 module OASISTypes = struct
 (* # 22 "src/oasis/OASISTypes.ml" *)
 
@@ -1035,40 +1120,40 @@
 
 
 
-  type name          = string 
-  type package_name  = string 
-  type url           = string 
-  type unix_dirname  = string 
-  type unix_filename = string 
-  type host_dirname  = string 
-  type host_filename = string 
-  type prog          = string 
-  type arg           = string 
-  type args          = string list 
-  type command_line  = (prog * arg list) 
+  type name          = string
+  type package_name  = string
+  type url           = string
+  type unix_dirname  = string
+  type unix_filename = string
+  type host_dirname  = string
+  type host_filename = string
+  type prog          = string
+  type arg           = string
+  type args          = string list
+  type command_line  = (prog * arg list)
 
 
-  type findlib_name = string 
-  type findlib_full = string 
+  type findlib_name = string
+  type findlib_full = string
 
 
   type compiled_object =
     | Byte
     | Native
     | Best
-    
+
 
 
   type dependency =
     | FindlibPackage of findlib_full * OASISVersion.comparator option
     | InternalLibrary of name
-    
+
 
 
   type tool =
     | ExternalTool of name
     | InternalExecutable of name
-    
+
 
 
   type vcs =
@@ -1081,7 +1166,7 @@
     | Arch
     | Monotone
     | OtherVCS of url
-    
+
 
 
   type plugin_kind =
@@ -1109,7 +1194,7 @@
       ]
 
 
-  type 'a plugin = 'a * name * OASISVersion.t option 
+  type 'a plugin = 'a * name * OASISVersion.t option
 
 
   type all_plugin = plugin_kind plugin
@@ -1121,7 +1206,7 @@
 (* # 115 "src/oasis/OASISTypes.ml" *)
 
 
-  type 'a conditional = 'a OASISExpr.choices 
+  type 'a conditional = 'a OASISExpr.choices
 
 
   type custom =
@@ -1129,7 +1214,7 @@
         pre_command:  (command_line option) conditional;
         post_command: (command_line option) conditional;
       }
-      
+
 
 
   type common_section =
@@ -1138,7 +1223,7 @@
         cs_data: PropList.Data.t;
         cs_plugin_data: plugin_data;
       }
-      
+
 
 
   type build_section =
@@ -1158,7 +1243,7 @@
         bs_byteopt:         args conditional;
         bs_nativeopt:       args conditional;
       }
-      
+
 
 
   type library =
@@ -1169,28 +1254,28 @@
         lib_findlib_parent:     findlib_name option;
         lib_findlib_name:       findlib_name option;
         lib_findlib_containers: findlib_name list;
-      } 
+      }
 
 
   type object_ =
       {
         obj_modules:            string list;
         obj_findlib_fullname:   findlib_name list option;
-      } 
+      }
 
 
   type executable =
       {
         exec_custom:          bool;
         exec_main_is:         unix_filename;
-      } 
+      }
 
 
   type flag =
       {
         flag_description:  string option;
         flag_default:      bool conditional;
-      } 
+      }
 
 
   type source_repository =
@@ -1202,7 +1287,7 @@
         src_repo_branch:      string option;
         src_repo_tag:         string option;
         src_repo_subdir:      unix_filename option;
-      } 
+      }
 
 
   type test =
@@ -1213,7 +1298,7 @@
         test_working_directory:  unix_filename option;
         test_run:                bool conditional;
         test_tools:              tool list;
-      } 
+      }
 
 
   type doc_format =
@@ -1224,7 +1309,7 @@
     | Info of unix_filename
     | DVI
     | OtherDoc
-    
+
 
 
   type doc =
@@ -1240,7 +1325,7 @@
         doc_format:      doc_format;
         doc_data_files:  (unix_filename * unix_filename option) list;
         doc_build_tools: tool list;
-      } 
+      }
 
 
   type section =
@@ -1251,7 +1336,7 @@
     | SrcRepo    of common_section * source_repository
     | Test       of common_section * test
     | Doc        of common_section * doc
-    
+
 
 
   type section_kind =
@@ -1260,42 +1345,43 @@
 
   type package =
       {
-        oasis_version:    OASISVersion.t;
-        ocaml_version:    OASISVersion.comparator option;
-        findlib_version:  OASISVersion.comparator option;
-        alpha_features:   string list;
-        beta_features:    string list;
-        name:             package_name;
-        version:          OASISVersion.t;
-        license:          OASISLicense.t;
-        license_file:     unix_filename option;
-        copyrights:       string list;
-        maintainers:      string list;
-        authors:          string list;
-        homepage:         url option;
-        synopsis:         string;
-        description:      string option;
-        categories:       url list;
-
-        conf_type:        [`Configure] plugin;
-        conf_custom:      custom;
-
-        build_type:       [`Build] plugin;
-        build_custom:     custom;
-
-        install_type:     [`Install] plugin;
-        install_custom:   custom;
-        uninstall_custom: custom;
-
-        clean_custom:     custom;
-        distclean_custom: custom;
-
-        files_ab:         unix_filename list;
-        sections:         section list;
-        plugins:          [`Extra] plugin list;
-        schema_data:      PropList.Data.t;
-        plugin_data:      plugin_data;
-      } 
+        oasis_version:          OASISVersion.t;
+        ocaml_version:          OASISVersion.comparator option;
+        findlib_version:        OASISVersion.comparator option;
+        alpha_features:         string list;
+        beta_features:          string list;
+        name:                   package_name;
+        version:                OASISVersion.t;
+        license:                OASISLicense.t;
+        license_file:           unix_filename option;
+        copyrights:             string list;
+        maintainers:            string list;
+        authors:                string list;
+        homepage:               url option;
+        synopsis:               string;
+        description:            OASISText.t option;
+        categories:             url list;
+
+        conf_type:              [`Configure] plugin;
+        conf_custom:            custom;
+
+        build_type:             [`Build] plugin;
+        build_custom:           custom;
+
+        install_type:           [`Install] plugin;
+        install_custom:         custom;
+        uninstall_custom:       custom;
+
+        clean_custom:           custom;
+        distclean_custom:       custom;
+
+        files_ab:               unix_filename list;
+        sections:               section list;
+        plugins:                [`Extra] plugin list;
+        disable_oasis_section:  unix_filename list;
+        schema_data:            PropList.Data.t;
+        plugin_data:            plugin_data;
+      }
 
 
 end
@@ -1348,6 +1434,24 @@
 
     let plugin_version plugin_kind plugin_name t =
       MapPlugin.find (plugin_kind, plugin_name) t.plugin_versions
+
+    let to_string t =
+      Printf.sprintf
+        "oasis_version: %s; alpha_features: %s; beta_features: %s; \
+         plugins_version: %s"
+        (OASISVersion.string_of_version t.oasis_version)
+        (String.concat ", " t.alpha_features)
+        (String.concat ", " t.beta_features)
+        (String.concat ", "
+           (MapPlugin.fold
+              (fun (_, plg) ver_opt acc ->
+                 (plg^
+                  (match ver_opt with
+                     | Some v ->
+                         " "^(OASISVersion.string_of_version v)
+                     | None -> ""))
+                 :: acc)
+              t.plugin_versions []))
   end
 
   type origin =
@@ -1388,6 +1492,17 @@
   let beta = InDev Beta
 
 
+  let to_string t =
+    Printf.sprintf
+      "feature: %s; plugin: %s; publication: %s"
+      t.name
+      (match t.plugin with
+         | None -> "<none>"
+         | Some (_, nm, _) -> nm)
+      (match t.publication with
+         | InDev stage -> string_of_stage stage
+         | SinceVersion ver -> ">= "^(OASISVersion.string_of_version ver))
+
   let data_check t data origin =
     let no_message = "no message" in
 
@@ -1620,6 +1735,25 @@
     create "dynrun_for_release" alpha
       (fun () ->
          s_ "Make '-setup-update dynamic' suitable for releasing project.")
+
+
+  let compiled_setup_ml =
+    create "compiled_setup_ml" alpha
+      (fun () ->
+         s_ "It compiles the setup.ml and speed-up actions done with it.")
+
+  let disable_oasis_section =
+    create "disable_oasis_section" alpha
+      (fun () ->
+        s_ "Allows the OASIS section comments and digest to be omitted in \
+            generated files.")
+
+  let no_automatic_syntax =
+    create "no_automatic_syntax" alpha
+      (fun () ->
+         s_ "Disable the automatic inclusion of -syntax camlp4o for packages \
+             that matches the internal heuristic (if a dependency ends with \
+             a .syntax or is a well known syntax).")
 end
 
 module OASISUnixPath = struct
@@ -1728,6 +1862,118 @@
 
   module Unix = OASISUnixPath
 
+  let bash_cmd = ref ( fun () -> "" )
+
+  let use_bash () = ( !bash_cmd () ) <> ""
+
+
+  (* generic quote and unixquote are taken from ocaml source *)
+  let generic_quote quotequote s =
+    let l = String.length s in
+    let b = Buffer.create (l + 20) in
+      Buffer.add_char b '\'';
+      for i = 0 to l - 1 do
+        if s.[i] = '\'' then
+          Buffer.add_string b quotequote
+        else
+          Buffer.add_char b  s.[i]
+      done;
+      Buffer.add_char b '\'';
+      Buffer.contents b
+
+  let unixquote = generic_quote "'\\''"
+
+  let win = Sys.os_type = "Win32"
+
+  let quote str =
+    if win && use_bash () then
+      unixquote str
+    else
+      quote str
+
+  (* uniform_path (only called, if Sys.os_type = "Win32")
+   * - enforces uniform path seperators
+   * - strips trailing slashes (exceptions in case of C:\ and / )
+   * - removes (some) unnecessary file components like ./././
+   *)
+
+  let get_naccu accu str first pos =
+    (* I assume c//d is identic to c/d
+     * the only exception (Network devices \\xyz\asdf)
+     * is covered in uniform_path
+     *)
+    if first = pos then
+      accu
+    else
+      let nlen = pos - first in
+      let nstr = String.sub str first nlen in
+        (* test/././ is the same as test *)
+        if nlen = 1 && nstr = "." then
+          accu
+        (* a/b/../ is the same as a *)
+        else if nlen = 2 && nstr = ".." then
+          match accu with
+            | []      -> [ nstr ]
+            | ".."::_ -> nstr::accu
+            | hd::tl  -> tl
+        else
+          nstr::accu
+
+  let is_path_sep = function
+    | '\\' | '/' -> true
+    | _ -> false
+
+
+  let uniform_path path_sep = function
+    | "" -> "" (* Raise an exception? Or an possible intermediate result?
+               * Filename.basename and dirname also don't raise exceptions *)
+    | str ->
+        let rec iter accu str len first pos =
+          if pos >= len then
+            List.rev (get_naccu accu str first pos)
+          else
+            let next = succ pos in
+              match is_path_sep str.[pos] with
+                | true -> iter (get_naccu accu str first pos) str len next next
+                | false -> iter accu str len first next
+        in
+          let is_unix_root = is_path_sep str.[0] in
+          let len = String.length str in
+          let next_sep = len > 1 && is_path_sep str.[1] in
+          let is_network_root = is_unix_root && next_sep in
+          let is_currel = str.[0] = '.' && ( next_sep || len = 1 ) in
+          let l = iter [] str len 0 0 in
+          (* Trailing slashes are normally stripped.
+           * This is not possible in case of root folders
+           * Sys.file_exists "C:" is false, Sys.file_exists "C:\\" true
+           *)
+          let l_min =
+            match l with
+              | [] -> [ "" ]
+              | _ -> l
+          in
+          let l =
+            if is_network_root then
+              ""::""::l_min
+            else if is_unix_root then
+              ""::l_min
+            else if is_currel then
+              "."::l
+            else
+              match l with
+                | s :: [] ->
+                    (* root folders like C:\ *)
+                    if String.length s = 2 && s.[1] = ':' &&
+                      len > 2 && is_path_sep str.[2]
+                    then
+                      s :: [ "" ]
+                    else
+                      l
+                | _ -> l
+          in
+            String.concat path_sep l
+
+
 
   let make =
     function
@@ -1737,20 +1983,32 @@
           List.fold_left Filename.concat hd tl
 
 
-  let of_unix ufn =
-    if Sys.os_type = "Unix" then
-      ufn
+  let of_unix str =
+    if win = false then
+      str
     else
-      make
-        (List.map
-           (fun p ->
-              if p = Unix.current_dir_name then
-                current_dir_name
-              else if p = Unix.parent_dir_name then
-                parent_dir_name
+      let path_sep =
+        if use_bash () then
+          "/"
               else
-                p)
-           (OASISString.nsplit ufn '/'))
+          "\\"
+      in
+        uniform_path path_sep str
+
+
+
+  (* see findlib's src/findlib/frontend.ml for details *)
+  let ocamlfind_unquote dir =
+    match Sys.os_type with
+      | "Cygwin"
+      | "Win32" ->
+        let len = String.length dir in
+          if len < 3 || dir.[0] <> '"' || dir.[len - 1] <> '"' ||
+            String.contains dir ' ' = false then
+            dir
+              else
+            String.sub dir 1 (len - 2)
+      | _ -> dir
 
 
 end
@@ -1990,16 +2248,6 @@
         lst
     in
 
-    (* The headers that should be compiled along *)
-    let headers =
-      if lib.lib_pack then
-        []
-      else
-        find_modules
-          lib.lib_modules
-          "cmi"
-    in
-
     (* The .cmx that be compiled along *)
     let cmxs =
       let should_be_built =
@@ -2025,12 +2273,32 @@
       []
     in
 
+    (* The headers and annot/cmt files that should be compiled along *)
+    let headers =
+      let sufx =
+        if lib.lib_pack
+        then [".cmti"; ".cmt"; ".annot"]
+        else [".cmi"; ".cmti"; ".cmt"; ".annot"]
+      in
+      List.map
+        begin
+          List.fold_left
+            begin fun accu s ->
+              let dot = String.rindex s '.' in
+              let base = String.sub s 0 dot in
+              List.map ((^) base) sufx @ accu
+            end
+            []
+        end
+        (find_modules lib.lib_modules "cmi")
+    in
+
     (* Compute what libraries should be built *)
     let acc_nopath =
       (* Add the packed header file if required *)
       let add_pack_header acc =
         if lib.lib_pack then
-          [cs.cs_name^".cmi"] :: acc
+          [cs.cs_name^".cmi"; cs.cs_name^".cmti"; cs.cs_name^".cmt"] :: acc
         else
           acc
       in
@@ -2390,13 +2658,13 @@
     in
 
     let library_name_of_findlib_name =
-      Lazy.lazy_from_fun
-        (fun () ->
-           (* Revert findlib_name_of_library_name. *)
-           MapString.fold
-             (fun k v mp -> MapString.add v k mp)
-             fndlb_name_of_lib_name
-             MapString.empty)
+      lazy begin
+        (* Revert findlib_name_of_library_name. *)
+        MapString.fold
+          (fun k v mp -> MapString.add v k mp)
+          fndlb_name_of_lib_name
+          MapString.empty
+      end
     in
     let library_name_of_findlib_name fndlb_nm =
       try
@@ -2482,25 +2750,221 @@
   open OASISMessage
 
 
+
+
+  (* In general, there is no chance to quote properly with the current
+   * settings. ( This is only a problem, if BaseCustom.run is used (e.g
+   * test commands, PreConfigure,....). Most of the time, OASISExec.run
+   * is used with enabled quoting.)
+   *
+   * "$rm" should ideally expand to 'rm -f' (no quotes), but "$test_exec"
+   * should ideally expand to '"C:\Program Files\dir\test.exe"' (with
+   * quotes). Paths with spaces are common on Windows, so this problem
+   * can't be ignored.
+   *
+   * Using a command with additional parameters is quite useful, not only
+   * for trivial cases like $rm. You could add an additional parameter
+   * for $make in order to use a special compatibility mode, on windows
+   * you can use it to inform ocaml that a certain program is a shell
+   * script ('sh.exe pcre-config').
+   *
+   * An additional parameter (e.g. $rm_switches) would be ugly,
+   * especially for *nix users, who don't use space characters in their
+   * installation paths anyway.
+   *
+   * I use the following workaround, which should work most of the time:
+   *
+   * - if cmd doesn't contains spaces or other suspicious characters, it
+   * can be quoted in the usual way (not ambigous, I think)
+   *
+   * - if cmd does contain spaces, a file with this name exists, and the
+   * beginning of cmd looks like a absolute pathname
+   * ('\\test\dir\foo.exe' or "C:\\sa df\\foo.exe" - not "foo.exe" ), I
+   * will also quote it. (ambigous, there could be "C:\bin\rm.exe" and
+   * "C:\bin\rm -f.exe").  Relative filenames are not considered, because
+   * I assume the source code folder contains only well named files and
+   * relative paths like "../../make.exe" are uncommon (autoconf even
+   * rejects them) *)
+
+
+  (* stricter settings as for regular windows batch lines
+   * necessary because of shell comannds like:
+   *   LC_ALL=C make ....
+   *)
+  let is_dubious_char = function
+    | '+' | '~' | ':' | '.' | '-' | '_' | '/' | '\\' -> false
+    | c ->
+      OASISString.is_digit c = false &&
+      OASISString.is_alpha c = false
+
+
+  let win_quote_needed str =
+    let f = function
+      (* this list is not exhaustive. Feel free to added common chars, that
+       * can be passed to cmd.exe without quoting *)
+      | 'a' .. 'z'  | 'A' .. 'Z' | '0' .. '9'
+      | '_' | '-' | '~' | '.' | ':' | ',' | '\\' -> false
+      | _ -> true
+    in
+      str = "" || OASISString.exists f str
+
+  let is_simple_command str =
+    String.length str > 0 &&
+    not (OASISString.exists is_dubious_char str)
+
+  let is_path_sep = function
+    | '/' | '\\' -> true
+    | _ -> false
+
+  let starts_with_absolute_path cmd =
+    let len = String.length cmd in
+      if len < 3 then
+        false
+      else
+        let c0 = cmd.[0] in
+        let c1 = cmd.[1] in
+          if is_path_sep c0 && is_path_sep c1 then (* network devices: "//" *)
+            true
+          else if len = 3 then
+            false
+          else  (* C:\.... *)
+            OASISString.is_alpha c0 && c1 = ':' && is_path_sep cmd.[2]
+
+  let exe_exts = lazy
+    begin
+      let exts =
+        try
+          OASISString.nsplit
+            (Sys.getenv "PATHEXT")
+            ';'
+        with
+          | Not_found -> []
+      in
+      let exts' =
+        List.filter
+          ( fun a -> a <> "" && a.[0] = '.' && a <> ".exe" )
+          (List.map String.lowercase exts) (* windows file system doesn't care *)
+      in
+        ".exe"::exts' (* .exe first, most common *)
+    end
+
+  let exe_file_exists fln =
+    Sys.file_exists fln ||
+    List.exists
+      (fun a -> Sys.file_exists ( fln ^ a ) )
+      (Lazy.force exe_exts)
+
+
+  let quote_anyway cmd =
+    if Sys.os_type <> "Win32" then (* workaround for windows only *)
+      false
+    else if is_simple_command cmd then
+      true
+    else
+      OASISString.exists OASISString.is_whitespace cmd &&
+        starts_with_absolute_path cmd &&
+        exe_file_exists cmd
+
+
+  let run_bash ~ctxt ?f_exit_code ?(quote=true) cmd args =
+    let fn = Filename.temp_file "oasis-" ".sh" in
+    let fn_deleted = ref false in
+      try
+        begin
+          let ch = open_out_bin fn in
+          let ch_closed = ref false in
+            try
+              begin
+                let cmd =
+                  if quote || quote_anyway cmd then
+                    OASISHostPath.quote (OASISHostPath.of_unix cmd)
+                  else
+                    cmd
+                in
+                  output_string ch cmd;
+                  List.iter
+                    ( fun s -> output_char ch ' '; output_string ch s )
+                    args ;
+                  output_char ch '\n';
+                  ch_closed:=true ;
+                  close_out ch;
+                  let bash = !OASISHostPath.bash_cmd () in
+                  let add_quotes = ref false in
+                  let shell_cmd =
+                    if Sys.os_type <> "Win32" then
+                      Filename.quote bash
+                    else
+                      if win_quote_needed bash = false then
+                        bash
+                      else
+                        begin
+                          add_quotes := true;
+                          Filename.quote bash
+                        end
+                  in
+                  let cmdline_orig = String.concat " " (cmd :: args) in
+                  let cmdline =
+                    let s = shell_cmd ^ " " ^ (Filename.quote fn) in
+                      if !add_quotes then
+                        "\"" ^ s ^ "\""
+                      else
+                        s
+                  in
+                    info ~ctxt (f_ "Running command '%s'") cmdline_orig;
+                    let ret = Sys.command cmdline in
+                      fn_deleted := true;
+                      Sys.remove fn;
+                      match f_exit_code, ret with
+                        | None, 0 -> ()
+                        | None, i ->
+                            failwithf
+                              (f_ "Command '%s' terminated with error code %d")
+                              cmdline_orig i
+                        | Some f, i ->
+                            f i
+              end
+            with
+              | x when !ch_closed = false ->
+                  close_out_noerr ch;
+                  raise x
+        end
+      with
+        | x when !fn_deleted = false ->
+            (try Sys.remove fn with _ -> () ) ;
+            raise x
+
   (* TODO: I don't like this quote, it is there because $(rm) foo expands to
    * 'rm -f' foo...
    *)
-  let run ~ctxt ?f_exit_code ?(quote=true) cmd args =
+
+  let run_default ~ctxt ?f_exit_code ?(quote=true) cmd args =
+    let add_quotes = ref false in
     let cmd =
-      if quote then
+      if quote || quote_anyway cmd then
         if Sys.os_type = "Win32" then
-          if String.contains cmd ' ' then
-            (* Double the 1st double quote... win32... sigh *)
-            "\""^(Filename.quote cmd)
-          else
+          begin
+            if win_quote_needed cmd = false then
             cmd
         else
+              begin
+                (* Double the 1st double quote... win32... sigh *)
+                (* Above comment ist false. The whole string must be quoted.
+                 * However, an error is only triggered, if args contains also
+                 * quoted parameters *)
+                add_quotes := true;
+                Filename.quote cmd
+              end
+          end
+        else
           Filename.quote cmd
       else
         cmd
     in
     let cmdline =
-      String.concat " " (cmd :: args)
+      let s = String.concat " " (cmd :: args) in
+        match !add_quotes with
+          | true -> "\"" ^ s ^ "\""
+          | false -> s
     in
       info ~ctxt (f_ "Running command '%s'") cmdline;
       match f_exit_code, Sys.command cmdline with
@@ -2513,6 +2977,13 @@
             f i
 
 
+
+  let run ~ctxt ?f_exit_code ?quote cmd args =
+    if OASISHostPath.use_bash () then
+      run_bash ~ctxt ?f_exit_code ?quote cmd args
+    else
+      run_default ~ctxt ?f_exit_code ?quote cmd args
+
   let run_read_output ~ctxt ?f_exit_code cmd args =
     let fn =
       Filename.temp_file "oasis-" ".txt"
@@ -2622,7 +3093,7 @@
       ) alternatives
 
 
-  let which ~ctxt prg =
+  let which ?(plain=false) ?ctxt prg =
     let path_sep =
       match Sys.os_type with
         | "Win32" ->
@@ -2634,11 +3105,17 @@
     let exec_ext =
       match Sys.os_type with
         | "Win32" ->
-            "" :: (OASISString.nsplit (Sys.getenv "PATHEXT") path_sep)
+            "" :: (List.map String.lowercase (OASISString.nsplit (Sys.getenv "PATHEXT") path_sep))
         | _ ->
             [""]
     in
+    let p =
       find_file ~case_sensitive:false [path_lst; [prg]] exec_ext
+    in
+    if plain then
+      p
+    else
+      OASISHostPath.of_unix p
 
 
   (**/**)
@@ -2655,32 +3132,55 @@
         dn
 
 
-  let q = Filename.quote
+  let q s = OASISHostPath.quote (OASISHostPath.of_unix s)
   (**/**)
 
 
   let cp ~ctxt ?(recurse=false) src tgt =
     if recurse then
-      match Sys.os_type with
-        | "Win32" ->
-            OASISExec.run ~ctxt
-              "xcopy" [q src; q tgt; "/E"]
-        | _ ->
-            OASISExec.run ~ctxt
-              "cp" ["-r"; q src; q tgt]
+      (*
+        'xcopy /E' and 'cp -r' don't have the same semantic!
+        -dir2 does exist:
+          xcopy dir dir2 /E -> copys content of dir into dir2 (dir2/dir doesn't exist!)
+          cp -r dir dir2    -> copys dir to dir2 (dir2/dir does exist!)
+        -dir2 doesn't exist:
+          xcopy dir dir2 /E -> request on command line, if dir2 is an directory or file.
+          cp -r dir dir2    -> dir and dir2 have the same content (dir2/dir doesn't exist)
+        Probably, there are even more differences,....
+      *)
+      if Sys.os_type = "Win32" && OASISHostPath.use_bash () = false then
+        let tgt_real =
+          if Sys.file_exists tgt = false then
+            begin
+              OASISExec.run ~ctxt "md" [q tgt];
+              tgt
+            end
+    else
+            let base = Filename.basename src in
+            if base = "." then
+              tgt
+            else
+              let tgt_real = Filename.concat tgt base in
+                if Sys.file_exists tgt_real = false then
+                  OASISExec.run ~ctxt "md" [q tgt_real];
+              tgt_real
+        in
+        OASISExec.run ~ctxt "xcopy" [q src; q tgt_real; "/E" ; "/Q" ; "/Y"]
+      else
+        OASISExec.run ~ctxt "cp" ["-r"; q src; q tgt]
     else
-      OASISExec.run ~ctxt
-        (match Sys.os_type with
-         | "Win32" -> "copy"
-         | _ -> "cp")
-        [q src; q tgt]
+      if Sys.os_type = "Win32" && OASISHostPath.use_bash () = false then
+        OASISExec.run ~ctxt "copy" [q src; q tgt ; "/Y"]
+      else
+        OASISExec.run ~ctxt "cp" [q src; q tgt]
 
 
   let mkdir ~ctxt tgt =
     OASISExec.run ~ctxt
-      (match Sys.os_type with
-         | "Win32" -> "md"
-         | _ -> "mkdir")
+      ( if Sys.os_type = "Win32" && not (OASISHostPath.use_bash ()) then
+          "md"
+        else
+          "mkdir" )
       [q tgt]
 
 
@@ -2708,14 +3208,16 @@
 
 
   let rmdir ~ctxt tgt =
-    if Sys.readdir tgt = [||] then
-      begin
-        match Sys.os_type with
-          | "Win32" ->
-              OASISExec.run ~ctxt "rd" [q tgt]
-          | _ ->
-              OASISExec.run ~ctxt "rm" ["-r"; q tgt]
-      end
+    if Sys.readdir tgt = [||] then begin
+      if Sys.os_type = "Win32" && OASISHostPath.use_bash () = false then
+            OASISExec.run ~ctxt "rd" [q tgt]
+      else
+            OASISExec.run ~ctxt "rm" ["-r"; q tgt]
+    end else begin
+      OASISMessage.error ~ctxt
+        (f_ "Cannot remove directory '%s': not empty.")
+        tgt
+    end
 
 
   let glob ~ctxt fn =
@@ -2763,7 +3265,7 @@
 end
 
 
-# 2766 "setup.ml"
+# 3268 "setup.ml"
 module BaseEnvLight = struct
 (* # 22 "src/base/BaseEnvLight.ml" *)
 
@@ -2838,26 +3340,27 @@
       end
 
 
-  let var_get name env =
-    let rec var_expand str =
-      let buff =
-        Buffer.create ((String.length str) * 2)
-      in
-        Buffer.add_substitute
-          buff
-          (fun var ->
-             try
-               var_expand (MapString.find var env)
-             with Not_found ->
-               failwith
-                 (Printf.sprintf
-                    "No variable %s defined when trying to expand %S."
-                    var
-                    str))
-          str;
-        Buffer.contents buff
+  let rec var_expand str env =
+    let buff =
+      Buffer.create ((String.length str) * 2)
     in
-      var_expand (MapString.find name env)
+      Buffer.add_substitute
+        buff
+        (fun var ->
+           try
+             var_expand (MapString.find var env) env
+           with Not_found ->
+             failwith
+               (Printf.sprintf
+                  "No variable %s defined when trying to expand %S."
+                  var
+                  str))
+        str;
+      Buffer.contents buff
+
+
+  let var_get name env =
+    var_expand (MapString.find name env) env
 
 
   let var_choose lst env =
@@ -2867,15 +3370,15 @@
 end
 
 
-# 2870 "setup.ml"
+# 3373 "setup.ml"
 module BaseContext = struct
 (* # 22 "src/base/BaseContext.ml" *)
 
-
+  (* TODO: get rid of this module. *)
   open OASISContext
 
 
-  let args = args
+  let args () = fst (fspecs ())
 
 
   let default = default
@@ -2961,7 +3464,7 @@
     Genlex.make_lexer []
 
 
-  let rec var_expand str =
+  let rec var_expand ?(quoted=false) str =
     let buff =
       Buffer.create ((String.length str) * 2)
     in
@@ -2989,7 +3492,11 @@
                  | [Genlex.Ident "ocaml_escaped"; Genlex.String s] ->
                      String.escaped s
                  | [Genlex.Ident nm] ->
-                     var_get nm
+                     let s = var_get nm in
+                     if quoted then
+                       OASISHostPath.quote s
+                     else
+                       s
                  | _ ->
                      failwithf
                        (f_ "Unknown expression '%s' in variable expansion of %s.")
@@ -3519,9 +4026,11 @@
     in
     let findlib_dir pkg =
       let dir =
+        OASISHostPath.of_unix (
+          OASISHostPath.ocamlfind_unquote (
         OASISExec.run_read_one_line ~ctxt:!BaseContext.default
           (ocamlfind ())
-          ["query"; "-format"; "%d"; pkg]
+              ["query"; "-format"; "%d"; pkg] ) )
       in
         if Sys.file_exists dir && Sys.is_directory dir then
           dir
@@ -3651,6 +4160,9 @@
       match nm with
         | "ocaml_version" ->
             "version", chop_version_suffix
+        | "standard_library"
+        | "standard_library_default" ->
+            nm, ( fun x -> OASISHostPath.of_unix x)
         | _ -> nm, (fun x -> x)
     in
       var_redefine
@@ -3791,14 +4303,43 @@
 
 
   let (/) a b =
-    if os_type () = Sys.os_type then
+    let os = os_type () in
+      if os = Sys.os_type then
+        if Sys.os_type = "Win32" && OASISHostPath.use_bash () then
+          OASISUnixPath.concat a b
+        else
       Filename.concat a b
-    else if os_type () = "Unix" then
+      else if os = "Unix" then
       OASISUnixPath.concat a b
     else
       OASISUtils.failwithf (f_ "Cannot handle os_type %s filename concat")
         (os_type ())
   (**/**)
+  let auto_bash =
+    lazy (
+      try
+        OASISFileUtil.which ~plain:true "dash"
+      with
+      | Not_found | Sys_error _ ->
+        try
+          OASISFileUtil.which ~plain:true "bash"
+        with
+        | Not_found | Sys_error _ -> "" )
+
+  let auto_bash () =
+    if Sys.os_type <> "Win32" then
+      ""
+    else
+      Lazy.force auto_bash
+
+
+  let bash_cmd =
+    var_define
+      ~short_desc:(fun () -> s_ "Enforced bash shell:")
+      ~cli:CLIAuto
+      ~arg_help:"program"
+      "use_bash"
+      auto_bash
 
 
   let prefix =
@@ -3807,10 +4348,30 @@
       (fun () ->
          match os_type () with
            | "Win32" ->
+               let getenv w =
+                 try
+                   Some(Sys.getenv w)
+                 with
+                   | Not_found -> None
+               in
+               let s =
+                 if Sys.word_size = 64 then
+                   getenv "ProgramW6432"
+                 else
+                   None
+               in
+               let s =
+                 if s = None then
+                   getenv "PROGRAMFILES"
+                 else
+                   s
+               in
                let program_files =
-                 Sys.getenv "PROGRAMFILES"
+                 match s with
+                   | None -> "C:\\Program Files"
+                   | Some x -> x
                in
-                 program_files/(pkg_name ())
+                 OASISHostPath.of_unix (program_files/(pkg_name ()))
            | _ ->
                "/usr/local")
 
@@ -3896,7 +4457,15 @@
   let docdir =
     p "docdir"
       (fun () -> s_ "Documentation root")
-      (fun () -> "$datarootdir"/"doc"/"$pkg_name")
+      (fun () ->
+        (* TODO: (Windows only?) "$pkg_name" is not always substituted
+         * (at least if datarootdir contains spaces or other garbage)
+         * I haven't looked up why.
+         *)
+        match os_type () with
+          | "Win32" -> "$datarootdir"/"doc"/ ( pkg_name () )
+          | _ -> "$datarootdir"/"doc"/"$pkg_name"
+      )
 
 
   let htmldir =
@@ -3970,9 +4539,10 @@
       ~short_desc:(fun () -> s_ "Remove a file.")
       "rm"
       (fun () ->
-         match os_type () with
-           | "Win32" -> "del"
-           | _ -> "rm -f")
+         if not (OASISHostPath.use_bash ()) && os_type () = "Win32" then
+           "del"
+         else
+           "rm -f" )
 
 
   let rmdir =
@@ -3980,9 +4550,10 @@
       ~short_desc:(fun () -> s_ "Remove a directory.")
       "rmdir"
       (fun () ->
-         match os_type () with
-           | "Win32" -> "rd"
-           | _ -> "rm -rf")
+         if not (OASISHostPath.use_bash ()) && os_type () = "Win32" then
+           "rd"
+         else
+           "rm -rf")
 
 
   let debug =
@@ -4046,14 +4617,29 @@
            let has_native_dynlink =
              let ocamlfind = ocamlfind () in
                try
-                 let fn =
+                 (* -format %d/%a doesn't work, because ocamlfind quotes %d
+                  * and %a separatly *)
+                 let fn1 =
+                   OASISHostPath.ocamlfind_unquote (
+                     OASISExec.run_read_one_line
+                       ~ctxt:!BaseContext.default
+                       ocamlfind
+                       ["query"; "-predicates"; "native"; "dynlink";
+                        "-format"; "%d"] )
+                 in
+                 let fn2 =
+                   OASISHostPath.ocamlfind_unquote (
                    OASISExec.run_read_one_line
                      ~ctxt:!BaseContext.default
                      ocamlfind
                      ["query"; "-predicates"; "native"; "dynlink";
-                      "-format"; "%d/%a"]
+                        "-format"; "%a"] )
                  in
-                   Sys.file_exists fn
+                   if fn1 <> "" && fn2 <> "" &&
+                     Sys.file_exists (Filename.concat fn1 fn2) then
+                     true
+                   else
+                     false
                with _ ->
                  false
            in
@@ -4080,6 +4666,8 @@
     rpkg := Some pkg;
     List.iter (fun f -> f pkg.oasis_version) !var_cond
 
+  let () =
+    OASISHostPath.bash_cmd := bash_cmd
 end
 
 module BaseFileAB = struct
@@ -4452,7 +5040,7 @@
     OASISExec.run ~ctxt:!BaseContext.default ~quote:false
       (var_expand cmd)
       (List.map
-         var_expand
+         (var_expand ~quoted:true)
          (args @ (Array.to_list extra_args)))
 
 
@@ -4739,9 +5327,27 @@
 
   let configure t args =
     (* Run configure *)
+
+    (* use-bash is an exception. It's already needed to run the
+       pre-configure script. *)
+    let rec f = function
+      | [] ->
+        begin
+          try
+            let x = Sys.getenv "USE_BASH" in
+              OASISHostPath.bash_cmd := (fun () -> x);
+          with
+            _ -> ()
+        end
+      | "--use-bash"::x::_ ->
+          OASISHostPath.bash_cmd := (fun () -> x);
+      | _::tl -> f tl
+    in
+      f (Array.to_list args);
     BaseCustom.hook
       t.package.conf_custom
       (fun () ->
+           OASISHostPath.bash_cmd := BaseStandardVar.bash_cmd;
          (* Reload if preconf has changed it *)
          begin
            try
@@ -5006,11 +5612,14 @@
        s_ " Don't try to update setup.ml, even if _oasis has changed.")
 
 
+  let default_oasis_fn = "_oasis"
+
+
   let update_setup_ml t =
     let oasis_fn =
       match t.oasis_fn with
         | Some fn -> fn
-        | None -> "_oasis"
+        | None -> default_oasis_fn
     in
     let oasis_exec =
       match t.oasis_exec with
@@ -5108,7 +5717,8 @@
         try
           match t.oasis_digest with
             | Some dgst ->
-              if Sys.file_exists oasis_fn && dgst <> Digest.file "_oasis" then
+              if Sys.file_exists oasis_fn &&
+                 dgst <> Digest.file default_oasis_fn then
                 begin
                   do_update ();
                   true
@@ -5274,7 +5884,7 @@
 end
 
 
-# 5277 "setup.ml"
+# 5887 "setup.ml"
 module InternalConfigurePlugin = struct
 (* # 22 "src/plugins/internal/InternalConfigurePlugin.ml" *)
 
@@ -5570,11 +6180,19 @@
     "install-findlib"
 
 
-  let win32_max_command_line_length = 8000
-
-
   let split_install_command ocamlfind findlib_name meta files =
     if Sys.os_type = "Win32" then
+      let f s =
+        OASISHostPath.quote ( OASISHostPath.of_unix s )
+      in
+      let files = List.map f files in
+      let meta = f meta  in
+      let win32_max_command_line_length =
+        if OASISHostPath.use_bash () = false then
+          8000
+        else
+          30000
+      in
       (* Arguments for the first command: *)
       let first_args = ["install"; findlib_name; meta] in
       (* Arguments for remaining commands: *)
@@ -5710,6 +6328,17 @@
           lst
     in
 
+    let make_fnames modul sufx =
+      List.fold_right
+        begin fun sufx accu ->
+          (String.capitalize modul ^ sufx) ::
+          (String.uncapitalize modul ^ sufx) ::
+          accu
+        end
+        sufx
+        []
+    in
+
     (** Install all libraries *)
     let install_libs pkg =
 
@@ -5730,27 +6359,29 @@
                   OASISHostPath.of_unix bs.bs_path
                 in
                   List.fold_left
-                    (fun acc modul ->
-                       try
-                         List.find
-                           OASISFileUtil.file_exists_case
-                           (List.map
-                              (Filename.concat path)
-                              [modul^".mli";
-                               modul^".ml";
-                               String.uncapitalize modul^".mli";
-                               String.capitalize   modul^".mli";
-                               String.uncapitalize modul^".ml";
-                               String.capitalize   modul^".ml"])
-                         :: acc
-                       with Not_found ->
-                         begin
-                           warning
-                             (f_ "Cannot find source header for module %s \
-                                  in library %s")
-                             modul cs.cs_name;
-                           acc
-                         end)
+                    begin fun acc modul ->
+                      begin
+                        try
+                          [List.find
+                            OASISFileUtil.file_exists_case
+                            (List.map
+                               (Filename.concat path)
+                               (make_fnames modul [".mli"; ".ml"]))]
+                        with Not_found ->
+                          warning
+                            (f_ "Cannot find source header for module %s \
+                                 in library %s")
+                            modul cs.cs_name;
+                          []
+                      end
+                      @
+                      List.filter
+                        OASISFileUtil.file_exists_case
+                        (List.map
+                           (Filename.concat path)
+                           (make_fnames modul [".annot";".cmti";".cmt"]))
+                      @ acc
+                    end
                     acc
                     lib.lib_modules
               in
@@ -5798,27 +6429,29 @@
                   OASISHostPath.of_unix bs.bs_path
                 in
                   List.fold_left
-                    (fun acc modul ->
-                       try
-                         List.find
-                           OASISFileUtil.file_exists_case
-                           (List.map
-                              (Filename.concat path)
-                              [modul^".mli";
-                               modul^".ml";
-                               String.uncapitalize modul^".mli";
-                               String.capitalize   modul^".mli";
-                               String.uncapitalize modul^".ml";
-                               String.capitalize   modul^".ml"])
-                         :: acc
-                       with Not_found ->
-                         begin
-                           warning
-                             (f_ "Cannot find source header for module %s \
-                                  in object %s")
-                             modul cs.cs_name;
-                           acc
-                         end)
+                    begin fun acc modul ->
+                      begin
+                        try
+                          [List.find
+                             OASISFileUtil.file_exists_case
+                             (List.map
+                                (Filename.concat path)
+                                (make_fnames modul [".mli"; ".ml"]))]
+                        with Not_found ->
+                          warning
+                            (f_ "Cannot find source header for module %s \
+                                 in object %s")
+                            modul cs.cs_name;
+                          []
+                      end
+                      @
+                      List.filter
+                        OASISFileUtil.file_exists_case
+                        (List.map
+                           (Filename.concat path)
+                           (make_fnames modul [".annot";".cmti";".cmt"]))
+                      @ acc
+                    end
                     acc
                     obj.obj_modules
               in
@@ -6123,7 +6756,7 @@
 end
 
 
-# 6126 "setup.ml"
+# 6759 "setup.ml"
 module OCamlbuildCommon = struct
 (* # 22 "src/plugins/ocamlbuild/OCamlbuildCommon.ml" *)
 
@@ -6135,10 +6768,15 @@
   open OASISGettext
   open BaseEnv
   open BaseStandardVar
+  open OASISTypes
+
+
+
+
+  type extra_args = string list
 
 
-  let ocamlbuild_clean_ev =
-    "ocamlbuild-clean"
+  let ocamlbuild_clean_ev = "ocamlbuild-clean"
 
 
   let ocamlbuildflags =
@@ -6157,8 +6795,11 @@
             "-classic-display";
             "-no-log";
             "-no-links";
-            "-install-lib-dir";
-            (Filename.concat (standard_library ()) "ocamlbuild")
+            (* Fix not longer necassary since at least OCaml 3.11, see #4379.
+               In the future, it's the wrong location, because of the split of
+               ocamlbuild from the main distribution *)
+            (* "-install-lib-dir";
+               (OASISHostPath.quote (OASISHostPath.of_unix (Filename.concat (standard_library ()) "ocamlbuild"))) *)
           ]
         else
           [];
@@ -6176,6 +6817,11 @@
         else
           [];
 
+        if bool_of_string (tests ()) then
+          ["-tag"; "tests"]
+        else
+          [];
+
         if bool_of_string (profile ()) then
           ["-tag"; "profile"]
         else
@@ -6261,27 +6907,7 @@
     ref (fun lst -> lst)
 
 
-  type ocamlbuild_plugin =
-    {
-      plugin_tags: string option;
-      extra_args: string list;
-    } 
-
-
-  let check_ocaml_version version pkg =
-    match pkg.ocaml_version with
-      | Some ocaml_version ->
-          let min_ocaml_version = OASISVersion.version_of_string version in
-          OASISVersion.comparator_ge min_ocaml_version ocaml_version
-      | None ->
-          false
-
-
-  let ocamlbuild_supports_ocamlfind = check_ocaml_version "3.12.1"
-  let ocamlbuild_supports_plugin_tags = check_ocaml_version "4.01"
-
-
-  let build t pkg argv =
+  let build extra_args pkg argv =
     (* Return the filename in build directory *)
     let in_build_dir fn =
       Filename.concat
@@ -6425,33 +7051,13 @@
         (BaseBuilt.register bt bnm lst)
     in
 
-    let cond_targets =
-      (* Run the hook *)
-      !cond_targets_hook cond_targets
-    in
+    (* Run the hook *)
+    let cond_targets = !cond_targets_hook cond_targets in
 
-    let extra_args =
-      match t.plugin_tags with
-        | Some tags -> "-plugin-tags" :: ("'" ^ tags ^ "'") :: t.extra_args
-        | None -> t.extra_args
-    in
-    let extra_args =
-      if ocamlbuild_supports_ocamlfind pkg then
-        "-use-ocamlfind" :: extra_args
-      else
-        extra_args
-    in
-
-      (* Run a list of target... *)
-      run_ocamlbuild
-        (List.flatten
-           (List.map snd cond_targets)
-         @ extra_args)
-        argv;
-      (* ... and register events *)
-      List.iter
-        check_and_register
-        (List.flatten (List.map fst cond_targets))
+    (* Run a list of target... *)
+    run_ocamlbuild (List.flatten (List.map snd cond_targets) @ extra_args) argv;
+    (* ... and register events *)
+    List.iter check_and_register (List.flatten (List.map fst cond_targets))
 
 
   let clean pkg extra_args  =
@@ -6488,12 +7094,18 @@
 
 
 
+  type run_t =
+    {
+      extra_args: string list;
+      run_path: unix_filename;
+    }
+
 
-  let doc_build path pkg (cs, doc) argv =
+  let doc_build run pkg (cs, doc) argv =
     let index_html =
       OASISUnixPath.make
         [
-          path;
+          run.run_path;
           cs.cs_name^".docdir";
           "index.html";
         ]
@@ -6502,11 +7114,11 @@
       OASISHostPath.make
         [
           build_dir argv;
-          OASISHostPath.of_unix path;
+          OASISHostPath.of_unix run.run_path;
           cs.cs_name^".docdir";
         ]
     in
-      run_ocamlbuild [index_html] argv;
+      run_ocamlbuild (index_html :: run.extra_args) argv;
       List.iter
         (fun glb ->
            BaseBuilt.register
@@ -6517,7 +7129,7 @@
         ["*.html"; "*.css"]
 
 
-  let doc_clean t pkg (cs, doc) argv =
+  let doc_clean run pkg (cs, doc) argv =
     run_clean argv;
     BaseBuilt.unregister BaseBuilt.BDoc cs.cs_name
 
@@ -6525,15 +7137,13 @@
 end
 
 
-# 6528 "setup.ml"
+# 7140 "setup.ml"
 open OASISTypes;;
 
 let setup_t =
   {
      BaseSetup.configure = InternalConfigurePlugin.configure;
-     build =
-       OCamlbuildPlugin.build
-         {OCamlbuildPlugin.plugin_tags = None; extra_args = []};
+     build = OCamlbuildPlugin.build [];
      test = [];
      doc = [];
      install = InternalInstallPlugin.install;
@@ -6638,12 +7248,13 @@
             ];
           plugins =
             [(`Extra, "META", Some "0.3"); (`Extra, "DevFiles", Some "0.3")];
+          disable_oasis_section = [];
           schema_data = PropList.Data.create ();
           plugin_data = []
        };
      oasis_fn = Some "_oasis";
-     oasis_version = "0.4.1";
-     oasis_digest = Some "m\128obEF\141\134";
+     oasis_version = "0.4.5";
+     oasis_digest = Some "\163m\128o\231\203\215bE\230F\254\141\233\134\227";
      oasis_exec = None;
      oasis_setup_args = [];
      setup_update = false
@@ -6651,6 +7262,6 @@
 
 let setup () = BaseSetup.setup setup_t;;
 
-# 6655 "setup.ml"
+# 7266 "setup.ml"
 (* OASIS_STOP *)
 let () = setup ();;
