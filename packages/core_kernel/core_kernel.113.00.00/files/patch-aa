--- ./config/detect.sh
+++ ./config/detect.sh
@@ -4,7 +4,7 @@
 
 set -e
 
-if ld -lm -shared --wrap caml_modify -o /dev/null 2>/dev/null; then
+if "$LD" -lm -shared --wrap caml_modify -o /dev/null 2>/dev/null; then
     ld_wrap_possible=true
 else
     ld_wrap_possible=false
--- ./config/discover.sh
+++ ./config/discover.sh
@@ -7,7 +7,7 @@
     exit 2
 fi
 
-OCAMLC="$1"
+OCAMLC="$(cygpath -m "$1")"
 ML_OUTFILE="$2"
 C_OUTFILE="$3"
 shift 3
@@ -16,7 +16,7 @@
 OUT=config/test.out
 trap "rm -f $OUT" EXIT
 
-$OCAMLC -ccopt -E $OCAML_CFLAGS -c $SRC | grep '^"OUT:[^"]*"$' | sed 's/"OUT:\([^"]*\)"/\1/' | tee > $OUT
+"$OCAMLC" -ccopt -E $OCAML_CFLAGS -c $SRC | grep '^"OUT:[^"]*"$' | sed 's/"OUT:\([^"]*\)"/\1/' | tee > $OUT
 
 OCAML_VERSION="`ocamlc -version`"
 case "$OCAML_VERSION" in
--- ./myocamlbuild.ml
+++ ./myocamlbuild.ml
@@ -1,7 +1,7 @@
 (* OASIS_START *)
-(* DO NOT EDIT (digest: 293325619b977003dbabc19faaed3968) *)
+(* DO NOT EDIT (digest: f095268bd635abe6513bc11b137ff24f) *)
 module OASISGettext = struct
-(* # 22 "src/oasis/OASISGettext.ml" *)
+(* # 22 "src/oasis\\OASISGettext.ml" *)
 
 
   let ns_ str =
@@ -30,7 +30,7 @@
 end
 
 module OASISExpr = struct
-(* # 22 "src/oasis/OASISExpr.ml" *)
+(* # 22 "src/oasis\\OASISExpr.ml" *)
 
 
 
@@ -131,7 +131,7 @@
 
 # 132 "myocamlbuild.ml"
 module BaseEnvLight = struct
-(* # 22 "src/base/BaseEnvLight.ml" *)
+(* # 22 "src/base\\BaseEnvLight.ml" *)
 
 
   module MapString = Map.Make(String)
@@ -236,7 +236,7 @@
 
 # 237 "myocamlbuild.ml"
 module MyOCamlbuildFindlib = struct
-(* # 22 "src/plugins/ocamlbuild/MyOCamlbuildFindlib.ml" *)
+(* # 22 "src/plugins/ocamlbuild\\MyOCamlbuildFindlib.ml" *)
 
 
   (** OCamlbuild extension, copied from
@@ -314,7 +314,9 @@
     with Not_found -> s
 
   (* ocamlfind command *)
-  let ocamlfind x = S[Sh (exec_from_conf "ocamlfind"); x]
+  let ocamlfind x = S[Sh (
+    Ocamlbuild_pack.Shell.quote_filename_if_needed
+      (exec_from_conf "ocamlfind") ); x]
 
   (* This lists all supported packages. *)
   let find_packages () =
@@ -426,7 +428,7 @@
 end
 
 module MyOCamlbuildBase = struct
-(* # 22 "src/plugins/ocamlbuild/MyOCamlbuildBase.ml" *)
+(* # 22 "src/plugins/ocamlbuild\\MyOCamlbuildBase.ml" *)
 
 
   (** Base functions for writing myocamlbuild.ml
@@ -447,7 +449,7 @@
   type tag = string
 
 
-(* # 62 "src/plugins/ocamlbuild/MyOCamlbuildBase.ml" *)
+(* # 62 "src/plugins/ocamlbuild\\MyOCamlbuildBase.ml" *)
 
 
   type t =
@@ -603,7 +605,7 @@
 end
 
 
-# 606 "myocamlbuild.ml"
+# 608 "myocamlbuild.ml"
 open Ocamlbuild_plugin;;
 let package_default =
   {
@@ -635,7 +637,7 @@
 
 let dispatch_default = MyOCamlbuildBase.dispatch_default conf package_default;;
 
-# 639 "myocamlbuild.ml"
+# 641 "myocamlbuild.ml"
 (* OASIS_STOP *)
 
 let dispatch = function
--- ./setup.ml
+++ ./setup.ml
@@ -1,12 +1,12 @@
 (* OASIS_START *)
-(* DO NOT EDIT (digest: 7fd76dd93c86e35b7ca70ef88a0c2965) *)
+(* DO NOT EDIT (digest: a3888ccd7df5212735d3f56f24a4e285) *)
 (*
    Regenerated by OASIS v0.4.5
    Visit http://oasis.forge.ocamlcore.org for more information and
    documentation about functions used in this file.
 *)
 module OASISGettext = struct
-(* # 22 "src/oasis/OASISGettext.ml" *)
+(* # 22 "src/oasis\\OASISGettext.ml" *)
 
 
   let ns_ str =
@@ -35,7 +35,7 @@
 end
 
 module OASISContext = struct
-(* # 22 "src/oasis/OASISContext.ml" *)
+(* # 22 "src/oasis\\OASISContext.ml" *)
 
 
   open OASISGettext
@@ -115,7 +115,7 @@
 end
 
 module OASISString = struct
-(* # 22 "src/oasis/OASISString.ml" *)
+(* # 22 "src/oasis\\OASISString.ml" *)
 
 
   (** Various string utilities.
@@ -244,11 +244,33 @@
     String.iter (fun c -> Buffer.add_char buf (f c)) s;
     Buffer.contents buf
 
+  (** Like List.exists, but for strings *)
+  let exists f str =
+    let rec iter i =
+      if i < 0 then
+        false
+      else if f str.[i] then
+        true
+      else
+        iter (pred i)
+    in
+      iter (String.length str - 1)
+
+  let is_digit c =
+    '0' <= c && c <= '9'
+
+  let is_alpha c =
+    ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')
+
+  let is_whitespace =
+    function
+      | ' ' | '\r' | '\n' | '\t' -> true
+      |  _  -> false
 
 end
 
 module OASISUtils = struct
-(* # 22 "src/oasis/OASISUtils.ml" *)
+(* # 22 "src/oasis\\OASISUtils.ml" *)
 
 
   open OASISGettext
@@ -394,7 +416,7 @@
 end
 
 module PropList = struct
-(* # 22 "src/oasis/PropList.ml" *)
+(* # 22 "src/oasis\\PropList.ml" *)
 
 
   open OASISGettext
@@ -440,7 +462,7 @@
       Hashtbl.clear t
 
 
-(* # 78 "src/oasis/PropList.ml" *)
+(* # 78 "src/oasis\\PropList.ml" *)
   end
 
 
@@ -679,7 +701,7 @@
 end
 
 module OASISMessage = struct
-(* # 22 "src/oasis/OASISMessage.ml" *)
+(* # 22 "src/oasis\\OASISMessage.ml" *)
 
 
   open OASISGettext
@@ -723,7 +745,7 @@
 end
 
 module OASISVersion = struct
-(* # 22 "src/oasis/OASISVersion.ml" *)
+(* # 22 "src/oasis\\OASISVersion.ml" *)
 
 
   open OASISGettext
@@ -750,12 +772,10 @@
 
 
   (* Range of allowed characters *)
-  let is_digit c =
-    '0' <= c && c <= '9'
+  let is_digit = OASISString.is_digit
 
 
-  let is_alpha c =
-    ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')
+  let is_alpha = OASISString.is_alpha
 
 
   let is_special =
@@ -930,7 +950,7 @@
 end
 
 module OASISLicense = struct
-(* # 22 "src/oasis/OASISLicense.ml" *)
+(* # 22 "src/oasis\\OASISLicense.ml" *)
 
 
   (** License for _oasis fields
@@ -978,7 +998,7 @@
 end
 
 module OASISExpr = struct
-(* # 22 "src/oasis/OASISExpr.ml" *)
+(* # 22 "src/oasis\\OASISExpr.ml" *)
 
 
 
@@ -1077,7 +1097,7 @@
 end
 
 module OASISText = struct
-(* # 22 "src/oasis/OASISText.ml" *)
+(* # 22 "src/oasis\\OASISText.ml" *)
 
 
 
@@ -1092,7 +1112,7 @@
 end
 
 module OASISTypes = struct
-(* # 22 "src/oasis/OASISTypes.ml" *)
+(* # 22 "src/oasis\\OASISTypes.ml" *)
 
 
 
@@ -1181,7 +1201,7 @@
   type plugin_data = (all_plugin * plugin_data_purpose * (unit -> unit)) list
 
 
-(* # 115 "src/oasis/OASISTypes.ml" *)
+(* # 115 "src/oasis\\OASISTypes.ml" *)
 
 
   type 'a conditional = 'a OASISExpr.choices
@@ -1365,7 +1385,7 @@
 end
 
 module OASISFeatures = struct
-(* # 22 "src/oasis/OASISFeatures.ml" *)
+(* # 22 "src/oasis\\OASISFeatures.ml" *)
 
   open OASISTypes
   open OASISUtils
@@ -1735,7 +1755,7 @@
 end
 
 module OASISUnixPath = struct
-(* # 22 "src/oasis/OASISUnixPath.ml" *)
+(* # 22 "src/oasis\\OASISUnixPath.ml" *)
 
 
   type unix_filename = string
@@ -1832,7 +1852,7 @@
 end
 
 module OASISHostPath = struct
-(* # 22 "src/oasis/OASISHostPath.ml" *)
+(* # 22 "src/oasis\\OASISHostPath.ml" *)
 
 
   open Filename
@@ -1840,6 +1860,118 @@
 
   module Unix = OASISUnixPath
 
+  let bash_cmd = ref ( fun () -> "" )
+
+  let use_bash () = ( !bash_cmd () ) <> ""
+
+
+  (* generic quote and unixquote are taken from ocaml source *)
+  let generic_quote quotequote s =
+    let l = String.length s in
+    let b = Buffer.create (l + 20) in
+      Buffer.add_char b '\'';
+      for i = 0 to l - 1 do
+        if s.[i] = '\'' then
+          Buffer.add_string b quotequote
+        else
+          Buffer.add_char b  s.[i]
+      done;
+      Buffer.add_char b '\'';
+      Buffer.contents b
+
+  let unixquote = generic_quote "'\\''"
+
+  let win = Sys.os_type = "Win32"
+
+  let quote str =
+    if win && use_bash () then
+      unixquote str
+    else
+      quote str
+
+  (* uniform_path (only called, if Sys.os_type = "Win32")
+   * - enforces uniform path seperators
+   * - strips trailing slashes (exceptions in case of C:\ and / )
+   * - removes (some) unnecessary file components like ./././
+   *)
+
+  let get_naccu accu str first pos =
+    (* I assume c//d is identic to c/d
+     * the only exception (Network devices \\xyz\asdf)
+     * is covered in uniform_path
+     *)
+    if first = pos then
+      accu
+    else
+      let nlen = pos - first in
+      let nstr = String.sub str first nlen in
+        (* test/././ is the same as test *)
+        if nlen = 1 && nstr = "." then
+          accu
+        (* a/b/../ is the same as a *)
+        else if nlen = 2 && nstr = ".." then
+          match accu with
+            | []      -> [ nstr ]
+            | ".."::_ -> nstr::accu
+            | hd::tl  -> tl
+        else
+          nstr::accu
+
+  let is_path_sep = function
+    | '\\' | '/' -> true
+    | _ -> false
+
+
+  let uniform_path path_sep = function
+    | "" -> "" (* Raise an exception? Or an possible intermediate result?
+               * Filename.basename and dirname also don't raise exceptions *)
+    | str ->
+        let rec iter accu str len first pos =
+          if pos >= len then
+            List.rev (get_naccu accu str first pos)
+          else
+            let next = succ pos in
+              match is_path_sep str.[pos] with
+                | true -> iter (get_naccu accu str first pos) str len next next
+                | false -> iter accu str len first next
+        in
+          let is_unix_root = is_path_sep str.[0] in
+          let len = String.length str in
+          let next_sep = len > 1 && is_path_sep str.[1] in
+          let is_network_root = is_unix_root && next_sep in
+          let is_currel = str.[0] = '.' && ( next_sep || len = 1 ) in
+          let l = iter [] str len 0 0 in
+          (* Trailing slashes are normally stripped.
+           * This is not possible in case of root folders
+           * Sys.file_exists "C:" is false, Sys.file_exists "C:\\" true
+           *)
+          let l_min =
+            match l with
+              | [] -> [ "" ]
+              | _ -> l
+          in
+          let l =
+            if is_network_root then
+              ""::""::l_min
+            else if is_unix_root then
+              ""::l_min
+            else if is_currel then
+              "."::l
+            else
+              match l with
+                | s :: [] ->
+                    (* root folders like C:\ *)
+                    if String.length s = 2 && s.[1] = ':' &&
+                      len > 2 && is_path_sep str.[2]
+                    then
+                      s :: [ "" ]
+                    else
+                      l
+                | _ -> l
+          in
+            String.concat path_sep l
+
+
 
   let make =
     function
@@ -1849,26 +1981,38 @@
           List.fold_left Filename.concat hd tl
 
 
-  let of_unix ufn =
-    if Sys.os_type = "Unix" then
-      ufn
+  let of_unix str =
+    if win = false then
+      str
     else
-      make
-        (List.map
-           (fun p ->
-              if p = Unix.current_dir_name then
-                current_dir_name
-              else if p = Unix.parent_dir_name then
-                parent_dir_name
+      let path_sep =
+        if use_bash () then
+          "/"
               else
-                p)
-           (OASISString.nsplit ufn '/'))
+          "\\"
+      in
+        uniform_path path_sep str
+
+
+
+  (* see findlib's src/findlib/frontend.ml for details *)
+  let ocamlfind_unquote dir =
+    match Sys.os_type with
+      | "Cygwin"
+      | "Win32" ->
+        let len = String.length dir in
+          if len < 3 || dir.[0] <> '"' || dir.[len - 1] <> '"' ||
+            String.contains dir ' ' = false then
+            dir
+              else
+            String.sub dir 1 (len - 2)
+      | _ -> dir
 
 
 end
 
 module OASISSection = struct
-(* # 22 "src/oasis/OASISSection.ml" *)
+(* # 22 "src/oasis\\OASISSection.ml" *)
 
 
   open OASISTypes
@@ -1961,13 +2105,13 @@
 end
 
 module OASISBuildSection = struct
-(* # 22 "src/oasis/OASISBuildSection.ml" *)
+(* # 22 "src/oasis\\OASISBuildSection.ml" *)
 
 
 end
 
 module OASISExecutable = struct
-(* # 22 "src/oasis/OASISExecutable.ml" *)
+(* # 22 "src/oasis\\OASISExecutable.ml" *)
 
 
   open OASISTypes
@@ -2001,7 +2145,7 @@
 end
 
 module OASISLibrary = struct
-(* # 22 "src/oasis/OASISLibrary.ml" *)
+(* # 22 "src/oasis\\OASISLibrary.ml" *)
 
 
   open OASISTypes
@@ -2203,7 +2347,7 @@
 end
 
 module OASISObject = struct
-(* # 22 "src/oasis/OASISObject.ml" *)
+(* # 22 "src/oasis\\OASISObject.ml" *)
 
 
   open OASISTypes
@@ -2271,7 +2415,7 @@
 end
 
 module OASISFindlib = struct
-(* # 22 "src/oasis/OASISFindlib.ml" *)
+(* # 22 "src/oasis\\OASISFindlib.ml" *)
 
 
   open OASISTypes
@@ -2566,37 +2710,37 @@
 end
 
 module OASISFlag = struct
-(* # 22 "src/oasis/OASISFlag.ml" *)
+(* # 22 "src/oasis\\OASISFlag.ml" *)
 
 
 end
 
 module OASISPackage = struct
-(* # 22 "src/oasis/OASISPackage.ml" *)
+(* # 22 "src/oasis\\OASISPackage.ml" *)
 
 
 end
 
 module OASISSourceRepository = struct
-(* # 22 "src/oasis/OASISSourceRepository.ml" *)
+(* # 22 "src/oasis\\OASISSourceRepository.ml" *)
 
 
 end
 
 module OASISTest = struct
-(* # 22 "src/oasis/OASISTest.ml" *)
+(* # 22 "src/oasis\\OASISTest.ml" *)
 
 
 end
 
 module OASISDocument = struct
-(* # 22 "src/oasis/OASISDocument.ml" *)
+(* # 22 "src/oasis\\OASISDocument.ml" *)
 
 
 end
 
 module OASISExec = struct
-(* # 22 "src/oasis/OASISExec.ml" *)
+(* # 22 "src/oasis\\OASISExec.ml" *)
 
 
   open OASISGettext
@@ -2604,25 +2748,221 @@
   open OASISMessage
 
 
+
+
+  (* In general, there is no chance to quote properly with the current
+   * settings. ( This is only a problem, if BaseCustom.run is used (e.g
+   * test commands, PreConfigure,....). Most of the time, OASISExec.run
+   * is used with enabled quoting.)
+   *
+   * "$rm" should ideally expand to 'rm -f' (no quotes), but "$test_exec"
+   * should ideally expand to '"C:\Program Files\dir\test.exe"' (with
+   * quotes). Paths with spaces are common on Windows, so this problem
+   * can't be ignored.
+   *
+   * Using a command with additional parameters is quite useful, not only
+   * for trivial cases like $rm. You could add an additional parameter
+   * for $make in order to use a special compatibility mode, on windows
+   * you can use it to inform ocaml that a certain program is a shell
+   * script ('sh.exe pcre-config').
+   *
+   * An additional parameter (e.g. $rm_switches) would be ugly,
+   * especially for *nix users, who don't use space characters in their
+   * installation paths anyway.
+   *
+   * I use the following workaround, which should work most of the time:
+   *
+   * - if cmd doesn't contains spaces or other suspicious characters, it
+   * can be quoted in the usual way (not ambigous, I think)
+   *
+   * - if cmd does contain spaces, a file with this name exists, and the
+   * beginning of cmd looks like a absolute pathname
+   * ('\\test\dir\foo.exe' or "C:\\sa df\\foo.exe" - not "foo.exe" ), I
+   * will also quote it. (ambigous, there could be "C:\bin\rm.exe" and
+   * "C:\bin\rm -f.exe").  Relative filenames are not considered, because
+   * I assume the source code folder contains only well named files and
+   * relative paths like "../../make.exe" are uncommon (autoconf even
+   * rejects them) *)
+
+
+  (* stricter settings as for regular windows batch lines
+   * necessary because of shell comannds like:
+   *   LC_ALL=C make ....
+   *)
+  let is_dubious_char = function
+    | '~' | ':' | '.' | '-' | '_' | '/' | '\\' -> false
+    | c ->
+      OASISString.is_digit c = false &&
+      OASISString.is_alpha c = false
+
+
+  let win_quote_needed str =
+    let f = function
+      (* this list is not exhaustive. Feel free to added common chars, that
+       * can be passed to cmd.exe without quoting *)
+      | 'a' .. 'z'  | 'A' .. 'Z' | '0' .. '9'
+      | '_' | '-' | '~' | '.' | ':' | ',' | '\\' -> false
+      | _ -> true
+    in
+      str = "" || OASISString.exists f str
+
+  let is_simple_command str =
+    String.length str > 0 &&
+    not (OASISString.exists is_dubious_char str)
+
+  let is_path_sep = function
+    | '/' | '\\' -> true
+    | _ -> false
+
+  let starts_with_absolute_path cmd =
+    let len = String.length cmd in
+      if len < 3 then
+        false
+      else
+        let c0 = cmd.[0] in
+        let c1 = cmd.[1] in
+          if is_path_sep c0 && is_path_sep c1 then (* network devices: "//" *)
+            true
+          else if len = 3 then
+            false
+          else  (* C:\.... *)
+            OASISString.is_alpha c0 && c1 = ':' && is_path_sep cmd.[2]
+
+  let exe_exts = lazy
+    begin
+      let exts =
+        try
+          OASISString.nsplit
+            (Sys.getenv "PATHEXT")
+            ';'
+        with
+          | Not_found -> []
+      in
+      let exts' =
+        List.filter
+          ( fun a -> a <> "" && a.[0] = '.' && a <> ".EXE" )
+          (List.map String.uppercase exts) (* windows file system doesn't care *)
+      in
+        ".EXE"::exts' (* .exe first, most common *)
+    end
+
+  let exe_file_exists fln =
+    Sys.file_exists fln ||
+    List.exists
+      (fun a -> Sys.file_exists ( fln ^ a ) )
+      (Lazy.force exe_exts)
+
+
+  let quote_anyway cmd =
+    if Sys.os_type <> "Win32" then (* workaround for windows only *)
+      false
+    else if is_simple_command cmd then
+      true
+    else
+      OASISString.exists OASISString.is_whitespace cmd &&
+        starts_with_absolute_path cmd &&
+        exe_file_exists cmd
+
+
+  let run_bash ~ctxt ?f_exit_code ?(quote=true) cmd args =
+    let fn = Filename.temp_file "oasis-" ".sh" in
+    let fn_deleted = ref false in
+      try
+        begin
+          let ch = open_out_bin fn in
+          let ch_closed = ref false in
+            try
+              begin
+                let cmd =
+                  if quote || quote_anyway cmd then
+                    OASISHostPath.quote (OASISHostPath.of_unix cmd)
+                  else
+                    cmd
+                in
+                  output_string ch cmd;
+                  List.iter
+                    ( fun s -> output_char ch ' '; output_string ch s )
+                    args ;
+                  output_char ch '\n';
+                  ch_closed:=true ;
+                  close_out ch;
+                  let bash = !OASISHostPath.bash_cmd () in
+                  let add_quotes = ref false in
+                  let shell_cmd =
+                    if Sys.os_type <> "Win32" then
+                      Filename.quote bash
+                    else
+                      if win_quote_needed bash = false then
+                        bash
+                      else
+                        begin
+                          add_quotes := true;
+                          Filename.quote bash
+                        end
+                  in
+                  let cmdline_orig = String.concat " " (cmd :: args) in
+                  let cmdline =
+                    let s = shell_cmd ^ " " ^ (Filename.quote fn) in
+                      if !add_quotes then
+                        "\"" ^ s ^ "\""
+                      else
+                        s
+                  in
+                    info ~ctxt (f_ "Running command '%s'") cmdline_orig;
+                    let ret = Sys.command cmdline in
+                      fn_deleted := true;
+                      Sys.remove fn;
+                      match f_exit_code, ret with
+                        | None, 0 -> ()
+                        | None, i ->
+                            failwithf
+                              (f_ "Command '%s' terminated with error code %d")
+                              cmdline_orig i
+                        | Some f, i ->
+                            f i
+              end
+            with
+              | x when !ch_closed = false ->
+                  close_out_noerr ch;
+                  raise x
+        end
+      with
+        | x when !fn_deleted = false ->
+            (try Sys.remove fn with _ -> () ) ;
+            raise x
+
   (* TODO: I don't like this quote, it is there because $(rm) foo expands to
    * 'rm -f' foo...
    *)
-  let run ~ctxt ?f_exit_code ?(quote=true) cmd args =
+
+  let run_default ~ctxt ?f_exit_code ?(quote=true) cmd args =
+    let add_quotes = ref false in
     let cmd =
-      if quote then
+      if quote || quote_anyway cmd then
         if Sys.os_type = "Win32" then
-          if String.contains cmd ' ' then
-            (* Double the 1st double quote... win32... sigh *)
-            "\""^(Filename.quote cmd)
-          else
+          begin
+            if win_quote_needed cmd = false then
             cmd
         else
+              begin
+                (* Double the 1st double quote... win32... sigh *)
+                (* Above comment ist false. The whole string must be quoted.
+                 * However, an error is only triggered, if args contains also
+                 * quoted parameters *)
+                add_quotes := true;
+                Filename.quote cmd
+              end
+          end
+        else
           Filename.quote cmd
       else
         cmd
     in
     let cmdline =
-      String.concat " " (cmd :: args)
+      let s = String.concat " " (cmd :: args) in
+        match !add_quotes with
+          | true -> "\"" ^ s ^ "\""
+          | false -> s
     in
       info ~ctxt (f_ "Running command '%s'") cmdline;
       match f_exit_code, Sys.command cmdline with
@@ -2635,6 +2975,13 @@
             f i
 
 
+
+  let run ~ctxt ?f_exit_code ?quote cmd args =
+    if OASISHostPath.use_bash () then
+      run_bash ~ctxt ?f_exit_code ?quote cmd args
+    else
+      run_default ~ctxt ?f_exit_code ?quote cmd args
+
   let run_read_output ~ctxt ?f_exit_code cmd args =
     let fn =
       Filename.temp_file "oasis-" ".txt"
@@ -2678,7 +3025,7 @@
 end
 
 module OASISFileUtil = struct
-(* # 22 "src/oasis/OASISFileUtil.ml" *)
+(* # 22 "src/oasis\\OASISFileUtil.ml" *)
 
 
   open OASISGettext
@@ -2760,7 +3107,10 @@
         | _ ->
             [""]
     in
+    let p =
       find_file ~case_sensitive:false [path_lst; [prg]] exec_ext
+    in
+      OASISHostPath.of_unix p
 
 
   (**/**)
@@ -2777,32 +3127,55 @@
         dn
 
 
-  let q = Filename.quote
+  let q s = OASISHostPath.quote (OASISHostPath.of_unix s)
   (**/**)
 
 
   let cp ~ctxt ?(recurse=false) src tgt =
     if recurse then
-      match Sys.os_type with
-        | "Win32" ->
-            OASISExec.run ~ctxt
-              "xcopy" [q src; q tgt; "/E"]
-        | _ ->
-            OASISExec.run ~ctxt
-              "cp" ["-r"; q src; q tgt]
+      (*
+        'xcopy /E' and 'cp -r' don't have the same semantic!
+        -dir2 does exist:
+          xcopy dir dir2 /E -> copys content of dir into dir2 (dir2/dir doesn't exist!)
+          cp -r dir dir2    -> copys dir to dir2 (dir2/dir does exist!)
+        -dir2 doesn't exist:
+          xcopy dir dir2 /E -> request on command line, if dir2 is an directory or file.
+          cp -r dir dir2    -> dir and dir2 have the same content (dir2/dir doesn't exist)
+        Probably, there are even more differences,....
+      *)
+      if Sys.os_type = "Win32" && OASISHostPath.use_bash () = false then
+        let tgt_real =
+          if Sys.file_exists tgt = false then
+            begin
+              OASISExec.run ~ctxt "md" [q tgt];
+              tgt
+            end
     else
-      OASISExec.run ~ctxt
-        (match Sys.os_type with
-         | "Win32" -> "copy"
-         | _ -> "cp")
-        [q src; q tgt]
+            let base = Filename.basename src in
+            if base = "." then
+              tgt
+            else
+              let tgt_real = Filename.concat tgt base in
+                if Sys.file_exists tgt_real = false then
+                  OASISExec.run ~ctxt "md" [q tgt_real];
+              tgt_real
+        in
+        OASISExec.run ~ctxt "xcopy" [q src; q tgt_real; "/E" ; "/Q" ; "/Y"]
+      else
+        OASISExec.run ~ctxt "cp" ["-r"; q src; q tgt]
+    else
+      if Sys.os_type = "Win32" && OASISHostPath.use_bash () = false then
+        OASISExec.run ~ctxt "copy" [q src; q tgt ; "/Y"]
+      else
+        OASISExec.run ~ctxt "cp" [q src; q tgt]
 
 
   let mkdir ~ctxt tgt =
     OASISExec.run ~ctxt
-      (match Sys.os_type with
-         | "Win32" -> "md"
-         | _ -> "mkdir")
+      ( if Sys.os_type = "Win32" && not (OASISHostPath.use_bash ()) then
+          "md"
+        else
+          "mkdir" )
       [q tgt]
 
 
@@ -2831,10 +3204,9 @@
 
   let rmdir ~ctxt tgt =
     if Sys.readdir tgt = [||] then begin
-      match Sys.os_type with
-        | "Win32" ->
+      if Sys.os_type = "Win32" && OASISHostPath.use_bash () = false then
             OASISExec.run ~ctxt "rd" [q tgt]
-        | _ ->
+      else
             OASISExec.run ~ctxt "rm" ["-r"; q tgt]
     end else begin
       OASISMessage.error ~ctxt
@@ -2888,9 +3260,9 @@
 end
 
 
-# 2893 "setup.ml"
+# 3265 "setup.ml"
 module BaseEnvLight = struct
-(* # 22 "src/base/BaseEnvLight.ml" *)
+(* # 22 "src/base\\BaseEnvLight.ml" *)
 
 
   module MapString = Map.Make(String)
@@ -2993,9 +3365,9 @@
 end
 
 
-# 2998 "setup.ml"
+# 3370 "setup.ml"
 module BaseContext = struct
-(* # 22 "src/base/BaseContext.ml" *)
+(* # 22 "src/base\\BaseContext.ml" *)
 
   (* TODO: get rid of this module. *)
   open OASISContext
@@ -3009,7 +3381,7 @@
 end
 
 module BaseMessage = struct
-(* # 22 "src/base/BaseMessage.ml" *)
+(* # 22 "src/base\\BaseMessage.ml" *)
 
 
   (** Message to user, overrid for Base
@@ -3033,7 +3405,7 @@
 end
 
 module BaseEnv = struct
-(* # 22 "src/base/BaseEnv.ml" *)
+(* # 22 "src/base\\BaseEnv.ml" *)
 
   open OASISGettext
   open OASISUtils
@@ -3087,7 +3459,7 @@
     Genlex.make_lexer []
 
 
-  let rec var_expand str =
+  let rec var_expand ?(quoted=false) str =
     let buff =
       Buffer.create ((String.length str) * 2)
     in
@@ -3115,7 +3487,11 @@
                  | [Genlex.Ident "ocaml_escaped"; Genlex.String s] ->
                      String.escaped s
                  | [Genlex.Ident nm] ->
-                     var_get nm
+                     let s = var_get nm in
+                     if quoted then
+                       OASISHostPath.quote s
+                     else
+                       s
                  | _ ->
                      failwithf
                        (f_ "Unknown expression '%s' in variable expansion of %s.")
@@ -3515,7 +3891,7 @@
 end
 
 module BaseArgExt = struct
-(* # 22 "src/base/BaseArgExt.ml" *)
+(* # 22 "src/base\\BaseArgExt.ml" *)
 
 
   open OASISUtils
@@ -3545,7 +3921,7 @@
 end
 
 module BaseCheck = struct
-(* # 22 "src/base/BaseCheck.ml" *)
+(* # 22 "src/base\\BaseCheck.ml" *)
 
 
   open BaseEnv
@@ -3645,9 +4021,11 @@
     in
     let findlib_dir pkg =
       let dir =
+        OASISHostPath.of_unix (
+          OASISHostPath.ocamlfind_unquote (
         OASISExec.run_read_one_line ~ctxt:!BaseContext.default
           (ocamlfind ())
-          ["query"; "-format"; "%d"; pkg]
+              ["query"; "-format"; "%d"; pkg] ) )
       in
         if Sys.file_exists dir && Sys.is_directory dir then
           dir
@@ -3679,7 +4057,7 @@
 end
 
 module BaseOCamlcConfig = struct
-(* # 22 "src/base/BaseOCamlcConfig.ml" *)
+(* # 22 "src/base\\BaseOCamlcConfig.ml" *)
 
 
   open BaseEnv
@@ -3777,6 +4155,9 @@
       match nm with
         | "ocaml_version" ->
             "version", chop_version_suffix
+        | "standard_library"
+        | "standard_library_default" ->
+            nm, ( fun x -> OASISHostPath.of_unix x)
         | _ -> nm, (fun x -> x)
     in
       var_redefine
@@ -3799,7 +4180,7 @@
 end
 
 module BaseStandardVar = struct
-(* # 22 "src/base/BaseStandardVar.ml" *)
+(* # 22 "src/base\\BaseStandardVar.ml" *)
 
 
   open OASISGettext
@@ -3917,15 +4298,27 @@
 
 
   let (/) a b =
-    if os_type () = Sys.os_type then
+    let os = os_type () in
+      if os = Sys.os_type then
+        if Sys.os_type = "Win32" && OASISHostPath.use_bash () then
+          OASISUnixPath.concat a b
+        else
       Filename.concat a b
-    else if os_type () = "Unix" then
+      else if os = "Unix" then
       OASISUnixPath.concat a b
     else
       OASISUtils.failwithf (f_ "Cannot handle os_type %s filename concat")
         (os_type ())
   (**/**)
 
+  let bash_cmd =
+    var_define
+      ~short_desc:(fun () -> s_ "Enforced bash shell:")
+      ~cli:CLIAuto
+      ~arg_help:"program"
+      "use_bash"
+      (fun () -> "")
+
 
   let prefix =
     p "prefix"
@@ -3933,10 +4326,30 @@
       (fun () ->
          match os_type () with
            | "Win32" ->
+               let getenv w =
+                 try
+                   Some(Sys.getenv w)
+                 with
+                   | Not_found -> None
+               in
+               let s =
+                 if Sys.word_size = 64 then
+                   getenv "ProgramW6432"
+                 else
+                   None
+               in
+               let s =
+                 if s = None then
+                   getenv "PROGRAMFILES"
+                 else
+                   s
+               in
                let program_files =
-                 Sys.getenv "PROGRAMFILES"
+                 match s with
+                   | None -> "C:\\Program Files"
+                   | Some x -> x
                in
-                 program_files/(pkg_name ())
+                 OASISHostPath.of_unix (program_files/(pkg_name ()))
            | _ ->
                "/usr/local")
 
@@ -4022,7 +4435,15 @@
   let docdir =
     p "docdir"
       (fun () -> s_ "Documentation root")
-      (fun () -> "$datarootdir"/"doc"/"$pkg_name")
+      (fun () ->
+        (* TODO: (Windows only?) "$pkg_name" is not always substituted
+         * (at least if datarootdir contains spaces or other garbage)
+         * I haven't looked up why.
+         *)
+        match os_type () with
+          | "Win32" -> "$datarootdir"/"doc"/ ( pkg_name () )
+          | _ -> "$datarootdir"/"doc"/"$pkg_name"
+      )
 
 
   let htmldir =
@@ -4096,9 +4517,10 @@
       ~short_desc:(fun () -> s_ "Remove a file.")
       "rm"
       (fun () ->
-         match os_type () with
-           | "Win32" -> "del"
-           | _ -> "rm -f")
+         if not (OASISHostPath.use_bash ()) && os_type () = "Win32" then
+           "del"
+         else
+           "rm -f" )
 
 
   let rmdir =
@@ -4106,9 +4528,10 @@
       ~short_desc:(fun () -> s_ "Remove a directory.")
       "rmdir"
       (fun () ->
-         match os_type () with
-           | "Win32" -> "rd"
-           | _ -> "rm -rf")
+         if not (OASISHostPath.use_bash ()) && os_type () = "Win32" then
+           "rd"
+         else
+           "rm -rf")
 
 
   let debug =
@@ -4172,14 +4595,29 @@
            let has_native_dynlink =
              let ocamlfind = ocamlfind () in
                try
-                 let fn =
+                 (* -format %d/%a doesn't work, because ocamlfind quotes %d
+                  * and %a separatly *)
+                 let fn1 =
+                   OASISHostPath.ocamlfind_unquote (
+                     OASISExec.run_read_one_line
+                       ~ctxt:!BaseContext.default
+                       ocamlfind
+                       ["query"; "-predicates"; "native"; "dynlink";
+                        "-format"; "%d"] )
+                 in
+                 let fn2 =
+                   OASISHostPath.ocamlfind_unquote (
                    OASISExec.run_read_one_line
                      ~ctxt:!BaseContext.default
                      ocamlfind
                      ["query"; "-predicates"; "native"; "dynlink";
-                      "-format"; "%d/%a"]
+                        "-format"; "%a"] )
                  in
-                   Sys.file_exists fn
+                   if fn1 <> "" && fn2 <> "" &&
+                     Sys.file_exists (Filename.concat fn1 fn2) then
+                     true
+                   else
+                     false
                with _ ->
                  false
            in
@@ -4206,10 +4644,12 @@
     rpkg := Some pkg;
     List.iter (fun f -> f pkg.oasis_version) !var_cond
 
+  let () =
+    OASISHostPath.bash_cmd := bash_cmd
 end
 
 module BaseFileAB = struct
-(* # 22 "src/base/BaseFileAB.ml" *)
+(* # 22 "src/base\\BaseFileAB.ml" *)
 
 
   open BaseEnv
@@ -4260,7 +4700,7 @@
 end
 
 module BaseLog = struct
-(* # 22 "src/base/BaseLog.ml" *)
+(* # 22 "src/base\\BaseLog.ml" *)
 
 
   open OASISUtils
@@ -4387,7 +4827,7 @@
 end
 
 module BaseBuilt = struct
-(* # 22 "src/base/BaseBuilt.ml" *)
+(* # 22 "src/base\\BaseBuilt.ml" *)
 
 
   open OASISTypes
@@ -4565,7 +5005,7 @@
 end
 
 module BaseCustom = struct
-(* # 22 "src/base/BaseCustom.ml" *)
+(* # 22 "src/base\\BaseCustom.ml" *)
 
 
   open BaseEnv
@@ -4578,7 +5018,7 @@
     OASISExec.run ~ctxt:!BaseContext.default ~quote:false
       (var_expand cmd)
       (List.map
-         var_expand
+         (var_expand ~quoted:true)
          (args @ (Array.to_list extra_args)))
 
 
@@ -4618,7 +5058,7 @@
 end
 
 module BaseDynVar = struct
-(* # 22 "src/base/BaseDynVar.ml" *)
+(* # 22 "src/base\\BaseDynVar.ml" *)
 
 
   open OASISTypes
@@ -4666,7 +5106,7 @@
 end
 
 module BaseTest = struct
-(* # 22 "src/base/BaseTest.ml" *)
+(* # 22 "src/base\\BaseTest.ml" *)
 
 
   open BaseEnv
@@ -4758,7 +5198,7 @@
 end
 
 module BaseDoc = struct
-(* # 22 "src/base/BaseDoc.ml" *)
+(* # 22 "src/base\\BaseDoc.ml" *)
 
 
   open BaseEnv
@@ -4795,7 +5235,7 @@
 end
 
 module BaseSetup = struct
-(* # 22 "src/base/BaseSetup.ml" *)
+(* # 22 "src/base\\BaseSetup.ml" *)
 
   open BaseEnv
   open BaseMessage
@@ -4865,9 +5305,27 @@
 
   let configure t args =
     (* Run configure *)
+
+    (* use-bash is an exception. It's already needed to run the
+       pre-configure script. *)
+    let rec f = function
+      | [] ->
+        begin
+          try
+            let x = Sys.getenv "USE_BASH" in
+              OASISHostPath.bash_cmd := (fun () -> x);
+          with
+            _ -> ()
+        end
+      | "--use-bash"::x::_ ->
+          OASISHostPath.bash_cmd := (fun () -> x);
+      | _::tl -> f tl
+    in
+      f (Array.to_list args);
     BaseCustom.hook
       t.package.conf_custom
       (fun () ->
+           OASISHostPath.bash_cmd := BaseStandardVar.bash_cmd;
          (* Reload if preconf has changed it *)
          begin
            try
@@ -5404,9 +5862,9 @@
 end
 
 
-# 5409 "setup.ml"
+# 5867 "setup.ml"
 module InternalConfigurePlugin = struct
-(* # 22 "src/plugins/internal/InternalConfigurePlugin.ml" *)
+(* # 22 "src/plugins/internal\\InternalConfigurePlugin.ml" *)
 
 
   (** Configure using internal scheme
@@ -5655,7 +6113,7 @@
 end
 
 module InternalInstallPlugin = struct
-(* # 22 "src/plugins/internal/InternalInstallPlugin.ml" *)
+(* # 22 "src/plugins/internal\\InternalInstallPlugin.ml" *)
 
 
   (** Install using internal scheme
@@ -5700,11 +6158,19 @@
     "install-findlib"
 
 
-  let win32_max_command_line_length = 8000
-
-
   let split_install_command ocamlfind findlib_name meta files =
     if Sys.os_type = "Win32" then
+      let f s =
+        OASISHostPath.quote ( OASISHostPath.of_unix s )
+      in
+      let files = List.map f files in
+      let meta = f meta  in
+      let win32_max_command_line_length =
+        if OASISHostPath.use_bash () = false then
+          8000
+        else
+          30000
+      in
       (* Arguments for the first command: *)
       let first_args = ["install"; findlib_name; meta] in
       (* Arguments for remaining commands: *)
@@ -6268,9 +6734,9 @@
 end
 
 
-# 6273 "setup.ml"
+# 6739 "setup.ml"
 module OCamlbuildCommon = struct
-(* # 22 "src/plugins/ocamlbuild/OCamlbuildCommon.ml" *)
+(* # 22 "src/plugins/ocamlbuild\\OCamlbuildCommon.ml" *)
 
 
   (** Functions common to OCamlbuild build and doc plugin
@@ -6308,7 +6774,7 @@
             "-no-log";
             "-no-links";
             "-install-lib-dir";
-            (Filename.concat (standard_library ()) "ocamlbuild")
+            (OASISHostPath.quote (OASISHostPath.of_unix (Filename.concat (standard_library ()) "ocamlbuild")))
           ]
         else
           [];
@@ -6391,7 +6857,7 @@
 end
 
 module OCamlbuildPlugin = struct
-(* # 22 "src/plugins/ocamlbuild/OCamlbuildPlugin.ml" *)
+(* # 22 "src/plugins/ocamlbuild\\OCamlbuildPlugin.ml" *)
 
 
   (** Build using ocamlbuild
@@ -6586,7 +7052,7 @@
 end
 
 module OCamlbuildDocPlugin = struct
-(* # 22 "src/plugins/ocamlbuild/OCamlbuildDocPlugin.ml" *)
+(* # 22 "src/plugins/ocamlbuild\\OCamlbuildDocPlugin.ml" *)
 
 
   (* Create documentation using ocamlbuild .odocl files
@@ -6646,9 +7112,9 @@
 end
 
 
-# 6651 "setup.ml"
+# 7117 "setup.ml"
 module CustomPlugin = struct
-(* # 22 "src/plugins/custom/CustomPlugin.ml" *)
+(* # 22 "src/plugins/custom\\CustomPlugin.ml" *)
 
 
   (** Generate custom configure/build/doc/test/install system
@@ -6794,7 +7260,7 @@
 end
 
 
-# 6799 "setup.ml"
+# 7265 "setup.ml"
 open OASISTypes;;
 
 let setup_t =
@@ -7359,7 +7825,7 @@
        };
      oasis_fn = Some "_oasis";
      oasis_version = "0.4.5";
-     oasis_digest = Some "-\192\185_\138\163\220g\234gu\011\162L\225\179";
+     oasis_digest = Some "-À¹_Š£Ügêgu\011¢Lá³";
      oasis_exec = None;
      oasis_setup_args = [];
      setup_update = false
@@ -7367,7 +7833,7 @@
 
 let setup () = BaseSetup.setup setup_t;;
 
-# 7373 "setup.ml"
+# 7839 "setup.ml"
 (* OASIS_STOP *)
 
 let () =
--- ./src/bigstring_marshal_stubs.c
+++ ./src/bigstring_marshal_stubs.c
@@ -30,12 +30,12 @@
 }
 
 extern CAMLprim void
-caml_output_value_to_malloc(value v, value v_flags, char **buf_p, long *len);
+caml_output_value_to_malloc(value v, value v_flags, char **buf_p, intnat *len);
 
 CAMLprim value bigstring_marshal_stub(value v, value v_flags)
 {
   char *buf;
-  long len;
+  intnat len;
   int alloc_flags = CAML_BA_CHAR | CAML_BA_C_LAYOUT | CAML_BA_MANAGED;
   caml_output_value_to_malloc(v, v_flags, &buf, &len);
   return caml_ba_alloc(alloc_flags, 1, buf, &len);
--- ./src/bigstring_stubs.c
+++ ./src/bigstring_stubs.c
@@ -21,6 +21,13 @@
 #define bswap_16 OSSwapInt16
 #define bswap_32 OSSwapInt32
 #define bswap_64 OSSwapInt64
+#elif __MINGW32__
+static inline uint16_t bswap_16 (uint16_t x)
+{
+    return (x << 8) | (x >> 8);
+}
+#define bswap_32 __builtin_bswap32
+#define bswap_64 __builtin_bswap64
 #elif __GLIBC__
 #include <byteswap.h>
 #include <malloc.h>
@@ -146,7 +153,7 @@
                               value v_pos, value v_len)
 {
   char *start, *r;
-  long ret;
+  intnat ret;
 
   start = get_bstr(v_str, v_pos);
   r = (char*) memchr(start, Int_val(v_needle), Long_val(v_len));
--- ./src/byte_units.ml
+++ ./src/byte_units.ml
@@ -188,7 +188,7 @@
   TEST = f (`Specific `Bytes)     "3k" "3072b"
   TEST = f (`Specific `Kilobytes) "3k" "3k"
   TEST = f (`Specific `Megabytes) "3k" "0.00292969m"
-  TEST = f (`Specific `Gigabytes) "3k" "2.86102e-06g"
+  TEST = f (`Specific `Gigabytes) "3k" (match Sys.os_type with |"Win32" -> "2.86102e-006g" | _ -> "2.86102e-06g")
   TEST = f (`Specific `Words)     "3k" (sprintf "%gw" ((3.0 *. kbyte) /. bytes_per_word))
 
 end
--- ./src/core_gc_stubs.c
+++ ./src/core_gc_stubs.c
@@ -16,9 +16,9 @@
 extern intnat caml_stat_compactions;
 extern intnat caml_stat_heap_chunks;
 
-static long minor_words(void)
+static intnat minor_words(void)
 {
-  return (long) (caml_stat_minor_words +
+  return (intnat) (caml_stat_minor_words +
             (double) Wsize_bsize (caml_young_end - caml_young_ptr));
 }
 
@@ -27,9 +27,9 @@
   return Val_long(minor_words());
 }
 
-static long major_words(void)
+static intnat major_words(void)
 {
-  return (long) (caml_stat_major_words + (double) caml_allocated_words);
+  return (intnat) (caml_stat_major_words + (double) caml_allocated_words);
 }
 
 CAMLprim value core_kernel_gc_major_words(value unit __attribute__((unused)))
@@ -39,7 +39,7 @@
 
 CAMLprim value core_kernel_gc_promoted_words(value unit __attribute__((unused)))
 {
-  return Val_long((long) caml_stat_promoted_words);
+  return Val_long((intnat) caml_stat_promoted_words);
 }
 
 CAMLprim value core_kernel_gc_minor_collections(value unit __attribute__((unused)))
--- ./src/float.ml
+++ ./src/float.ml
@@ -292,7 +292,7 @@
 TEST = to_string_round_trippable 3.1400000000000004               = "3.1400000000000006"
 TEST = to_string_round_trippable 8.000000000000002                = "8.0000000000000018"
 TEST = to_string_round_trippable 9.992                            = "9.992"
-TEST = to_string_round_trippable (2.**63. *. (1. +. 2.** (-52.))) = "9.2233720368547779e+18"
+TEST = to_string_round_trippable (2.**63. *. (1. +. 2.** (-52.))) = (match Sys.os_type with |"Win32" -> "9.2233720368547779e+018" | _ -> "9.2233720368547779e+18" )
 TEST = to_string_round_trippable (-3.)                            = "-3."
 TEST = to_string_round_trippable nan                              = "nan"
 TEST = to_string_round_trippable infinity                         = "inf"
--- ./test/pool_caml_modify_check.ml
+++ ./test/pool_caml_modify_check.ml
@@ -4,7 +4,7 @@
    This can be very easily broken, and as such we're adding these tests to detect when
    this may have happened. *)
 
-open Core.Std
+open Core_kernel.Std
 open Check_caml_modify
 
 (* Big enough length so an array goes directly into the major heap. *)
